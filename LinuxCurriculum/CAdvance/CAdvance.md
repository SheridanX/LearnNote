​    

# 目录

[第一章 内存这个大话题. 1](#_Toc39573162)

[4.1.0 章节概要.... 1](#_Toc39573163)

[4.1.1.程序运行为什么需要内存.... 2](#_Toc39573164)

[4.1.3.位、字节、半字、字的概念和内存位宽.... 4](#_Toc39573165)

[4.1.4.内存编址和寻址、内存对齐.... 6](#_Toc39573166)

[4.1.5.C语言如何操作内存.... 7](#_Toc39573167)

[4.1.6.内存管理之结构体.... 9](#_Toc39573168)

[4.1.7、内存管理之栈（stack）.... 11](#_Toc39573169)

[4.1.8、内存管理之堆.... 12](#_Toc39573170)

[4.1.9、复杂数据结构.... 13](#_Toc39573171)

[第二章 C语言位操作. 15](#_Toc39573172)

[4.2.0 章节概要.... 15](#_Toc39573173)

[4.2.1.位操作符.... 15](#_Toc39573174)

[4.2.2.位与位或位异或在操作寄存器时的特殊作用... 17](#_Toc39573175)

[4.2.3.如何用位运算构建特定二进制数.... 18](#_Toc39573176)

[4.2.4.位运算实战演练1. 19](#_Toc39573177)

[4.2.5.位运算实战演练2. 20](#_Toc39573178)

[4.2.6.技术升级：用宏定义来完成位运算.... 21](#_Toc39573179)

[第三章 指针才是C的精髓. 22](#_Toc39573180)

[4.3.0 章节概要.... 22](#_Toc39573181)

[4.3.1.指针到底是什么？.... 23](#_Toc39573182)

[4.3.3.野指针问题.... 24](#_Toc39573183)

[4.3.4.const关键字与指针... 26](#_Toc39573184)

[4.3.5.深入学习一下数组.... 27](#_Toc39573185)

[4.3.6.指针与数组的天生姻缘... 29](#_Toc39573186)

[4.3.7.指针与强制类型转换.... 30](#_Toc39573187)

[4.3.8.指针、数组与sizeof运算符... 31](#_Toc39573188)

[4.3.9.指针与函数传参.... 32](#_Toc39573189)

[4.3.10.输入型参数与输出型参数.... 34](#_Toc39573190)

[第四章 C语言复杂表达式与指针高级应用. 36](#_Toc39573191)

[4.4.0. 章节概要.... 36](#_Toc39573192)

[4.4.1.指针数组与数组指针.... 36](#_Toc39573193)

[4.4.2.函数指针与typedef 38](#_Toc39573194)

[4.4.3.函数指针实战1. 39](#_Toc39573195)

[4.4.5.再论typedef 40](#_Toc39573196)

[4.4.6.二重指针.... 42](#_Toc39573197)

[4.4.7.二维数组.... 45](#_Toc39573198)

[4.4.8.二维数组的运算和指针... 46](#_Toc39573199)

[第五章 数组&字符串&结构体&共用体&枚举. 48](#_Toc39573200)

[4.5.0 章节概要.... 48](#_Toc39573201)

[4.5.1.程序中内存从哪里来1. 49](#_Toc39573202)

[4.5.2.程序中内存从哪里来2. 50](#_Toc39573203)

[4.5.4.程序中内存从哪里来3. 52](#_Toc39573204)

[4.5.5.C语言的字符串类型.... 54](#_Toc39573205)

[4.5.6.字符串和字符数组的细节.... 55](#_Toc39573206)

[4.5.7.C语言之结构体概述.... 57](#_Toc39573207)

[4.5.8.结构体的对齐访问1. 59](#_Toc39573208)

[4.5.11.offsetof宏与container_of宏... 64](#_Toc39573209)

[4.5.12.共用体union. 68](#_Toc39573210)

[4.5.13.大小端模式1. 70](#_Toc39573211)

[4.5.14.大小端模式2. 72](#_Toc39573212)

[4.5.15.枚举.... 73](#_Toc39573213)

[第六章、语言宏定义与预处理、函数和函数库. 81](#_Toc39573214)

[4.6.0 .章节概要.... 81](#_Toc39573215)

[4.6.1.C语言预处理理论.... 82](#_Toc39573216)

[4.6.2.C语言预处理代码实战.... 83](#_Toc39573217)

[4.6.3.宏定义1. 85](#_Toc39573218)

[4.6.3.1、宏定义的规则和使用解析.... 85](#_Toc39573219)

[4.6.4.宏定义2. 86](#_Toc39573220)

[4.6.5.函数的本质.... 87](#_Toc39573221)

[4.6.6.函数的基本使用.... 88](#_Toc39573222)

[4.6.7.递归函数.... 89](#_Toc39573223)

[4.6.8.函数库.... 90](#_Toc39573224)

[4.6.9.字符串函数（重点）.... 92](#_Toc39573225)

[4.6.10.数学库函数.... 93](#_Toc39573226)

[4.6.11.自己制作静态链接库并使用.... 94](#_Toc39573227)

[第七章 存储类&作用域&生命周期&链接属性. 96](#_Toc39573228)

[4.7.0.章节概要.... 96](#_Toc39573229)

[4.7.1.概念解析.... 96](#_Toc39573230)

[4.7.2.linux下C程序的内存映像... 98](#_Toc39573231)

[4.7.3、存储类相关的关键字1. 100](#_Toc39573232)

[4.7.4.存储类相关的关键字2. 101](#_Toc39573233)

[4.7.5.作用域详解.... 105](#_Toc39573234)

[4.7.6.变量的生命周期.... 106](#_Toc39573235)

[4.7.7.链接属性.... 107](#_Toc39573236)

[4.7.8.最后的总结.... 108](#_Toc39573237)

[第八章 一些杂散但值得讨论的问题. 110](#_Toc39573238)

[4.8.0 章节概要.... 110](#_Toc39573239)

[4.8.1.操作系统究竟是个什么玩意？... 110](#_Toc39573240)

[4.8.2.main函数返回给谁？.... 112](#_Toc39573241)

[4.8.3.argc、argv与main函数的传参... 113](#_Toc39573242)

[4.8.4.void类型的本质.... 114](#_Toc39573243)

[4.8.5.C语言中的NULL. 115](#_Toc39573244)

[4.8.6.运算中的临时匿名变量... 117](#_Toc39573245)

[4.8.7.顺序结构.... 118](#_Toc39573246)

[第九章 链表&状态机与多线程. 122](#_Toc39573247)

[4.9.0 章节概要.... 122](#_Toc39573248)

[4.9.1.链表的引入.... 123](#_Toc39573249)

[4.9.2.单链表的实现.... 124](#_Toc39573250)

[4.9.3.单链表的算法之插入节点.... 126](#_Toc39573251)

[4.9.4.单链表的算法之插入节点续.... 127](#_Toc39573252)

[4.9.5.从链表头部插入新节点... 129](#_Toc39573253)

[4.9.6.单链表的算法之遍历节点.... 130](#_Toc39573254)

[4.9.7.单链表的算法之删除节点.... 131](#_Toc39573255)

[4.9.8.单链表的算法之逆序.... 134](#_Toc39573256)

[4.9.9.双链表的引入和基本实现.... 135](#_Toc39573257)

[4.9.10.双链表的算法之插入节点.... 136](#_Toc39573258)

[4.9.11.双链表的算法之遍历节点.... 138](#_Toc39573259)

[4.9.12.双链表的算法之删除节点.... 140](#_Toc39573260)

[4.9.13.linux内核链表.... 141](#_Toc39573261)

[4.9.14.内核链表的基本算法和使用简介.... 142](#_Toc39573262)

[4.9.15.什么是状态机.... 144](#_Toc39573263)

[4.9.16.C语言实现简单的状态机.... 145](#_Toc39573264)

[4.9.17.多线程简介.... 147](#_Toc39573265)

[第十章 番外篇-程序员和编译器之间的暧昧. 149](#_Toc39573266)

[4.10.0 章节概要.... 149](#_Toc39573267)

[4.10.1.编程工作的演进史.... 149](#_Toc39573268)

[4.10.2.程序员、编译器、CPU之间的三角恋... 150](#_Toc39573269)

[4.10.3.像编译器一样思考吧.... 151](#_Toc39573270)

 

**
**

# 第一章 内存这个大话题

## 4.1.0 章节概要

**4.1.1.程序运行为什么需要内存1**

​    本节从本质上分析了计算机程序在计算机中是如何运行的，通过冯诺依曼结构和哈佛结构的对比，让大家对代码和数据之分有了清楚的认识。这些认识有助于你对程序运行过程的分析，从而保证将来写出优秀的程序代码。

**4.1.2.程序运行为什么需要内存2**

​    本节从本质上分析了计算机程序在计算机中是如何运行的，通过冯诺依曼结构和哈佛结构的对比，让大家对代码和数据之分有了清楚的认识。这些认识有助于你对程序运行过程的分析，从而保证将来写出优秀的程序代码。

**4.1.3.位、字节、半字、字的概念和内存位宽**

​    本节从逻辑上阐述内存的编程模型和逻辑认识，并且解释了内存单元的几个单位：位、字节、半字、字。通过本节学习希望大家从逻辑上对内存有一个认知，先建立起来大的框架性概念。

**4.1.4.内存编址和寻址、内存对齐**

​    本节重点讲述内存单元格和其地址的对应关系，同时讲了内存对齐的意义和重要性，试图带领大家对内存从逻辑和现实两个角度深入理解，以为后面的深入分析C语言特性打下基础。

**4.1.5.C语言如何操作内存**

​    本节主要讲C语言语法中对内存的使用，包括：变量定义、指针、数组等C语言基本语法，讲述这些语法和内存之间的内在联系，试图引导大家从内存的角度来理解这些语法特性。

**4.1.6.内存管理之结构体**

​    本节首先讲述数据结构的概念和意义，然后从数组讲起，使用数组的缺陷引出结构体，目的在于让大家明白结构体这种简单数据结构的内在，最后讲了通过结构体内嵌指针来实现面向对象，这是linux内核中常见的一种语法技巧。

**4.1.7.内存管理之栈**

​    本节初步讲解栈stack，特点在于从内存角度讲解栈。

**4.1.8.内存管理之堆**

​    本节讲解堆这种内存管理方法，并对比堆和栈的区别，综合栈和堆讲解操作系统的内存管理策略。

**4.1.9、复杂数据结构**

​    本节首先讲解了链表、二叉树、哈希表等复杂数据结构，然后重点讲了数据结构和算法的意义，以及学习方法和态度。

## 4.1.1.程序运行为什么需要内存

### 4.1.1.1、计算机程序运行的目的

​    计算机为什么需要编程？编程已经编了很多年，已经写了很多程序，为什么还需要另外写程序？计算机有这个新的程序到底为了什么？

​    程序的目的是为了去运行，程序运行是为了得到一定的结果。人的需求是会变化的，计算机得设计新的的程序来得到新的结果以此来实现新的功能来满足人类的不断变化的需求。

计算机就是用来计算的，所有的计算机程序其实都是在做计算。计算就是在计算数据。所以计算机程序中很重要的部分就是数据。

​    计算机程序 = 代码 + 数据       计算机程序运行完得到一个结果，就是说

​    代码 + 数据 (经过运行后) = 结果

​    从宏观上来理解，代码就是动作，就是加工数据的动作；数据就是数字，就是被代码所加工的东西。

​    那么可以得出结论：程序运行的目的不外乎2个：结果、过程

​    用函数来类比：函数的形参就是待加工的数据（函数内还需要一些临时数据，就是局部变量），函数本体就是代码，函数的返回值就是结果，函数体的执行过程就是过程。

​    

```c
int add(int a, int b)
  {
​    return a + b;
  }      // 这个函数的执行就是为了得到结果
  void add(int a, int b)
  {
​    int c;
​    c = a + b;
​    printf("c = %d.\n", c);
  }      // 这个函数的执行重在过程（重在过程中的printf），返回值不需要
  int add(int a, int b)
  {
​    int c;
​    c = a + b;
​    printf("c = %d.\n", c);
​    return c;
  }      // 这个函数又重结果又重过程
```

### 4.1.1.2、计算机程序运行过程

​    计算机程序的运行过程，其实就是程序中很多个函数相继运行的过程。程序是由很多个函数组成的，程序的本质就是函数，函数的本质是加工数据的动作。

### 4.1.1.3、冯诺依曼结构和哈佛结构

​    冯诺依曼结构是：数据和代码放在一起。

​    哈佛结构是：数据和代码分开存在。

​    什么是代码：函数

​    什么是数据：全局变量、局部变量

​    在S5PV210中运行的linux系统上，运行应用程序时：这时候所有的应用程序的代码和数据都在DRAM，所以这种结构就是冯诺依曼结构；在单片机中，我们把程序代码烧写到Flash（NorFlash）中，然后程序在Flash中原地运行，程序中所涉及到的数据（全局变量、局部变量）不能放在Flash中，必须放在RAM（SRAM）中。这种就叫哈佛结构。

 

### 4.1.1.4、动态内存DRAM和静态内存SRAM

​    DRAM是动态内存，SRAM是静态内存。详细细节自己baidu

 

### 4.1.1.5、总结：为什么需要内存呢

​    内存是用来存储可变数据的，数据在程序中表现为全局变量、局部变量等（在gcc中，其实常量也是存储在内存中的）（大部分单片机中，常量是存储在flash中的，也就是在代码段），对我们写程序来说非常重要，对程序运行更是本质相关。

​    所以内存对程序来说几乎是本质需求。越简单的程序需要越少的内存，而越庞大越复杂的程序需要更多的内存。内存管理是我们写程序时很重要的话题。我们以前学过的了解过的很多编程的关键其实都是为了内存，譬如说数据结构（数据结构是研究数据如何组织的，数据是放在内存中的）和算法（算法是为了用更优秀更有效的方法来加工数据，既然跟数据有关就离不开内存）。

​    

### 4.1.1.6、深入思考：如何管理内存（无OS时，有OS时）

​    对于计算机来说，内存容量越大则可能性越大，所以大家都希望自己的电脑内存更大。我们写程序时如何管理内存就成了很大的问题。如果管理不善，可能会造成程序运行消耗过多的内存，这样迟早内存都被你这个程序吃光了，当没有内存可用时程序就会崩溃。所以内存对程序来说是一种资源，所以管理内存对程序来说是一个重要技术和话题。

​    先从操作系统角度讲：操作系统掌握所有的硬件内存，因为内存很大，所以操作系统把内存分成1个1个的页面（其实就是一块，一般是4KB），然后以页面为单位来管理。页面内用更细小的方式来以字节为单位管理。操作系统内存管理的原理非常麻烦、非常复杂、非常不人性化。那么对我们这些使用操作系统的人来说，其实不需要了解这些细节。操作系统给我们提供了内存管理的一些接口，我们只需要用API即可管理内存。

​    譬如在C语言中使用malloc free这些接口来管理内存。

​    没有操作系统时：在没有操作系统（其实就是裸机程序）中，程序需要直接操作内存，编程者需要自己计算内存的使用和安排。如果编程者不小心把内存用错了，错误结果需要自己承担。

​    

​    再从语言角度来讲：不同的语言提供了不同的操作内存的接口。

​    譬如汇编：根本没有任何内存管理，内存管理全靠程序员自己，汇编中操作内存时直接使用内存地址（譬如0xd0020010），非常麻烦；

​    譬如C语言：C语言中编译器帮我们管理直接内存地址，我们都是通过编译器提供的变量名等来访问内存的，操作系统下如果需要大块内存，可以通过API（malloc free）来访问系统内存。裸机程序中需要大块的内存需要自己来定义数组等来解决。

​    

​    譬如C++语言：C++语言对内存的使用进一步封装。我们可以用new来创建对象（其实就是为对象分配内存），然后使用完了用delete来删除对象（其实就是释放内存）。所以C++语言对内存的管理比C要高级一些，容易一些。但是C++中内存的管理还是靠程序员自己来做。如果程序员new了一个对象，但是用完了忘记delete就会造成这个对象占用的内存不能释放，这就是内存泄漏。

​    Java/C#等语言：这些语言不直接操作内存，而是通过虚拟机来操作内存。这样虚拟机作为我们程序员的代理，来帮我们处理内存的释放工作。如果我的程序申请了内存，使用完成后忘记释放，则虚拟机会帮我释放掉这些内存。听起来似乎C# java等语言比C/C++有优势，但是其实他这个虚拟机回收内存是需要付出一定代价的，所以说语言没有好坏，只有适应不适应。当我们程序对性能非常在乎的时候（譬如操作系统内核）就会用C/C++语言；当我们对开发程序的速度非常在乎的时候，就会用Java/C#等语言。

 

 

## 4.1.3.位、字节、半字、字的概念和内存位宽

### 4.1.3.1、什么是内存？（硬件和逻辑两个角度）

​    从硬件角度：内存实际上是电脑的一个配件（一般叫内存条）。根据不同的硬件实现原理还可以把内存分成SRAM和DRAM（DRAM又有好多代，譬如最早的SDRAM，后来的DDR1、DDR2·····、LPDDR）。

​    从逻辑角度：内存是这样一种东西，它可以随机访问（随机访问的意思是只要给一个地址，就可以访问这个内存地址）、并且可以读写（当然了逻辑上也可以限制其为只读或者只写）；内存在编程中天然是用来存放变量的（就是因为有了内存，所以C语言才能定义变量，C语言中的一个变量实际就对应内存中的一个单元）。

### 4.1.3.2、内存的逻辑抽象图（内存的编程模型）

​    从逻辑角度来讲，内存实际上是由无限多个内存单元格组成的，每个单元格有一个固定的地址叫内存地址，这个内存地址和这个内存单元格唯一对应且永久绑定。

​    以大楼来类比内存是最合适的。逻辑上的内存就好象是一栋无限大的大楼，内存的单元格就好象大楼中的一个个小房间。每个内存单元格的地址就好象每个小房间的房间号。内存中存储的内容就好象住在房间中的人一样。

​    逻辑上来说，内存可以有无限大（因为数学上编号永远可以增加，无尽头）。但是现实中实际的内存大小是有限制的，譬如32位的系统（32位系统指的是32位数据线，但是一般地址线也是32位，这个地址线32位决定了内存地址只能有32位二进制，所以逻辑上的大小为2的32次方）内存限制就为4G。实际上32位的系统中可用的内存是小于等于4G的（譬如我32位CPU装32位windows，但实际电脑只有512M内存）。

​    

### 4.1.3.3、位和字节

​    内存单元的大小单位有4个：位（1bit） 字节（8bit） 半字（一般是16bit） 字（一般是32bit）

​    在所有的计算机、所有的机器中（不管是32位系统还是16位系统还是以后的64位系统），位永远都是1bit，字节永远都是8bit。

 

### 4.1.3.4、字和半字

​    历史上曾经出现过16位系统、32位系统、64位系统三种，而且操作系统还有windows、linux、iOS等很多，所以很多的概念在历史上曾经被混乱的定义过。

​    建议大家对字、半字、双字这些概念不要详细区分，只要知道这些单位具体有多少位是依赖于平台的。实际工作中在每种平台上先去搞清楚这个平台的定义（字是多少位，半字永远是字的一半，双字永远是字的2倍大小）。

​    编程时一般根本用不到字这个概念，那我们区分这个概念主要是因为有些文档中会用到这些概念，如果不加区别可能会造成你对程序的误解。

​    在linux+ARM这个软硬件平台上（我们嵌入式核心课的所有课程中），字是32位的。

 

### 4.1.3.5、内存位宽（硬件和逻辑两个角度）

​    从硬件角度讲：硬件内存的实现本身是有宽度的，也就是说有些内存条就是8位的，而有些就是16位的。那么需要强调的是内存芯片之间是可以并联的，通过并联后即使8位的内存芯片也可以做出来16位或32位的硬件内存。

​    从逻辑角度讲：内存位宽在逻辑上是任意的，甚至逻辑上存在内存位宽是24位的内存（但是实际上这种硬件是买不到的，也没有实际意义）。从逻辑角度来讲不管内存位宽是多少，我就直接操作即可，对我的操作不构成影响。但是因为你的操作不是纯逻辑而是需要硬件去执行的，所以不能为所欲为，所以我们实际的很多操作都是受限于硬件的特性的。譬如24位的内存逻辑上和32位的内存没有任何区别，但实际硬件都是32位的，都要按照32位硬件的特性和限制来干活。

 

## 4.1.4.内存编址和寻址、内存对齐

### 4.1.4.1、内存编址方法

​    内存在逻辑上就是一个一个的格子，这些格子可以用来装东西（里面装的东西就是内存中存储的数），每个格子有一个编号，这个编号就是内存地址，这个内存地址（一个数字）和这个格子的空间（实质是一个空间）是一一对应且永久绑定的。这就是内存的编址方法。

​    在程序运行时，计算机中CPU实际只认识内存地址，而不关心这个地址所代表的空间在哪里，怎么分布这些实体问题。因为硬件设计保证了按照这个地址就一定能找到这个格子，所以说内存单元的2个概念：地址和空间是内存单元的两个方面。

### 4.1.4.2、关键：内存编址是以字节为单位的

​    我随便给一个数字（譬如说7），然后说这个数字是一个内存地址，然后问你这个内存地址对应的空间多大？这个大小是固定式，就是一个字节（8bit）。

​    如果把内存比喻位一栋大楼，那么这个楼里面的一个一个房间就是一个一个内存格子，这个格子的大小是固定的8bit，就好象这个大楼里面所有的房间户型是一样的。

### 4.1.4.3、内存和数据类型的关系

​    C语言中的基本数据类型有：char short int long float double 

​    int 整形（整数类型，这个整就体现在它和CPU本身的数据位宽是一样的）譬如32位的CPU，整形就是32位，int就是32位。

​    数据类型和内存的关系就在于：

​    数据类型是用来定义变量的，而这些变量需要存储、运算在内存中。所以数据类型必须和内存相匹配才能获得最好的性能，否则可能不工作或者效率低下。

​    在32位系统中定义变量最好用int，因为这样效率高。原因就在于32位的系统本身配合内存等也是32位，这样的硬件配置天生适合定义32位的int类型变量，效率最高。也能定义8位的char类型变量或者16位的short类型变量，但是实际上访问效率不高。

​    在很多32位环境下，我们实际定义bool类型变量（实际只需要1个bit就够了）都是用int来实现bool的。也就是说我们定义一个bool b1;时，编译器实际帮我们分配了32位的内存来存储这个bool变量b1。编译器这么做实际上浪费了31位的内存，但是好处是效率高。

​    问题：实际编程时要以省内存为大还是要以运行效率为重？答案是不定的，看具体情况。很多年前内存很贵机器上内存都很少，那时候写代码以省内存为主。现在随着半导体技术的发展内存变得很便宜了，现在的机器都是高配，不在乎省一点内存，而效率和用户体验变成了关键。所以现在写程序大部分都是以效率为重。

​    

### 4.1.4.4、内存对齐

​    我们在C中int a;定义一个int类型变量，在内存中就必须分配4个字节来存储这个a。有这么2种不同内存分配思路和策略：

​    第一种：0 1 2 3                              对齐访问

​    第二种：1 2 3 4  或者 2 3 4 5 或者 3 4 5 6     非对齐访问

​    内存的对齐访问不是逻辑的问题，是硬件的问题。从硬件角度来说，32位的内存它 0 1 2 3四个单元本身逻辑上就有相关性，这4个字节组合起来当作一个int硬件上就是合适的，效率就高。

​    对齐访问很配合硬件，所以效率很高；非对齐访问因为和硬件本身不搭配，所以效率不高。（因为兼容性的问题，一般硬件也都提供非对齐访问，但是效率要低很多。）

​    

### 4.1.4.5、从内存编址看数组的意义

​    

## 4.1.5.C语言如何操作内存

### 4.1.5.1、C语言对内存地址的封装（用变量名来访问内存、数据类型的含义、函数名的含义）

​    譬如在C语言中 int a; a = 5; a += 4;    // a == 9;

结合内存来解析C语言语句的本质：

​    int a;    // 编译器帮我们申请了1个int类型的内存格子（长度是4字节，地址是确定的，但是只有编译器知道，我们是不知道的，也不需要知道。），并且把符号a和这个格子绑定。

​    a = 5;   // 编译器发现我们要给a赋值，就会把这个值5丢到符号a绑定的那个内存格子中。

​    a += 4;  // 编译器发现我们要给a加值，a += 4 等效于 a = a + 4;编译器会先把a原来的值读出来，然后给这个值加4，再把加之后的和写入a里面去。

​    

​    C语言中数据类型的本质含义是：表示一个内存格子的长度和解析方法。

​    数据类型决定长度的含义：我们一个内存地址（0x30000000），本来这个地址只代表1个字节的长度，但是实际上我们可以通过给他一个类型(int)，让他有了长度(4)，这样这个代表内存地址的数字(0x30000000)就能表示从这个数字(0x30000000)开头的连续的n(4)个字节的内存格子了(0x30000000 + 0x30000001 + 0x30000002 + 0x30000003)。

​    数据类型决定解析方法的含义：譬如我有一个内存地址（0x30000000），我们可以通过给这个内存地址不同的类型来指定这个内存单元格子中二进制数的解析方法。譬如我 (int)0x30000000，含义就是(0x30000000 + 0x30000001 + 0x30000002 + 0x30000003)这4个字节连起来共同存储的是一个int型数据；那么我(float)0x30000000，含义就是(0x30000000 + 0x30000001 + 0x30000002 + 0x30000003)这4个字节连起来共同存储的是一个float型数据；

​    之前讲过一个很重要的概念：内存单元格子的编址单位是字节。

​    (int *)0;

  (float *)0;

  (short)0;

  (char)0;

  

  int a;     // int a;时编译器会自动给a分配一个内存地址，譬如说是0x12345678

  (int *)a;    // 等价于(int *)0x12345678

  (float *)a;

 

 

​    

​    C语言中，函数就是一段代码的封装。函数名的实质就是这一段代码的首地址。所以说函数名的本质也是一个内存地址。

 

### 4.1.5.2、用指针来间接访问内存

关于类型（不管是普通变量类型int float等，还是指针类型int *  float *等），只要记住：

类型只是对后面数字或者符号（代表的是内存地址）所表征的内存的一种长度规定和解析方法规定而已。

C语言中的指针，全名叫指针变量，指针变量其实很普通变量没有任何区别。譬如int a和int *p其实没有任何区别，a和p都代表一个内存地址（譬如是0x20000000），但是这个内存地址（0x20000000）的长度和解析方法不同。a是int型所以a的长度是4字节，解析方法是按照int的规定来的；p是int *类型，所以长度是4字节，解析方法是int *的规定来的（0x20000000开头的连续4字节中存储了1个地址，这个地址所代表的内存单元中存放的是一个int类型的数）。

### 4.1.5.3、指针类型的含义

### 4.1.5.4、用数组来管理内存

数组管理内存和变量其实没有本质区别，只是符号的解析方法不同。（普通变量、数组、指针变量其实都没有本质差别，都是对内存地址的解析，只是解析方法不一样）。

int a;       // 编译器分配4字节长度给a，并且把首地址和符号a绑定起来。

int b[10]; // 编译器分配40个字节长度给b，并且把首元素首地址和符号b绑定起来。

 

数组中第一个元素（a[0]）就称为首元素；每一个元素类型都是int，所以长度都是4，其中第一个字节的地址就称为首地址；首元素a[0]的首地址就称为首元素首地址。

 

## 4.1.6.内存管理之结构体

### 4.1.6.1、数据结构这门学问的意义

​    数据结构就是研究数据如何组织（在内存中排布），如何加工的学问。

### 4.1.6.2、最简单的数据结构：数组

​    为什么要有数组？因为程序中有好多个类型相同、意义相关的变量需要管理，这时候如果用单独的变量来做程序看起来比较乱，用数组来管理会更好管理。

​    譬如 int ages[20];

### 4.1.6.3、数组的优势和缺陷

​    优势：数组比较简单，访问用下标，可以随机访问。

​    缺陷：

1 数组中所有元素类型必须相同；

2 数组大小必须定义时给出，而且一旦确定不能再改。

### 4.1.6.4、结构体隆重登场

​    结构体发明出来就是为了解决数组的第一个缺陷：数组中所有元素类型必须相同

​    我们要管理3个学生的年龄（int类型），怎么办？

​    第一种解法：用数组      int ages[3];

​    第二种解法：用结构体    

struct ages

  {

​    int age1;

​    int age2;

​    int age3;

  };

  struct ages age;

 

 

​    分析总结：在这个示例中，数组要比结构体好。但是不能得出结论说数组就比结构体好，在包中元素类型不同时就只能用结构体而不能用数组了。

​    

​    因为people的各个元素类型不完全相同，所以必须用结构体，没法用数组。

​     

struct people

  {

​    int age;      // 人的年龄

​    char name[20];   // 人的姓名

​    int height;     // 人的身高

  };

 

### 4.1.6.5、题外话：结构体内嵌指针实现面向对象

**面向过程与面向对象：**

总的来说：C语言是面向过程的，但是C语言写出的linux系统是面向对象的。

非面向对象的语言，不一定不能实现面向对象的代码。只是说用面向对象的语言来实现面向对象要更加简单一些、直观一些、无脑一些。

用C++、Java等面向对象的语言来实现面向对象简单一些，因为语言本身帮我们做了很多事情；但是用C来实现面向对象很麻烦，看起来也不容易理解，这就是为什么大多数人学过C语言却看不懂linux内核代码的原因。

 

struct s

{

  int age;          // 普通变量

  void (*pFunc)(void);    // 函数指针，指向 void func(void)这类的函数

};

 

 

使用这样的结构体就可以实现面向对象。

这样包含了函数指针的结构体就类似于面向对象中的class，结构体中的变量类似于class中的成员变量，结构体中的函数指针类似于class中的成员方法。

 

## 4.1.7、内存管理之栈（stack）

### 4.1.7.1、什么是栈

​    栈是一种数据结构，C语言中使用栈来保存局部变量。栈是被发明出来管理内存的。

### 1.4.7.2、栈管理内存的特点（小内存、自动化）

​    先进后出 FILO   first in last out       栈

​    先进先出 FIFO  first in first out     队列

栈的特点是入口即出口，只有一个口，另一个口是堵死的。所以先进去的必须后出来。

队列的特点是入口和出口都有，必须从入口进去，从出口出来，所以先进去的必须先出来，否则就堵住后面的。

​       

### 1.4.7.3、栈的应用举例：局部变量

​    C语言中的局部变量是用栈来实现的。

​    我们在C中定义一个局部变量时（int a），编译器会在栈中分配一段空间（4字节）给这个局部变量用（分配时栈顶指针会移动给出空间，给局部变量a用的意思就是，将这4字节的栈内存的内存地址和我们定义的局部变量名a给关联起来），对应栈的操作是入栈。

​    注意：这里栈指针的移动和内存分配是自动的（栈自己完成，不用我们写代码去操作）。

​    然后等我们函数退出的时候，局部变量要灭亡。对应栈的操作是弹栈（出栈）。出栈时也是栈顶指针移动将栈空间中与a关联的那4个字节空间释放。这个动作也是自动的，也不用人写代码干预。

​    

栈的优点：栈管理内存，好处是方便，分配和最后回收都不用程序员操心，C语言自动完成。

分析一个细节：C语言中，定义局部变量时如果未初始化，则值是随机的，为什么？

定义局部变量，其实就是在栈中通过移动栈指针来给程序提供一个内存空间和这个局部变量名绑定。因为这段内存空间在栈上，而栈内存是反复使用的（脏的，上次用完没清零的），所以说使用栈来实现的局部变量定义时如果不显式初始化，值就是脏的。如果你显式初始化怎么样？

C语言是通过一个小手段来实现局部变量的初始化的。

int a = 15;   // 局部变量定义时初始化

C语言编译器会自动把这行转成：

int a;     // 局部变量定义

a = 15;     // 普通的赋值语句

### 1.4.7.4、栈的约束（预定栈大小不灵活，怕溢出）

首先，栈是有大小的。所以栈内存大小不好设置。如果太小怕溢出，太大怕浪费内存。（这个缺点有点像数组）

其次，栈的溢出危害很大，一定要避免。所以我们在C语言中定义局部变量时不能定义太多或者太大（譬如不能定义局部变量时 int a[10000]; 使用递归来解决问题时一定要注意递归收敛）

 

## 4.1.8、内存管理之堆

### 4.1.8.1、什么是堆

堆（heap）是一种内存管理方式。内存管理对操作系统来说是一件非常复杂的事情，因为首先内存容量很大，其次内存需求在时间和大小块上没有规律（操作系统上运行着的几十、几百、几千个进程随时都会申请或者释放内存，申请或者释放的内存块大小随意）。

堆这种内存管理方式特点就是自由（随时申请、释放；大小块随意）。堆内存是操作系统划归给堆管理器（操作系统中的一段代码，属于操作系统的内存管理单元）来管理的，然后向使用者（用户进程）提供API（malloc和free）来使用堆内存。

我们什么时候使用堆内存？需要内存容量比较大时，需要反复使用及释放时，很多数据结构（譬如链表）的实现都要使用堆内存。

### 4.1.8.2、堆管理内存的特点（大块内存、手工分配&使用&释放）

特点一：容量不限（常规使用的需求容量都能满足）。

特点二：申请及释放都需要手工进行，手工进行的含义就是需要程序员写代码明确进行申请malloc及释放free。如果程序员申请内存并使用后未释放，这段内存就丢失了（在堆管理器的记录中，这段内存仍然属于你这个进程，但是进程自己又以为这段内存已经不用了，再用的时候又会去申请新的内存块，这就叫吃内存），称为内存泄漏。在C/C++语言中，内存泄漏是最严重的程序bug，这也是别人认为Java/C#等语言比C/C++优秀的地方。

### 4.1.8.3、C语言操作堆内存的接口（malloc free）

堆内存释放时最简单，直接调用free释放即可。  void free(void *ptr);

堆内存申请时，有3个可选择的类似功能的函数：malloc, calloc, realloc

void *malloc(size_t size);

void *calloc(size_t nmemb, size_t size);  // nmemb个单元，每个单元size字节

void *realloc(void *ptr, size_t size);   // 改变原来申请的空间的大小的

 

譬如要申请10个int元素的内存：

malloc(40);     malloc(10*sizeof(int));//便于代码移植， int，在32,64位系统中长度不同

calloc(10, 4);   calloc(10, sizeof(int));






数组定义时必须同时给出数组元素个数（数组大小），而且一旦定义再无法更改。在Java等高级语言中，有一些语法技巧可以更改数组大小，但其实这只是一种障眼法。它的工作原理是：先重新创建一个新的数组大小为要更改后的数组，然后将原数组的所有元素复制进新的数组，然后释放掉原数组，最后返回新的数组给用户；

 

堆内存申请时必须给定大小，然后一旦申请完成大小不变，如果要变只能通过realloc接口。realloc的实现原理类似于上面说的Java中的可变大小的数组的方式。

### 4.1.8.4、堆的优势和劣势（管理大块内存、灵活、容易内存泄漏）

​    优势：灵活；

​    劣势：需要程序员去处理各种细节，所以容易出错，严重依赖于程序员的水平。

 

## 4.1.9、复杂数据结构

### 4.1.9.1、链表、哈希表、二叉树、图等

链表是最重要的，链表在linux内核中使用非常多，驱动、应用编写很多时候都需要使用链表。所以对链表必须掌握，掌握到：会自己定义结构体来实现链表、会写链表的节点插入（前插、后插）、节点删除、节点查找、节点遍历等。（至于像逆序这些很少用，掌握了前面那几个这个也不难）。

 

哈希表不是很常用，一般不需要自己写实现，而直接使用别人实现的哈希表比较多。对我们来说最重要的是要明白哈希表的原理、从而知道哈希表的特点，从而知道什么时候该用哈希表，当看到别人用了哈希表的时候要明白别人为什么要用哈希表、合适不合适？有没有更好的选择？

 

二叉树、图等。对于这些复杂数据结构，不要太当回事。这些复杂数据结构用到的概率很小（在嵌入式开发中），其实这些数据结构被发明出来就是为了解决特定问题的，你不处理特定问题根本用不到这些，没必要去研究。

 

### 4.1.9.2、为什么需要更复杂的数据结构

因为现实中的实际问题是多种多样的，问题的复杂度不同，所以需要解决问题的算法和数据结构也不同。所以当你处理什么复杂度的问题，就去研究针对性解决的数据结构和算法；当你没有遇到此类问题（或者你工作的领域根本跟这个就没关系）时就不要去管了。

### 4.1.9.3、数据结构和算法的关系

数据结构的发明都是为了配合一定的算法；算法是为了处理具体问题，算法的实现依赖于相应的数据结构。

当前我们说的算法和纯数学是不同的（算法是基于数学的，大学计算机系研究生博士生很多本科都是数学相关专业的），因为计算机算法要求以数学算法为指导，并且结合计算机本身的特点来改进，最终实现一个在计算机上可以运行的算法（意思就是用代码可以表示的算法）。

 

### 4.1.9.4、应该怎样学习这部分？

从上面表述大家应该明白以下事实：

​    \1. 数据结构和算法是相辅相成的，要一起研究。

​    \2. 数据结构和算法对嵌入式来说不全是重点，不要盲目的跑去研究这个。

​    \3. 一般在实际应用中，实现数据结构和算法的人和使用数据结构和算法的人是分开的。实际中有一部分人的工作就是研究数据结构和算法，并且试图用代码来实现这些算法（表现为库）；其他做真正工作的人要做的就是理解、明白这些算法和数据结构的意义、优劣、特征，然后在合适的时候选择合适的数据结构和算法来解决自己碰到的实际问题。

 

举个例子：linux内核在字符设备驱动管理时，使用了哈希表（hash table，散列表）。所以字符设备驱动的很多特点都和哈希表的特点有关。

 

 

 

 

 

 

 

 

 

 

 

 



 

# 第二章 C语言位操作

## 4.2.0 章节概要

4.2.1.常用位操作符

​    本节讲解C语言中常用的位操作符，如位与、位或、位取反、位异或、左移右移等。目的在于让大家系统学习各种位操作的操作符及真值表。

4.2.2.位与位或位异或在操作寄存器时的特殊作用

​    本节首先讲解寄存器位设置时的特点和需求，然后重点讲解了位与、位或、位异或等操作及其在寄存器设置中的具体作用，并用实例进行演示和验证。

4.2.3.如何用位运算构建特定二进制数

​    本节主要讲解了左移、右移以及位取反符号，以及如何用这三个符号构建特定的二进制数。这种方式是最常见的设置寄存器的方式，而不是像上节中直接给出二进制数的方式。

4.2.4.位运算实战演练1

​    本节用6个实际案例来演示如果用位运算符完成一定运算，这些示例都是流行的面试题目中位运算部分的，对大家掌握位运算有很大帮助。

4.2.5.位运算实战演练2

​    本节用2个实际案例来演示如果用位运算符完成一定运算，这些示例都是流行的面试题目中位运算部分的，对大家掌握位运算有很大帮助。

4.2.6.技术升级：用宏定义来完成位运算

​    本节讲述位运算中难度最大的部分，即用宏定义来描述位运算。在linux内核中有很多类似的宏，分布在各个角落，搞清楚这些宏的实现可以帮助我们提升C语言水平，同时为以后研究linux内核源码扫清障碍。

## 4.2.1.位操作符

### 4.2.1.1、位与&

(1)注意：位与符号是一个&，两个&&是逻辑与。

(2)真值表：1&0=0    1&1=1  0&0=0  0&1=0  

(3)从真值表可以看出：位与操作的特点是，只有1和1位于结果为1，其余全是0.

(4)位与和逻辑与的区别：位与时两个操作数是按照二进制位彼次对应位相与的，逻辑与是两个操作数作为整体来相与的。（举例：0xAA&0xF0=0xA0, 0xAA && 0xF0=1）

### 4.2.1.2、位或|

(1)注意：位或符号是一个|，两个||是逻辑或。

(2)真值表：1|0=1 1|1=1   0|0=0   0|1=1

(3)从真值表可以看出：位或操作的特点是：只有2个0相位或才能得到0，只要有1个1结果就一定是1.

(4)位或和逻辑或的区别：位或时两个操作数是按照二进制位彼次对应位相与的，逻辑或是两个操作数作为整体来相或的。

### 4.2.1.3、位取反~

(1)注意：C语言中位取反是~，C语言中的逻辑取反是!

(2)按位取反是将操作数的二进制位逐个按位取反（1变成0，0变成1）；而逻辑取反是真（在C语言中只要不是0的任何数都是真）变成假（在C语言中只有0表示假）、假变成真。

 

实验：任何非0的数被按逻辑取反再取反就会得到1；

​     任何非0的数倍按位取反再取反就会得到他自己；

 

### 4.2.1.4、位异或^

(1)位异或真值表：1^1=0  0^0=0  1^0=1  0^1=1  

(2)位异或的特点：2个数如果相等结果为0，不等结果为1。记忆方法：异或就是相异就或操作起来。

 

位与、位或、位异或的特点总结：

位与：（任何数，其实就是1或者0）与1位与无变化，与0位与变成0

位或：（任何数，其实就是1或者0）与1位或变成1，与0位或无变化

位异或：（任何数，其实就是1或者0）与1位异或会取反，与0位异或无变化

 

### 4.2.1.5、左移位<< 与右移位>>

C语言的移位要取决于数据类型。

对于无符号数，左移时右侧补0（相当于逻辑移位）

对于无符号数，右移时左侧补0（相当于逻辑移位）

对于有符号数，左移时右侧补0（叫算术移位，相当于逻辑移位）

对于有符号数，右移时左侧补符号位（如果正数就补0，负数就补1，叫算术移位）

 

嵌入式中研究的移位，以及使用的移位都是无符号数

 

## 4.2.2.位与位或位异或在操作寄存器时的特殊作用

### 4.2.2.1、寄存器操作的要求（特定位改变而不影响其他位）

(1)ARM是内存与IO统一编址的，ARM中有很多内部外设，SoC中CPU通过向这些内部外设的寄存器写入一些特定的值来操控这个内部外设，进而操控硬件动作。所以可以说：读写寄存器就是操控硬件。

(2)寄存器的特点是按位进行规划和使用。但是寄存器的读写却是整体32位一起进行的（也就是说你只想修改bit5～bit7是不行的，必须整体32bit全部写入）

(3)寄存器操作要求就是：在设定特定位时不能影响其他位。

(4)如何做到？答案是：读-改-写三部曲。读改写的操作理念，就是：当我想改变一个寄存器中某些特定位时，我不会直接去给他写，我会先读出寄存器整体原来的值，然后在这个基础上修改我想要修改的特定位，再将修改后的值整体写入寄存器。这样达到的效果是：在不影响其他位原来值的情况下，我关心的位的值已经被修改了。

 

### 4.2.2.2、特定位清零用&

(1)回顾上节讲的位与操作的特点：（任何数，其实就是1或者0）与1位与无变化，与0位与变成0

(2)如果希望将一个寄存器的某些特定位变成0而不影响其他位，可以构造一个合适的1和0组成的数和这个寄存器原来的值进行位与操作，就可以将特定位清零。

(3)举例：假设原来32位寄存器中的值为：0xAAAAAAAA，我们希望将bit8～bit15清零而其他位不变，可以将这个数与0xFFFF00FF进行位与即可。

 

### 4.2.2.3、特定位置1用|

(1)回顾上节讲的位或操作的特点：任何数，其实就是1或者0）与1位或变成1，与0位或无变化 

(2)操作手法和刚才讲的位与是类似的。我们要构造这样一个数：要置1的特定位为1，其他位为0，然后将这个数与原来的数进行位或即可。

 

### 4.2.2.4、特定位取反用^

(1)回顾上节讲的位异或操作的特点：（任何数，其实就是1或者0）与1位异或会取反，与0位异或无变化

(2)操作手法和刚才讲的位与是类似的。我们要构造这样一个数：要取反的特定位为1，其他位为0，然后将这个数与原来的数进行位异或即可。

 

## 4.2.3.如何用位运算构建特定二进制数

### 4.2.3.1、寄存器位操作经常需要特定位给特定值

(1)从上节可知，对寄存器特定位进行置1或者清0或者取反，关键性的难点在于要事先构建一个特别的数，这个数和原来的值进行位与、位或、位异或等操作，即可达到我们对寄存器操作的要求。

(2)解法1：用工具软件或者计算器或者自己大脑计算，直接给出完整的32位特定数。

优势：可以完成工作，难度也不大，操作起来也不是太麻烦。

劣势：依赖工具，而且不直观，读程序的人不容易理解。

评价：凑活能用，但是不好用，应该被更好用的方法替代。

(2)解法2：自己写代码用位操作符号（主要是移位和位取反）来构建这个特定的二进制数

 

### 4.2.3.2、使用移位获取特定位为1的二进制数

(1)最简单的就是用移位来获取一个特定位为1的二进制数。譬如我们需要一个bit3～bit7为1（隐含意思就是其他位全部为0）的二进制数，可以这样：(0x1f<<3)

(2)更难一点的要求：获取bit3～bit7为1，同时bit23～bit25为1，其余位为0的数：((0x1f<<3) | (7<<23))

 

### 4.2.3.3、再结合位取反获取特定位为0的二进制数

(1)这次我们要获取bit4～bit10为0，其余位全部为1的数。怎么做？

(2)利用上面讲的方法就可以：(0xf<<0)|(0x1fffff<<11)

但是问题是：连续为1的位数太多了，这个数字本身就很难构造，所以这种方法的优势损失掉了。

(3)这种特定位（比较少）为0而其余位（大部分）为1的数，不适合用很多个连续1左移的方式来构造，适合左移加位取反的方式来构造。

(2)思路是：先试图构造出这个数的位相反数，再取反得到这个数。（譬如本例中要构造的数bit4～bit10为0其余位为1，那我们就先构造一个bit4～bit10为1，其余位为0的数，然后对这个数按位取反即可）。

 

### 4.2.3.4、总结：位与、位或结合特定二进制数即可完成寄存器位操作需求

(1)如果你要的这个数比较少位为1，大部分位为0，则可以通过连续很多个1左移n位得到。

(2)如果你想要的数是比较少位为0，大部分位为1，则可以通过先构建其位反数，然后再位取反来得到。

(3)如果你想要的数中连续1（连续0）的部分不止1个，那么可以通过多段分别构造，然后再彼此位与即可。这时候因为参与位或运算的各个数为1的位是不重复的，所以这时候的位或其实相当于几个数的叠加。

 

## 4.2.4.位运算实战演练1

回顾：要置1用|，用清零用&，要取反用^，~和<< >>用来构建特定二进制数。

### 4.2.4.1、给定一个整型数a，设置a的bit3，保证其他位不变。

​       a = a | (1<<3)   或者 a |= (1<<3)

### 4.2.4.2、给定一个整形数a，设置a的bit3~bit7，保持其他位不变。

​       a = a | (0b11111<<3)  或者 a |= (0x1f<<3);

### 4.2.4.3、给定一个整型数a，清除a的bit15，保证其他位不变。

​       a = a & (~(1<<15));   或者 a &= (~(1<<15));

4.2.4.4、给定一个整形数a，清除a的bit15~bit23，保持其他位不变。

​       a = a & (~(0x1ff<<15));   或者 a &= (~(0x1ff<<15));

### 4.2.4.5、给定一个整形数a，取出a的bit3~bit8。

思路：

​    第一步：先将这个数bit3～bit8不变，其余位全部清零。

​    第二步，再将其右移3位得到结果。

​    第三步，想明白了上面的2步算法，再将其转为C语言实现即可。

​    a &= (0x3f<<3);

  a >>= 3;

 

 

### 4.2.4.6、用C语言给一个寄存器的bit7～bit17赋值937（其余位不受影响）。

关键点：第一，不能影响其他位；第二，你并不知道原来bit7～bit17中装的值。

思路：第一步，先将bit7～bit17全部清零，当然不能影响其他位。

​     第二步，再将937写入bit7～bit17即可，当然不能影响其他位。

​     a &= ~(0x7ff<<7);

   a |= (937<<7);

 

 

​     

## 4.2.5.位运算实战演练2

### 4.2.4.7、用C语言将一个寄存器的bit7～bit17中的值加17（其余位不受影响）。

关键点：不知道原来的值是多少

思路：第一步，先读出原来bit7～bit17的值

Temp = a &(0x7ff); 

  第二步，给这个值加17

temp >>= 7; temp += 17;

   第三步，将bit7～bit17清零

​    a &= ~(0x1ff<<7);

   第四步，将第二步算出来的值写入bit7～bit17

​    a |= temp<<7;

 

 

### 4.2.4.8、用C语言给一个寄存器的bit7～bit17赋值937，同时给bit21～bit25赋值17.

思路：4.2.4.6的升级版，两倍的4.2.4.6中的代码即可解决。

 

//清bit 7~bit17

a &= ~(0x7ff<<7); 

//将bit7~bit 17 赋值937

a |= (0x3a9<<7); 

 //清bit 21~bit25

a&= ~(0xf<<21);

//将bit21~bit 25 赋值17

 a |= (0x11<<21);

分析：这样做也可以，但是效果不够高，我们有更优的解法就是合两步为一步。

a &= ~(0x7ff<<7) | ~(0xf<<21); //将清bit 7~bit17，清bit 21~bit25

a |= (0x3a9<<7) | (0x11<<21);// 将bit7~bit 17 赋值937, 将bit21~bit 25 赋值17

 

 

## 4.2.6.技术升级：用宏定义来完成位运算

### 4.2.6.1、直接用宏来置位、复位（最右边为第1位）。

 

​    \#define SET_NTH_BIT(x, n) (x | ((1U)<<(n-1)))

  \#define CLEAR_NTH_BIT(x, n) (x & ~((1U)<<(n-1)))

 

### 4.2.6.2、截取变量的部分连续位。例如：变量0x88, 也就是10001000b，若截取第2～4位，则值为：100b = 4 

​      \#define GETBITS(x, n, m) ((x & ~(~(0U)<<(m-n+1))<<(n-1)) >> (n-1)) 

分析：这个题目相当于我们4.2.4.5中做的事情，只不过要用宏来实现。

这个题目相当于是要把x的bit(n-1)到bit(m-1)取出来

复杂宏怎么分析：

 

((x & ~(~(0U)<<(m-n+1))<<(n-1)) >> (n-1))

第一步，先分清楚这个复杂宏分为几部分：2部分

(x & ~(~(0U)<<(m-n+1))<<(n-1))          >>        (n-1)

分析为什么要>>(n-1)，相当于是我们4.2.4.5中的第二步

 

第二步，继续解析剩下的：又分为2部分

x       &      ~(~(0U)<<(m-n+1))<<(n-1)       

分析为什么要&，相当于我们4.2.4.5中的第一步  

 

第三步，继续分析剩下的：

~      (~(0U)<<(m-n+1))        <<     (n-1) 

这个分析时要搞清楚第2坨到底应该先左边取反再右边<<还是先右边<<再左边取反。

解法：第一，查C语言优先级表；第二，自己实际写个代码测试。

说明这个式子应该是  ~(~(0U)<<(m-n+1))      <<     (n-1) ，这就又分为2部分了

 

10001000

00001110

00001000



# 第三章 指针才是C的精髓

## 4.3.0 章节概要

**4.3.1.指针到底是什么？**

​    本节深入剖析指针的本质，指出指针全称指针变量，强调指针其实也是变量的一种，和普通变量并没有本质分别。这个是大家理解关于指针的更高深问题的基础。

**4.3.2.指针带来的一些符号的理解**

​    本节重点讲解指针符号*和取地址符&，及其在指针定义和解引用时的理解。重点是指针符号在定义同时初始化和定义后再次赋值、解引用时各种符号的理解。

**4.3.3.野指针问题**

​    本节首先介绍什么是野指针以及野指针造成的原因和后果，然后重点讲述如何防止野指针的出现，希望大家能养成良好的使用指针的习惯，避免出现野指针导致程序运行时错误。

**4.3.4.const关键字与指针**

​    本节讲述const关键字的用法，重点是const关键字修饰指针的4种常见格式，及其理解方法。通过本节学习希望大家掌握const关键字在修饰指针时的用法。

**4.3.5.深入学习一下数组**

​    本节输入讲解数组，首先从内存和编译器两个角度来理解数组，然后重点讲解了数组相关的几个符号在做左值和右值时的意义区别，这些含义是深入理解C语言数组的关键

**4.3.6.指针与数组的天生姻缘**

​    本节将数组和指针结合起来，讲述指针指向数组时的一些运算，分析其运算时的结果。通过实例让大家明白指针方式访问数组，以及指针运算访问数组元素的细节。

**4.3.7.指针与强制类型转换**

​    本节首先讲解普通变量数据类型的意义，然后讲解指针变量数据类型的含义，最后讲了指针变量在进行加减运算时数据类型的作用和影响。

**4.3.8.指针、数组与sizeof运算符**

​    本节依次讲解了一些和指针、数组有关的sizeof运算的案例，通过这些代码实例希望让大家深入掌握一些C语言编程细节的语法表现，从而对指针和数组有更深入的理解。

**4.3.9.指针与函数传参**

​    本节讲解数组、指针、结构体等类型变量作为函数参数的情况。通过示例演示和分析让大家明白函数传参的实质，传值调用和传址调用等概念的真实内涵。

**4.3.10.输入型参数与输出型参数**

​    本节再次讲解函数传参，const修饰指针变量等知识点，最后引入输入型参数和输出型参数的概念。

## 4.3.1.指针到底是什么？

### 4.3.1.1、指针变量和普通变量的区别

(1)首先必须非常明确：指针的实质就是个变量，它跟普通变量没有任何本质区别。指针完整的名字应该叫指针变量，简称为指针。

### 4.3.1.2、为什么需要指针？

(1)指针的出现是为了实现间接访问。在汇编中都有间接访问，其实就是CPU的寻址方式中的间接寻址。

(2)间接访问（CPU的间接寻址）是CPU设计时决定的，这个决定了汇编语言必须能够实现间接寻址，又决定了汇编之上的C语言也必须实现简介寻址。

(3)高级语言如Java、C#等没有指针，那他们怎么实现间接访问？答案是语言本身帮我们封装了。

### 4.3.1.3、指针使用三部曲：定义指针变量、关联指针变量、解引用

 

(1)当我们int *p定义一个指针变量p时，因为p是局部变量，所以也遵循C语言局部变量的一般规律（定义局部变量并且未初始化，则值是随机的），所以此时p变量中存储的是一个随机的数字。

(2)此时如果我们解引用p，则相当于我们访问了这个随机数字为地址的内存空间。那这个空间到底能不能访问不知道（也许行也许不行），所以如果直接定义指针变量未绑定有效地址就去解引用几乎必死无疑。

(3)定义一个指针变量，不经绑定有效地址就去解引用，就好象拿一个上了镗的枪随意转了几圈然后开了一枪。

(4)指针绑定的意义就在于：让指针指向一个可以访问、应该访问的地方（就好象拿着枪瞄准目标的过程一样），指针的解引用是为了间接访问目标变量（就好象开枪是为了打中目标一样）

 

### 4.3.2.指针带来的一些符号的理解

我们写的代码是给编译器看的，代码要想达到你想象的结果，就必要编译器对你的代码的理解和你自己对代码的理解一样。编译器理解代码就是理解的符号，所以我们要正确理解C语言中的符号，才能像编译器一样思考程序、理解代码。

### 4.3.2.1、星号*

(1)C语言中*可以表示乘号，也可以表示指针符号。这两个用法是毫无关联的，只是恰好用了同一个符号而已。

(2)星号在用于指针相关功能的时候有2种用法：

第一种是指针定义时，*结合前面的类型用于表明要定义的指针的类型；

第二种功能是指针解引用，解引用时*p表示p指向的变量本身

 

### 4.3.2.2、取地址符&

(1)取地址符使用时直接加在一个变量的前面，然后取地址符和变量加起来构成一个新的符号，这个符号表示这个变量的地址。

 

### 4.3.2.3、指针定义并初始化、与指针定义然后赋值的区别

(1)指针定义时可以初始化，指针的初始化其实就是给指针变量初值（跟普通变量的初始化没有任何本质区别）。

(2)指针变量定义同时初始化的格式是：int a = 32; int *p = &a;

(2)不初始化时指针变量先定义再赋值：int a = 32; int *p;   p = &a;     正确的

​                                                 *p = &a; 错误的

### 4.3.2.4、左值与右值

(1)放在赋值运算符左边的就叫左值，右边的就叫右值。所以赋值操作其实就是：左值 = 右值;

(2)当一个变量做左值时，编译器认为这个变量符号的真实含义是这个变量所对应的那个内存空间；当一个变量做右值时，编译器认为这个变量符号的真实含义是这个变量的值，也就是这个变量所对应的内存空间中存储的那个数。

(3)左值与右值的区别，就好象现实生活中“家”这个字的含义。譬如“我回家了”，这里面的家指的是你家的房子（类似于左值）；但是说“家比事业重要”，这时候的家指的是家人（家人就是住在家所对应的那个房子里面的人，类似于右值）

 

## 4.3.3.野指针问题

### 4.3.3.1、神马是野指针？哪里来的？有什么危害？

(1)野指针，就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的。

 

  int main()

  {

​    int *p;

​    *p = 4;

​    return 0;

}

 

 

 (2)野指针很可能触发运行时段错误（Sgmentation fault）。

(3)因为指针变量在定义时如果未初始化，值也是随机的。指针变量的值其实就是别的变量（指针所指向的那个变量）的地址，所以意味着这个指针指向了一个地址是不确定的变量，这时候去解引用就是去访问这个地址不确定的变量，所以结果是不可知的。

(4)野指针因为指向地址是不可预知的，所以有3种情况：

第一种:是指向不可访问（操作系统不允许访问的敏感地址，譬如内核空间）的地址，结果是触发段错误，这种算是最好的情况了；

第二种:是指向一个可用的、而且没什么特别意义的空间（譬如我们曾经使用过但是已经不用的栈空间或堆空间），这时候程序运行不会出错，也不会对当前程序造成损害，这种情况下会掩盖你的程序错误，让你以为程序没问题，其实是有问题的；

第三种:情况就是指向了一个可用的空间，而且这个空间其实在程序中正在被使用（譬如说是程序的一个变量x），那么野指针的解引用就会刚好修改这个变量x的值，导致这个变量莫名其妙的被改变，程序出现离奇的错误。一般最终都会导致程序崩溃，或者数据被损害。这种危害是最大的。

(5)指针变量如果是局部变量，则分配在栈上，本身遵从栈的规律（反复使用，使用完不擦除，所以是脏的，本次在栈上分配到的变量的默认值是上次这个栈空间被使用时余留下来的值），就决定了栈的使用多少会影响这个默认值。因此野指针的值是有一定规律不是完全随机，但是这个值的规律对我们没意义。因为不管落在上面野指针3种情况的哪一种，都不是我们想看到的。

 

### 4.3.3.2、怎么避免野指针？

(1)野指针的错误来源就是指针定义了以后没有初始化，也没有赋值（总之就是指针没有明确的指向一个可用的内存空间），然后去解引用。

(2)知道了野指针产生的原因，避免方法就出来了：在指针的解引用之前，一定确保指针指向一个绝对可用的空间。

(3)常规的做法是：

​        第一点：定义指针时，同时初始化为NULL

​        第二点：在指针解引用之前，先去判断这个指针是不是NULL

​        第三点：指针使用完之后，将其赋值为NULL

​        第四点：在指针使用之前，将其赋值绑定给一个可用地址空间

(4)野指针的防治方案4点绝对可行，但是略显麻烦。很多人懒得这么做，那实践中怎么处理？在中小型程序中，自己水平可以把握的情况下，不必严格参照这个标准；但是在大型程序，或者自己水平感觉不好把握时，建议严格参照这个方法。

 

### 4.3.3.3、NULL到底是什么？

```c
(1)NULL在C/C++中定义为：

#ifdef _cplusplus      // 定义这个符号就表示当前是C++环境

#define NULL 0       // 在C++中NULL就是0

#else

#define NULL (void *)0   // 在C中NULL是强制类型转换为void *的0

#endif
```

 

(2)在C语言中，int *p;你可以p = (int *)0;但是不可以p = 0;因为类型不相同。

(3)所以NULL的实质其实就是0，然后我们给指针赋初值为NULL，其实就是让指针指向0地址处。为什么指向0地址处？2个原因。

第一层原因是0地址处作为一个特殊地址（我们认为指针指向这里就表示指针没有被初始化，就表示是野指针）；

第二层原因是这个地址0地址在一般的操作系统中都是不可被访问的，如果C语言程序员不按规矩（不检查是否等于NULL就去解引用）写代码直接去解引用就会触发段错误，这种已经是最好的结果了。

(4)一般在判断指针是否野指针时，都写成

​    if (NULL != p)

而不是写成 if (p != NULL)

原因是：如果NULL写在后面，当中间是==号的时候，有时候容易忘记写成了=，这时候其实程序已经错误，但是编译器不会报错。这个错误（对新手）很难检查出来；如果习惯了把NULL写在前面，当错误的把==写成了=时，编译器会报错，程序员会发现这个错误。

 

## 4.3.4.const关键字与指针

### 4.3.4.1、const修饰指针的4种形式

(1)const关键字，在C语言中用来修饰变量，表示这个变量是常量。

(2)const修饰指针有4种形式，区分清楚这4种即可全部理解const和指针。

​        

第一种：const int *p;  //p 不是const，p指向的变量是const

​    第二种：int const *p;  // p不是const，p指向的变量是const

​    第三种：int * const p;  // p是const，而p指向的变量不是const

​    第四种：const int * const p; // p 和p指向的变量都是cosnt

 

(3)关于指针变量的理解，主要涉及到2个变量：第一个是指针变量p本身，第二个是p指向的那个变量(*p)。一个const关键字只能修饰一个变量，所以弄清楚这4个表达式的关键就是搞清楚const放在某个位置是修饰谁的

 

### 4.3.4.2、const修饰的变量真的不能改吗？

(1)课堂练习说明：const修饰的变量其实是可以改的（前提是gcc环境下）。

(2)在某些单片机环境下，const修饰的变量是不可以改的。const修饰的变量到底能不能真的被修改，取决于具体的环境，C语言本身并没有完全严格一致的要求。

(3)在gcc中，const是通过编译器在编译的时候执行检查来确保实现的（也就是说const类型的变量不能改是编译错误，不是运行时错误。）所以我们只要想办法骗过编译器，就可以修改const定义的常量，而运行时不会报错。

(4)更深入一层的原因，是因为gcc把const类型的常量也放在了data段，其实和普通的全局变量放在data段是一样实现的，只是通过编译器认定这个变量是const的，运行时并没有标记const标志，所以只要骗过编译器就可以修改了。

 

### 4.3.4.3、const究竟应该怎么用

(1)const是在编译器中实现的，编译时检查，并非不能骗过。所以在C语言中使用const，就好象是 一种道德约束而非法律约束，所以大家使用const时更多是传递一种信息，就是告诉编译器、也告诉读程序的人，这个变量是不应该也不必被修改的。

 

 

## 4.3.5.深入学习一下数组

### 4.3.5.1、从内存角度来理解数组

(1)从内存角度讲，数组变量就是一次分配多个变量，而且这多个变量在内存中的存储单元是依次相连接的。

(2)我们分开定义多个变量（譬如int a, b, c, d;）和一次定义一个数组（int a[4]）；这两种定义方法相同点是都定义了4个int型变量，而且这4个变量都是独立的单个使用的；不同点是单独定义时a、b、c、d在内存中的地址不一定相连，但是定义成数组后，数组中的4个元素地址肯定是依次相连的。

(3)数组中多个变量虽然必须单独访问，但是因为他们的地址彼此相连，因此很适合用指针来操作，因此数组和指针天生就叫纠结在一起。

 

### 4.3.5.2、从编译器角度来理解数组

(1)从编译器角度来讲，数组变量也是变量，和普通变量和指针变量并没有本质不同。变量的本质就是一个地址，这个地址在编译器中决定具体数值，具体数值和变量名绑定，变量类型决定这个地址的延续长度。

(2)搞清楚：变量、变量名、变量类型这三个概念的具体含义，很多问题都清楚了。

int a; char a;

 

### 4.3.5.3、数组中几个关键符号（a a[0] &a &a[0]）的理解（前提是 int a[10]）

(1)这4个符号搞清楚了，数组相关的很多问题都有答案了。理解这些符号的时候要和左值右值结合起来，也就是搞清楚每个符号分别做左值和右值时的不同含义。

(2)a就是数组名。a做左值时表示整个数组的所有空间（10×4=40字节），又因为C语言规定数组操作时要独立单个操作，不能整体操作数组，所以a不能做左值；a做右值表示数组首元素（数组的第0个元素，也就是a[0]）的首地址（首地址就是起始地址，就是4个字节中最开始第一个字节的地址）。a做右值等同于&a[0];

(2)a[0]表示数组的首元素，也就是数组的第0个元素。做左值时表示数组第0个元素对应的内存空间（连续4字节）；做右值时表示数组第0个元素的值（也就是数组第0个元素对应的内存空间中存储的那个数）

(3)&a就是数组名a取地址，字面意思来看就应该是数组的地址。&a不能做左值（&a实质是一个常量，不是变量因此不能赋值，所以自然不能做左值。）；&a做右值时表示整个数组的首地址。

(4)&a[0]字面意思就是数组第0个元素的首地址（搞清楚[]和&的优先级，[]的优先级要高于&，所以a先和[]结合再取地址）。做左值时表示数组首元素对应的内存空间，做右值时表示数组首元素的值（也就是数组首元素对应的内存空间中存储的那个数值）。做右值时&a[0]等同于a。

 

解释：为什么数组的地址是常量？因为数组是编译器在内存中自动分配的。当我们每次执行程序时，运行时都会帮我们分配一块内存给这个数组，只要完成了分配，这个数组的地址就定好了，本次程序运行直到终止都无法再改了。那么我们在程序中只能通过&a来获取这个分配的地址，却不能去用赋值运算符修改它。

 

总结：

1：&a和a做右值时的区别：&a是整个数组的首地址，而a是数组首元素的首地址。这两个在数字上是相等的，但是意义不相同。意义不相同会导致他们在参与运算的时候有不同的表现。

2：a和&a[0]做右值时意义和数值完全相同，完全可以互相替代。

3：&a是常量，不能做左值。

4：a做左值代表整个数组所有空间，所以a不能做左值。

 

## 4.3.6.指针与数组的天生姻缘

### 4.3.6.1、以指针方式来访问数组元素

(1)数组元素使用时不能整体访问，只能单个访问。访问方式有2种：数组形式和指针形式。

(2)数组格式访问数组元素是：数组名[下标]; (注意下标从0开始)

(3)指针格式访问数组元素是：*(指针+偏移量); 如果指针是数组首元素地址（a或者&a[0]），那么偏移量就是下标；指针也可以不是首元素地址而是其他哪个元素的地址，这时候偏移量就要考虑叠加了。

(4)数组下标方式和指针方式均可以访问数组元素，两者的实质其实是一样的。在编译器内部都是用指针方式来访问数组元素的，数组下标方式只是编译器提供给编程者一种壳（语法糖）而已。所以用指针方式来访问数组才是本质的做法。

 

### 4.3.6.2、从内存角度理解指针访问数组的实质

(1)数组的特点就是：数组中各个元素的地址是依次相连的，而且数组还有一个很大的特点（其实也是数组的一个限制）就是数组中各个元素的类型比较相同。类型相同就决定了每个数组元素占几个字节是相同的（譬如int数组每个元素都占4字节，没有例外）。

(2)数组中的元素其实就是地址相连接、占地大小相同的一串内存空间。这两个特点就决定了只要知道数组中一个元素的地址，就可以很容易推算出其他元素的地址。

 

### 4.3.6.3、指针和数组类型的匹配问题

(1)int *p; int a[5];  p = a;      // 类型匹配

(1)int *p; int a[5];  p = &a;     // 类型不匹配。p是int *，&a是整个数组的指针，也就是一个数组指针类型，不是int指针类型，所以不匹配

(2)&a、a、&a[0]从数值上来看是完全相等的，但是意义来看就不同了。从意义上来看，a和&a[0]是数组首元素首地址，而&a是整个数组的首地址；从类型来看，a和&a[0]是元素的指针，也就是int *类型；而&a是数组指针，是int (*)[5];类型。

 

### 4.3.6.4、总结：指针类型决定了指针如何参与运算

(1)指针参与运算时，因为指针变量本身存储的数值是表示地址的，所以运算也是地址的运算。

(2)指针参与运算的特点是，指针变量+1，并不是真的加1，而是加1*sizeof(指针类型)；如果是int *指针，则+1就实际表示地址+4，如果是char *指针，则+1就表示地址+1；如果是double *指针，则+1就表示地址+8.

(2)指针变量+1时实际不是加1而是加1×sizeof(指针类型)，主要原因是希望指针+1后刚好指向下一个元素（而不希望错位）。

 

 

## 4.3.7.指针与强制类型转换

### 4.3.7.1、变量的数据类型的含义

(1)所有的类型的数据存储在内存中，都是按照二进制格式存储的。所以内存中只知道有0和1，不知道是int的、还是float的还是其他类型。

(2)int、char、short等属于整形，他们的存储方式（数转换成二进制往内存中放的方式）是相同的，只是内存格子大小不同（所以这几种整形就彼此叫二进制兼容格式）；而float和double的存储方式彼此不同，和整形更不同。

(3)int a = 5;时，编译器给a分配4字节空间，并且将5按照int类型的存储方式转成二进制存到a所对应的内存空间中去（a做左值的）；我们printf去打印a的时候（a此时做右值），printf内部的vsprintf函数会按照格式化字符串（就是printf传参的第一个字符串参数中的%d之类的东西）所代表的类型去解析a所对应的内存空间，解析出的值用来输出。也就是说，存进去时是按照这个变量本身的数据类型来存储的（譬如本例中a为int所以按照int格式来存储）；但是取出来时是按照printf中%d之类的格式化字符串的格式来提取的。此时虽然a所代表的内存空间中的10101序列并没有变（内存是没被修改的）但是怎么理解（怎么把这些1010转成数字）就不一定了。譬如我们用%d来解析，那么还是按照int格式解析则值自然还是5；但是如果用%f来解析，则printf就以为a对应的内存空间中存储的是一个float类型的数，会按照float类型来解析，值自然是很奇怪的一个数字了。

总结：C语言中的数据类型的本质，就是决定了这个数在内存中怎么存储的问题，也就是决定了这个数如何转成二进制的问题。一定要记住的一点是内存只是存储1010的序列，而不管这些1010怎么解析。所以要求我们平时数据类型不能瞎胡乱搞。

分析几个题目：

\* 按照int类型存却按照float类型取 一定会出错

\* 按照int类型存却按照char类型取    有可能出错也有可能不出错

\* 按照short类型存却按照int类型取    有可能出错也有可能不出错

\* 按照float类型存却按照double取    一定会出错

 

### 4.3.7.2、指针的数据类型的含义

(1)指针的本质是：变量，指针就是指针变量

(2)一个指针涉及2个变量：一个是指针变量自己本身，一个是指针变量指向的那个变量。

(3)int *p;定义指针变量时，p（指针变量本身）是int *类型，*p（指针指向的那个变量）是int类型的。

(4)int *类型说白了就是指针类型，只要是指针类型就都是占4字节，解析方式都是按照地址的方式来解析（意思是里面存的32个二进制加起来表示一个内存地址）的。结论就是：所有的指针类型（不管是int * 还是char * 还是double *）的解析方式是相同的，都是地址。

(5)对于指针所指向的那个变量来说，指针的类型就很重要了。指针所指向的那个变量的类型（它所对应的内存空间的解析方法）要取决于指针类型。譬如指针是int *的，那么指针所指向的变量就是int类型的。

 

### 4.3.7.3、指针数据类型转换实例分析1（int * -> char *）

(1)int和char类型都是整形，类型兼容的。所以互转的时候有时候错有时候对。

(2)int和char的不同在于char只有1个字节而int有4个字节，所以int的范围比char大。在char所表示的范围之内int和char是可以互转的不会出错；但是超过了char的范围后char转成int不会错（向大方向转就不会错，就好比拿小瓶子的水往大瓶子倒不会漏掉不会丢掉），而从int到char转就会出错（就好象拿大瓶子水往小瓶子倒一样）

 

### 4.3.7.4、指针数据类型转换实例分析2（int * -> float *）

(1)之前分析过：int和float的解析方式是不兼容的，所以int *转成float *再去访问绝对会出错。

 

 

## 4.3.8.指针、数组与sizeof运算符

(1)sizeof是C语言的一个运算符（主要sizeof不是函数，虽然用法很像函数），sizeof的作用是用来返回()里面的变量或者数据类型占用的内存字节数。

(2)sizeof存在的价值？主要是因为在不同平台下各种数据类型所占的内存字节数不尽相同（譬如int在32位系统中为4字节，在16位系统中为2字节···）。所以程序中需要使用sizeof来判断当前变量/数据类型在当前环境下占几个字节。

### 4.3.8.1、char str[] = ”hello”; sizeof(str)   sizeof(str[0])   strlen(str)  

### 4.3.8.2、char *p=str;         sizeof(p)   sizeof(*p)  strlen(p)

(1)32位系统中所有指针的长度都是4，不管是什么类型的指针。

(2)strlen是一个C库函数，用来返回一个字符串的长度（注意，字符串的长度是不计算字符串末尾的'\0'的）。一定要注意strlen接收的参数必须是一个字符串（字符串的特征是以'\0'结尾）  

4.3.8.3、int n=10;             sizeof(n)  =4；

(1)sizeof测试一个变量本身，和sizeof测试这个变量的类型，结果是一样的。

### 4.3.8.4、int b[100];        sizeof(b)   

(1)sizeof(数组名)的时候，数组名不做左值也不做右值，纯粹就是数组名的含义。那么sizeof(数组名)实际返回的是整个数组所占用内存空间（以字节为单位的）。

### 4.3.8.5、

​       void fun(int b[100])

​    {

​                sizeof(b)   

​    }  

 

​              

(1)函数传参，形参是可以用数组的

(2)函数形参是数组时，实际传递是不是整个数组，而是数组的首元素首地址。也就是说函数传参用数组来传，实际相当于传递的是指针（指针指向数组的首元素首地址）。     

 

### 4.3.8.6、

​    \#define dpChar char *

​    typedef char *tpChar;

 

​    dpChar p1, p2;     sizeof(p1) sizeof(p2)

​    tpChar p3, p4;     sizeof(p3) sizeof(p4)

 

## 4.3.9.指针与函数传参

### 4.3.9.1、普通变量作为函数形参

(1)函数传参时，普通变量作为参数时，形参和实参名字可以相同也可以不同，实际上都是用实参来替代相对应的形参的。

(2)在子函数内部，形参的值等于实参。原因是函数调用时把实参的值赋值给了形参。

(3)这就是很多书上写的“传值调用”（相当于实参做右值，形参做左值）

 

### 4.3.9.2、数组作为函数形参

(1)函数名作为形参传参时，实际传递是不是整个数组，而是数组的首元素的首地址（也就是整个数组的首地址。因为传参时是传值，所以这两个没区别）。所以在子函数内部，传进来的数组名就等于是一个指向数组首元素首地址的指针。所以sizeof得到的是4.

(2)在子函数内传参得到的数组首元素首地址，和外面得到的数组首元素首地址的值是相同的。很多人把这种特性叫做“传址调用”（所谓的传址调用就是调用子函数时传了地址（也就是指针），此时可以通过传进去的地址来访问实参。）

(3)数组作为函数形参时，[]里的数字是可有可无的。为什么？因为数组名做形参传递的实际只是个指针，根本没有数组长度这个信息。

### 4.3.9.3、指针作为函数形参

(1)只有一句话：和数组作为函数形参是一样的.这就好像指针方式访问数组元素和数组方式访问数组元素的结果一样是一样的。

 

### 4.3.9.4、结构体变量作为函数形参

 

(1)**结构体变量作为函数形参的时候**，实际上和普通变量（类似于int之类的）传参时表现是一模一样的。所以说结构体变量其实也是普通变量而已。

(2)因为结构体一般都很大，所以如果直接用结构体变量进行传参，那么函数调用效率就会很低。（因为在函数传参的时候需要将实参赋值给形参，所以当传参的变量越大调用效率就会越低）。怎么解决？思路只有一个那就是不要传变量了，改传变量的指针（地址）进去。

(3)结构体因为自身太大，所以传参应该用指针来传（但是程序员可以自己决定，你非要传结构体变量过去C语言也是允许的，只是效率低了）；回想一下数组，为什么C语言设计的时候数组传参默认是传的数组首元素首地址而不是整个数组？

(4)、我们可以先将结构体变量的地址传到子函数，再用指针来访问结构体。

 

### 4.3.9.4、传值调用与传址调用

(1)传值调用描述的是这样一种现象：x和y作为实参，自己并没有真身进入swap1函数内部，而只是拷贝了一份自己的副本（副本具有和自己一样的值，但是是不同的变量）进入子函数swap1，然后我们在子函数swap1中交换的实际是副本而不是x、y真身。所以在swap1内部确实是交换了，但是到外部的x和y根本没有受影响。

 

(2)在swap2中x和y真的被改变了（但是x和y真身还是没有进入swap2函数内，而是swap2函数内部跑出来把外面的x和y真身改了）。实际上实参x和y永远无法真身进入子函数内部（进去的只能是一份拷贝），但是在swap2我们把x和y的地址传进去给子函数了，于是乎在子函数内可以通过指针解引用方式从函数内部访问到外部的x和y真身，从而改变x和y。

(3)结论：这个世界上根本没有传值和传址这两种方式，C语言本身函数调用时一直是传值的，只不过传的值可以是变量名，也可以是变量的指针。

 

## 4.3.10.输入型参数与输出型参数

### 4.3.10.1、函数为什么需要形参与返回值

(1)函数名是一个符号，表示整个函数代码段的首地址，实质是一个指针常量，所以在程序中使用到函数名时都是当地址用的，用来调用这个函数的。

(2)函数体是函数的关键，由一对{}括起来，包含很多句代码，函数体就是函数实际做的工作。

(3)形参列表和返回值。形参是函数的输入部分，返回值是函数的输出部分。对函数最好的理解就是把函数看成是一个加工机器（程序其实就是数据加工器），形参列表就是这个机器的原材料输入端；而返回值就是机器的成品输出端。

(4)其实如果没有形参列表和返回值，函数也能对数据进行加工，用全局变量即可。用全局变量来传参和用函数参数列表返回值来传参各有特点，在实践中都有使用。总的来说，函数参数传参用的比较多，因为这样可以实现模块化编程，而C语言中也是尽量减少使用全局变量。

(5)全局变量传参最大的好处就是省略了函数传参的开销，所以效率要高一些；但是实战中用的最多的还是传参，如果参数很多传参开销非常大，通常的做法是把很多参数打包成一个结构体，然后传结构体变量指针进去。

 

### 4.3.10.2、函数传参中使用const指针

(1)const一般用在函数参数列表中，用法是const int *p;（意义是指针变量p本身可变的，而p所指向的变量是不可变的）。

(2)const用来修饰指针做函数传参，作用就在于声明在函数内部不会改变这个指针所指向的内容，所以给该函数传一个不可改变的指针（char *p = "linux";这种）不会触发错误；而一个未声明为const的指针的函数，你给他传一个不可更改的指针的时候就要小心了。

​    *pstr =”linux”；//这样的形式，linux是不可以被更改的；

​    Pstr[ ] =”linux”; //数组的形式里的字符是可以被更改的；

### 4.3.10.3、函数需要向外部返回多个值时怎么办？

(1)一般来说，函数的收入部分就是函数参数，输出部分就是返回值。问题是函数的参数可以有很多个，而返回值只能有1个。这就造成我们无法让一个函数返回多个值。

(2)现实编程中，一个函数需要返回多个值是非常普遍的，因此完全依赖于返回值是不靠谱的，通常的做法是用参数来做返回（在典型的linux风格函数中，返回值是不用来返回结果的，而是用来返回0或者负数用来表示程序执行结果是对还是错，是成功还是失败）。

(3)普遍做法，编程中函数的输入和输出都是靠函数参数的，返回值只是用来表示函数执行的结果是对（成功）还是错（失败）。如果这个参数是用来做输入的，就叫输入型参数；如果这个参数的目的是用来做输出的，就叫输出型参数。

(4)输出型参数就是用来让函数内部把数据输出到函数外部的。

### 4.3.10.4、总结

(1)看到一个函数的原型后，怎么样一眼看出来哪个参数做输入哪个做输出？函数传参如果传的是普通变量（不是指针）那肯定是输入型参数；如果传指针就有2种可能性了，为了区别，经常的做法是：如果这个参数是做输入的（通常做输入的在函数内部只需要读取这个参数而不会需要更改它）就在指针前面加const来修饰；如果函数形参是指针变量并且还没加const，那么就表示这个参数是用来做输出型参数的。

譬如C库函数中strcpy函数。

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

# 第四章 C语言复杂表达式与指针高级应用

## 4.4.0. 章节概要

4.4.1.指针数组与数组指针

​    本节讲述2个很容易搞混淆的C语言复杂符号：指针数组与数组指针。并且希望通过这两个“入门级”的复杂符号引入C语言复杂表达式的解析方法。

4.4.2.函数指针与typedef

​    本节讲述函数指针这个更为复杂些的C语言复杂表达式，使用上节介绍过的方法来解析函数指针，让大家再次复习这种非常有效的分析方法。并且引入typedef关键。

4.4.3.函数指针实战1

​    本节进行函数指针的实战编程练习1，通过编写一个计算器程序，让大家体会函数指针的常规用法，并且指出其中隐含的面向对象的思维方式。

4.4.4.函数指针实战2

​    本节继续进行函数指针的实战编程练习2，是一个比较复杂的分层结构下用函数指针实现架构的案例，linux内核驱动中广泛使用了这种技巧。

4.4.5.再论typedef

​    本节详细系统的讲述typedef的惯用法和应用目的，除了整理之前提到的内容外，重点讲了typedef与结构体、typedef与const这两个新知识点。

4.4.6.二重指针

​    本节讲述二重指针，通过代码实例让大家明白二重指针的本质，从而更加明白指针变量的本质。通过示例讲了二重指针的几种常见应用方法，二重指针和指针数组的关系等。

 

4.4.7.二维数组

​    本节讲解二维数组，首先从内存角度分析二维数组，然后从下标访问和指针访问的角度分别访问数组元素，试图让大家理解二维数组的本质。

4.4.8.二维数组的运算和指针

​    本节将二维数组和指针结合起来，通过一些题目运算让大家了解二维数组和指针之间的一些运算规律，这也是在现实编程中困扰大家最多的地方。

## 4.4.1.指针数组与数组指针

### 4.4.1.1、字面意思来理解指针数组与数组指针

(1)指针数组的实质是一个数组，这个数组中存储的内容全部是指针变量。

(2)数组指针的实质是一个指针，这个指针指向的是一个数组。

### 4.4.1.2、分析指针数组与数组指针的表达式

(1)int *p[5];   int (*p)[5];   int *(p[5]);

(2)一般规律：int *p;(p是一个指针)； int p[5];(p是一个数组)

总结：我们在定义一个符号时，关键在于：首先要搞清楚你定义的符号是谁（

第一步：找核心）；

第二步：找结合其次再来看谁跟核心最近、谁跟核心结合；

第三步：继续向外结合直到整个符号完以后继续向外扩展。

(3)如何核心和*结合，表示核心是指针；如果核心和[]结合，表示核心是数组；如果核心和()结合，表示核心是函数。

(4)用一般规律来分析3个符号：

第一个：int *p[5]; 核心是p，p是一个数组，数组有5个元素大，数组中的元素都是指针，指针指向的元素类型是int类型的；整个符号是一个指针数组。

第二个，int (*p)[5];

核心是p，p是一个指针，指针指向一个数组，数组有5个元素，数组中存的元素是int类型； 总结一下整个符号的意义就是数组指针。

第三个，int *(p[5]);

解析方法和结论和第一个相同，()在这里是可有可无的。

 

注意：符号的优先级到底有什么用？其实是决定当2个符号一起作用的时候决定哪个符号先运算，哪个符号后运算。

遇到优先级问题怎么办？第一，查优先级表；第二，自己记住（全部记住都成神了，人只要记住[] . ->这几个优先级比较好即可）。

 

### 4.4.1.3、总结1：优先级和结合性是分析符号意义的关键

(1)在分析C语言问题时不要胡乱去猜测规律，不要总觉得c语言无从捉摸，从已知的规律出发按照既定的规则去做即可。

### 4.4.1.4、总结2：学会逐层剥离的分析方法

(1)找到核心后从内到外逐层的进行结合，结合之后可以把已经结合的部分当成一个整体，再去和整体外面的继续进行结合。

### 4.4.1.5、总结3：基础理论和原则是关键，没有无缘无故的规则

 

## 4.4.2.函数指针与typedef

### 4.4.2.1、函数指针的实质（还是指针变量）

(1)函数指针的实质还是指针，还是指针变量。本身占4字节（在32位系统中，所有的指针都是4字节）

(2)函数指针、数组指针、普通指针之间并没有本质区别，区别在于指针指向的东西是个什么玩意。

(3)函数的实质是一段代码，这一段代码在内存中是连续分布的（一个函数的大括号括起来的所有语句将来编译出来生成的可执行程序是连续的），所以对于函数来说很关键的就是函数中的第一句代码的地址，这个地址就是所谓的函数地址，在C语言中用函数名这个符号来表示。

(4)结合函数的实质，函数指针其实就是一个普通变量，这个普通变量的类型是函数指针变量类型，它的值就是某个函数的地址（也就是它的函数名这个符号在编译器中对应的值）

 

### 4.4.2.2、函数指针的书写和分析方法

(1)C语言本身是强类型语言（每一个变量都有自己的变量类型），编译器可以帮我们做严格的类型检查。

(2)所有的指针变量类型其实本质都是一样的，但是为什么在C语言中要去区分它们，写法不一样呢（譬如int类型指针就写作int *p; 数组指针就写作int (*p)[5]，函数指针就得写得更复杂）

(3)假设我们有个函数是：void func(void); 对应的函数指针：void (*p)(void); 类型是：void (*)(void);

(4)函数名和数组名最大的区别就是：函数名做右值时加不加&效果和意义都是一样的；但是数组名做右值时加不加&意义就不一样。

(5)写一个复杂的函数指针的实例：譬如函数是strcpy函数（char *strcpy(char *dest, const char *src);），对应的函数指针是：char *(*pFunc)(char *dest, const char *src);

 

### 4.4.2.3、typedef关键字的用法

(1)typedef是C语言中一个关键字，作用是用来定义（或者叫重命名类型）

(2)C语言中的类型一共有2种：一种是编译器定义的原生类型（基础数据类型，如int、double之类的）；第二种是用户自定义类型，不是语言自带的是程序员自己定义的（譬如数组类型、结构体类型、函数类型·····）。

(3)我们今天讲的数组指针、指针数组、函数指针等都属于用户自定义类型。

(4)有时候自定义类型太长了，用起来不方便，所以用typedef给它重命名一个短点的名字。

(5)注意：typedef是给类型重命名，也就是说typedef加工出来的都是类型，而不是变量。

 

### 4.4.2.4、总结：函数指针的分析方法也是源于优先级与逐层剥离的基本理论

 

## 4.4.3.函数指针实战1

### 4.4.3.1、用函数指针调用执行函数

(1)最简单的函数指针来调用函数的示例，在上节课中已经演示过了。

(2)本节演示的是用函数指针指向不同的函数来实现同一个调用执行不同的结果。

(3)如果学过C++或者Java或者C#等面向对象的语言，就会知道面向对象三大特征中有一个多态。多态就是同一个执行实际结果不一样，跟我们这里看到的现象其实是一样的。

(4)刚才的调试过程，可以得到很多信息：

第一：当程序出现段错误时，第一步先定位段错误。定位的方法就是在可疑处加打印信息，从而锁定导致段错误的语句，然后集中分析这句为什么会段错误。

第二：linux中命令行默认是行缓冲的，意思就是说当我们程序printf输出的时候，linux不会一个字一个字的输出我们的内容，而是将其缓冲起来放在缓冲区等一行准备完了再一次性把一行全部输出出来（为了效率）。linux判断一行有没有完的依据就是换行符'\n'（windows中换行符是\r\n, linux中是\n，iOS中是\r）。也就是说你printf再多，只要没有遇到\n（或者程序终止，或者缓冲区满）都不会输出而会不断缓冲，这时候你是看不到内容输出的。因此，在每个printf打印语句（尤其是用来做调试的printf语句）后面一定要加\n，否则可能导致误判。

第三：关于在linux命令行下用scanf写交互性代码的问题，想说以下几点：

​       \1. 命令行下的交互程序纯粹是用来学习编程用的，几乎没有实践意义，大家别浪费时间了。

​       \2. scanf是和系统的标准输入打交道，printf和标准输出打交道。要完全搞清楚这些东西得把标准输入标准输出搞清楚。

​       \3. 我们用户在输入内容时结尾都会以\n结尾，但是程序中scanf的时候都不会去接收最后的\n，导致这个回车符还存留在标准输入中。下次再scanf时就会先被拿出来，这就导致你真正想拿的那个数反而没机会拿，导致错误。

 

### 4.4.4.函数指针实战2

**主题：结构体内嵌函数指针实现分层**

(1)程序为什么要分层？因为复杂程序东西太多一个人搞不定，需要更多人协同工作，于是乎就要分工。要分工先分层，分层之后各个层次由不同的人完成，然后再彼此调用组合共同工作。

(2)本程序要完成一个计算器，我们设计了2个层次：上层是framework.c，实现应用程序框架；下层是cal.c，实现计算器。实际工作时cal.c是直接完成工作的，但是cal.c中的关键部分是调用的framework.c中的函数来完成的。

(3)先写framework.c，由一个人来完成。这个人在framework.c中需要完成计算器的业务逻辑，并且把相应的接口写在对应的头文件中发出来，将来别的层次的人用这个头文件来协同工作。

(4)另一个人来完成cal.c，实现具体的计算器；这个人需要framework层的工作人员提供头文件来工作（但是不需要framework.c）

(5)总结：

第一：本节和上节实际完成的是同一个习题，但是采用了不同的程序架构。

第二：对于简单问题来说，上节的不分层反而容易理解，反而简单；本节的分层代码不好理解，看起来有点把简单问题复杂化的意思。原因在于我们这个问题本身确实是简单问题，而简单问题就应该用简单方法处理。我们为什么明知错误还要这样做？目的是向大家演示这种分层的写代码的思路和方法。

第三：分层写代码的思路是：有多个层次结合来完成任务，每个层次专注各自不同的领域和任务；不同层次之间用头文件来交互。

第四：分层之后上层为下层提供服务，上层写的代码是为了在下层中被调用。

第五：上层注重业务逻辑，与我们最终的目标相直接关联，而没有具体干活的函数。

第六：下层注重实际干活的函数，注重为上层填充变量，并且将变量传递给上层中的函数（其实就是调用上层提供的接口函数）来完成任务。

第七：下层代码中其实核心是一个结构体变量（譬如本例中的struct cal_t），写下层代码的逻辑其实很简单：第一步先定义结构体变量；第二步填充结构体变量；第三步调用上层写好的接口函数，把结构体变量传给它既可。

 

## 4.4.5.再论typedef

### 4.4.5.1、C语言的2种类型：内建类型与用户自定义类型

(1)内建类型ADT（auto define type）、自定义类型UDT(user define type);

### 4.4.5.2、typedef定义（或者叫重命名）类型而不是变量

(1)类型是一个数据模板，变量是一个实在的数据。类型是不占内存的，而变量是占内存的。

(2)面向对象的语言中：类型就是类class，变量就是对象。

### 4.4.5.3、typedef与#define宏的区别

typedef char *pChar;

\#define pChar char *

### 4.4.5.4、typedef与结构体

(1)结构体在使用时都是先定义结构体类型，再用结构体类型去定义变量。

​    struct student     //定义了一个 结构体类型，它是类型并不是变量

{

​    char name[20];

​    int age;

};

struct student s1;     // struct student是类型；s1是变量

  s1.age = 12;

 

(2)C语言语法规定，结构体类型使用时必须是struct 结构体类型名 结构体变量名;这样的方式来定义变量。

// 第一个类型名：struct student，第二个类型名是student

typedef struct student

{

  char name[20];

  int age;

}student;

  Student s1;     //定义变量不用struct 直接用student

  S1.name[1] = “小明”；

(3)使用typedef一次定义2个类型，分别是结构体变量类型，和结构体变量指针类型。

​    // 我们一次定义了2个类型：

// 第一个是结构体类型，有2个名字：struct teacher，teacher

// 第二个是结构体指针类型，有2个名字：struct teacher *， pTeacher

typedef struct teacher

{

​      char name[20];

​      int age;

​      int mager;

}teacher, *pTeacher;  

teacher t1;

  t1.age = 23;

  pTeacher p1 = &t1;

  printf("teacher age = %d.\n", p1->age);

输出 23

 

 

### 4.4.5.5、typedef与const

(1)typedef int *PINT;   const PINT p2; 相当于是int *const p2;

(2)typedef int *PINT;   PINT const p2; 相当于是int *const p2;

(3)如果确实想得到const int *p;这种效果，只能typedef const int *CPINT; CPINT p1;

 

### 4.4.5.6、使用typedef的重要意义（2个：简化类型、创造平台无关类型）

(1)简化类型的描述。

  char *(*)(char *, char *);   typedef char *(*pFunc)(char *, char *); 

 

 (2)很多编程体系下，人们倾向于不使用int、double等C语言内建类型，因为这些类型本身和平台是相关的（譬如int在16位机器上是16位的，在32位机器上就是32位的）。为了解决这个问题，很多程序使用自定义的中间类型来做缓冲。譬如linux内核中大量使用了这种技术.

内核中先定义：typedef int size_t; 然后在特定的编码需要下用size_t来替代int（譬如可能还有typedef int len_t）

(3)STM32的库中全部使用了自定义类型，譬如typedef volatile unsigned int vu32;

 

 

 

## 4.4.6.二重指针

### 4.4.6.1、二重指针与普通一重指针的区别

(1)本质上来说，二重指针和一重指针的本质都是指针变量，指针变量的本质就是变量。

(2)一重指针变量和二重指针变量本身都占4字节内存空间，char a;

​    

​    char **p1;   // 二重指针

  char *p2;    // 一重指针

  char *a;

  printf("sizeof(p1) = %d.\n", sizeof(p1)); //输出4

  printf("sizeof(p2) = %d.\n", sizeof(p2)); //输出4

  

  p2 = &a;

  //p1 = &a;   // p1是char **类型，&a是char *类型。

​          // char **类型就是指针指向的变量是char *类型

​          // char *类型表示指针指向的变量是char类型。

  p1 = &p2;    // p2本身是char *类型，再取地址变成char **类型，和p1兼容。

 

 

### 4.4.6.2、二重指针的本质

(1)二重指针本质上也是指针变量，和普通指针的差别就是它指向的变量类型必须是个一重指针。二重指针其实也是一种数据类型，编译器在编译时会根据二重指针的数据类型来做静态类型检查，一旦发现运算时数据类型不匹配编译器就会报错。

(2)C语言中如果没有二重指针行不行？其实是可以的。一重指针完全可以做二重指针做的事情，之所以要发明二重指针（函数指针、数组指针），就是为了让编译器了解这个指针被定义时定义它的程序员希望这个指针被用来指向什么东西（定义指针时用数据类型来标记，譬如int *p，就表示p要指向int型数据），编译器知道指针类型之后可以帮我们做静态类型检查。编译器的这种静态类型检查可以辅助程序员发现一些隐含性的编程错误，这是C语言给程序员提供的一种编译时的查错机制。

(3)为什么C语言需要发明二重指针？原因和发明函数指针、数组指针、结构体指针等一样的。

### 4.4.6.3、二重指针的用法

(1)二重指针指向一重指针的地址

int *p1[5];

  int *p2;

  int **p3;

  

  //p2 = p1;   //不可以

  p3 = p1;    // p1是指针数组名，本质上是数组名，数组名做右值表示数组首元素

​          // 首地址。数组的元素就是int *类型，所以p1做右值就表示一个int *

​          // 类型变量的地址，所以p1就是一个int类型变量的指针的指针，所以

​          // 它就是一个二重指针int **；

 

 

 (2)二重指针指向指针数组的

(3)实践编程中二重指针用的比较少，大部分时候就是和指针数组纠结起来用的。

(4)实践编程中有时在函数传参时为了通过函数内部改变外部的一个指针变量，会传这个指针变量的地址（也就是二重指针）进去

​     void func(int **p)

{

*p = (int *)0x12345678;

//**p = 6; //这样可以改变a的值；

}

 

int main(void)

{

​    int a = 4;

​    int *p = &a;        // p指向a

​    printf("p = %p.\n", p);   // p打印出来就是a的内存地址

printf("&p = %p.\n", &p);

​    func(&p);          // 在func内部将p指向了别的地方

​    printf("fp = %p.\n", p);  // p已经不指向a了，所以打印出来不是a的地址

​    *p = 23;  

  }              // 因为此时p指向0x12345678，但是这个地址是不允许访问的，因此会段错误。

​                

  输出： p = 0x62fe1c.； &p = 0x62fe10.；

​      Fp= 0x12345678;

  & p相当于吧p的地址放在&p（0x62fe10） 当 p 是这个地址0x62fe1c；*p

  传*p只能改变a的值， **p 能改变p的值。

 

int main()

{

​    int *p;

​    int **p1;

​    int a;

​    a = 3;

​    printf("&a = %x\n",&a);

​    p = &a;

​    printf("p = %x\n",p);

​    p1 = &p;

​    printf("&p% = %x",&p);

  

​    return 0;

 }

 

&a = 62fe0c

p = 62fe0c

&p= 62fe10

 

&p时，相当于编译器将p存放a的地址62fe0c变为一个地址变量放到地址为62fe10的内存中去了，这样，p就能被改变了（自己的理解）。

### 4.4.6.4、二重指针与数组指针

(1)二重指针、数组指针、结构体指针、一重指针、普通变量的本质都是相同的，都是变量。

(2)所有的指针变量本质都是相同的，都是4个字节，都是用来指向别的东西的，不同类型的指针变量只是可以指向的（编译器允许你指向的）变量类型不同。

(3)二重指针就是：指针数组指针

 

##  

## 4.4.7.二维数组

### 4.4.7.1、二维数组的内存映像

(1)一维数组在内存中是连续分布的多个内存单元组成的，而二维数组在内存中也是连续分布的多个内存单元组成的。

(1)从内存角度来看，一维数组和二维数组没有本质差别。

(2)二维数组int a[2][5]和一维数组int b[10]其实没有任何本质差别。我们可以把两者的同一单元的对应关系写下来。

a[0][0]    a[0][1]  a[0][4]  a[1][0]  a[1][1]    a[1][4] 

b[0]    b[1]      b[4]    b[5]    b[6]   b[9]

(3)既然二维数组都可以用一维数组来表示，那二维数组存在的意义和价值在哪里？明确告诉大家：二维数组a和一维数组b在内存使用效率、访问效率上是完全一样的（或者说差异是忽略不计的）。在某种情况下用二维数组而不用一维数组，原因在于二维数组好理解、代码好写、利于组织。

(4)总结：我们使用二维数组（C语言提供二维数组），并不是必须，而是一种简化编程的方式。想一下，一维数组的出现其实也不是必然的，也是为了简化编程。

 

### 4.4.7.2、哪个是第一维哪个是第二维？

(1)二维数组int a[2][5]中，2是第一维，5是第二维。

(2)结合内存映像来理解二维数组的第一维和第二维的意义。首先第一维是最外面一层的数组，所以int a[2][5]这个数组有2个元素；其中每一个元素又是一个含有5个元素的一维数组（这个数组就是第二维）。

(3)总结：二维数组的第一维是最外部的那一层，第一维本身是个数组，这个数组中存储的元素也是个一维数组；二维数组的第二维是里面的那一层，第二维本身是个一维数组，数组中存的元素是普通元素，第二维这个一维数组本身作为元素存储在第一维的二维数组中。

 

### 4.4.7.3、二维数组的下标式访问和指针式访问

(1)回顾：一维数组的两种访问方式。以int b[10]为例, int *p = b;。

b[0] 等同于 *(p+0);  b[9] 等同于 *(p+9); b[i] 等同于 *(p+i)

(2)二维数组的两种访问方式：以int a[2][5]为例，(合适类型的)p = a;

**a[0][0]等同于\*(\*(p+0)+0);     a[i][j]等同于 \*(\*(p+i)+j)**

 

### 4.4.7.4、二维数组的应用和更多维数组

 

(1)最简单情况，有10个学生成绩要统计；如果这10个学生没有差别的一组，就用b[10]；如果这10个学生天然就分为2组，每组5个，就适合用int a[2][5]来管理。

(2)最常用情况：一维数组用来表示直线，二维数组用来描述平面。数学上，用平面直角坐标系来比拟二维数组就很好理解了。

(3)三维数组和三维坐标系来比拟理解。三维数组其实就是立体空间。

(4)四维数组也是可以存在的，但是数学上有意义，现在空间中没有对应（因为人类生存的宇宙是三维的）。

总结：一般常用最多就到二维数组，三维数组除了做一些特殊与数学运算有关的之外基本用不到。（四轴飞行器中运算飞行器角度、姿态时就要用到三维数组）。

 

 

 

 

## 4.4.8.二维数组的运算和指针

### 4.4.8.1、指针指向二维数组的数组名

(1)二维数组的数组名表示二维数组的第一维数组中首元素（也就是第二维的数组）的首地址

int a[2][5] = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}};

  //int a[2][5] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

  

  printf("a[1][3] = %d.\n", a[1][3]);

  printf("a[1][3] = %d.\n", *(*(a+1)+3));

  

  //int *p1 = a;   // 类型不匹配

  //int **p2 = a;   // 类型不匹配

  // 指针指向二维数组的数组名

  int (*p3)[5];    // 数组指针，指针指向一个数组，数组有5个int类型元素

  p3 = a;     // a是二维数组的数组名，作为右值表示二维数组第一维的数组

​            // 的首元素首地址，等同于&a[0]

  p3 = &a[0];

  

  printf("a[0][3] = %d.\n", *(*(p3+0)+3));

  printf("a[1][4] = %d.\n", *(*(p3+1)+4));

 

 (2)二维数组的数组名a等同于&a[0]，这个和一维数组的符号含义是相符的。

(3)用数组指针来指向二维数组的数组名是类型匹配的。

 

### 4.4.8.2、指针指向二维数组的第一维

(1)用int *p来指向二维数组的第一维a[i]

// 指针指向二维数组的第一维

  //int *p4 = &a[0];   // 不可以

  int *p4 = a[0];     // a[0]表示二维数组的第一维的第一个元素，相当于是

​              // 第二维的整体数组的数组名。数组名又表示数组首元素

​              // 首地址，因此a[0]等同于&a[0][0];

  

  int *p5 = &a[0][0]; 

  printf("a[0][4] = %d.\n", *(p4+4));

  int *p6 = a[1];

  printf("a[1][1] = %d.\n", *(p6+1));

 

### 4.4.8.3、指针指向二维数组的第二维

(1)二维数组的第二维元素其实就是普通变量了（a[1][1]其实就是int类型的7），已经不能用指针类型和它相互赋值了。

(2)除非int *p = &a[i][j];，类似于指针指向二维数组的第一维。

 

总结：二维数组和指针的纠葛，关键就是2点：

1、数组中各个符号的含义。

2、数组的指针式访问，尤其是二维数组的指针式访问。



 

# 第五章 数组&字符串&结构体&共用体&枚举

## 4.5.0 章节概要

**4.5.1.程序中内存从哪里来1**

​    本节首先引出程序运行时对内存的依赖，然后分析这些变量需要的内存从哪里来，进而引出栈、堆、数据区这几个重要的内存来源，并详解栈内存分配及使用的细节。

**4.5.2.程序中内存从哪里来2**

​    本节详细讲解堆内存的特点和使用，写代码带大家来学会使用malloc、free函数获取及释放堆内存，并且讲解了堆内存的一些编程细节。

**4.5.3.程序中内存从哪里来3**

​    本节详细讲解堆内存的特点和使用，写代码带大家来学会使用malloc、free函数获取及释放堆内存，并且讲解了堆内存的一些编程细节。

**4.5.4.程序中内存从哪里来4**

​    本节首先引入代码段、数据段、bss段等概念，然后重点分析了数据段和bss段与C语言编程变量的关系，最后给大家总结了程序通过数据段方式获取内存的原理和使用细节。

**4.5.5.C语言的字符串类型**

​    本节讲述C语言字符串类型的本质，着重解释了C语言字符串的三个特点：指针指向头、固定结尾、内存相连分布。

**4.5.6.字符串和字符数组的细节**

​    本节讲述字符串和字符数组及其各种初始化式，然后结合sizeof运算符和strlen函数，通过代码实践试图让大家理解字符串和字符数组的具体表现。

**4.5.7.C语言之结构体概述**

​    本节概述结构体，主要讲了结构体和数组的差异，然后以点号方式和指针方式这两种方式来访问结构体成员，以此告诉大家结构体成员访问的原理。

**4.5.8.结构体的对齐访问1**

​    本节开始讲解结构体的对齐访问，通过数个结构体实例来讲解对齐访问的规则和sizeof测试结构体的大小，最后补充讲解了#prgama和__attribute__这两种方式下对结构体对齐规则的影响。共分3节，本节为第1节。

**4.5.9.结构体的对齐访问2**

​    本节开始讲解结构体的对齐访问，通过数个结构体实例来讲解对齐访问的规则和sizeof测试结构体的大小，最后补充讲解了#prgama和__attribute__这两种方式下对结构体对齐规则的影响。共分3节，本节为第2节。

**4.5.10.结构体的对齐访问3**

​    本节开始讲解结构体的对齐访问，通过数个结构体实例来讲解对齐访问的规则和sizeof测试结构体的大小，最后补充讲解了#prgama和__attribute__这两种方式下对结构体对齐规则的影响。共分3节，本节为第3节。

**4.5.11.offsetof宏与container_of宏**

​    本节讲解linux内核中常用的2个结构体相关的宏：offsetof和container_of，这两个宏充分利用了结构体、指针、数据类型、内存等知识，是C语言中比较高端的语法应用。通过理解及使用这两个宏可以极大提升C语言的功底，并且为学习linux内核做积累。

**4.5.12.共用体union**

​    本节首先介绍union，然后着重对比分析了union和struct的异同点，重点强调了共用体和结构体的差别，让大家理解共用体的实质。

 

**4.5.13.大小端模式1**

​    本节首先引入大小端的概念，然后介绍了常用的几种用代码来测试机器大小端模式的方式.

**4.5.14.大小端模式2**

​    本节继续讲解大小端，介绍了几种看起来似乎可以但是实际上并不工作的大小端测试代码。同时介绍了在通信系统中应用的大小端概念。

**4.5.15.枚举**

​    本节讲述C语言中的枚举常量，首先通过实例告诉大家枚举常量的定义和使用方法，然后讲解枚举和宏定义的异同，旨在告诉大家什么时候可以用枚举。

## 4.5.1.程序中内存从哪里来1

### 4.5.1.1、程序执行需要内存支持

()对程序来说，内存就是程序的立足之地（程序是被放在内存中运行的）；程序运行时需要内存来存储一些临时变量。

### 4.5.1.2、内存管理最终是由操作系统完成的

(1)内存本身在物理上是一个硬件器件，由硬件系统提供。

(2)内存是由操作系统统一管理。为了内存管理方便又合理，操作系统提供了多种机制来让我们应用程序使用内存。这些机制彼此不同，各自有各自的特点，我们程序根据自己的实际情况来选择某种方式获取内存（在操作系统处登记这块内存的临时使用权限）、使用内存、释放内存（向操作系统归还这块内存的使用权限）。

### 4.5.1.3、三种内存来源：栈（stack）、堆（heap）、数据区（.data）

(1)在一个C语言程序中，能够获取的内存就是三种情况：栈（stack）、堆（heap）、数据区（.data）

### 4.5.1.4、栈的详解

​    运行时自动分配&自动回收：栈是自动管理的，程序员不需要手工干预。方便简单。

​    反复使用：栈内存在程序中其实就是那一块空间，程序反复使用这一块空间。

​    脏内存：栈内存由于反复使用，每次使用后程序不会去清理，因此分配到时保留原来的值。

​    临时性：（函数不能返回栈变量的指针，因为这个空间是临时的）

 函数不能返回函数内部局部变量的地址，因为这个函数执行完返回后这个局部变量已经不在了 这个局部变量是分配在栈上的，虽然不在了但是栈内存还在还可以访问，但是访问时实际上这个内存地址已经和当时那个变量无关了。

​    栈会溢出：因为操作系统事先给定了栈的大小，如果在函数中无穷尽的分配栈内存总能用完。

​    

​    

## 4.5.2.程序中内存从哪里来2

### 4.5.2.1、堆内存详解

​    操作系统堆管理器管理：堆管理器是操作系统的一个模块，堆管理内存分配灵活，按需分配。

​    大块内存：堆内存管理者总量很大的操作系统内存块，各进程可以按需申请使用，使用完释放。

​    程序手动申请&释放：手工意思是需要写代码去申请malloc和释放free。

​    脏内存：堆内存也是反复使用的，而且使用者用完释放前不会清除，因此也是脏的。

​    临时性：堆内存只在malloc和free之间属于我这个进程，而可以访问。在malloc之前和free之后

​           都不能再访问，否则会有不可预料的后果。

​    

### 4.5.2.2、堆内存使用范例

(1)void *是个指针类型，malloc返回的是一个void *类型的指针，实质上malloc返回的是堆管理器分配给我本次申请的那段内存空间的首地址（malloc返回的值其实是一个数字，这个数字表示一个内存地址）。为什么要使用void *作为类型？主要原因是malloc帮我们分配内存时只是分配了内存空间，至于这段空间将来用来存储什么类型的元素malloc是不关心的，由我们程序自己来决定。

(2)**什么是void类型**。早期被翻译成空型，这个翻译非常不好，会误导人。void类型不表示没有类型，而表示**万能类型**。void的意思就是说这个数据的类型当前是不确定的，在需要的时候可以再去指定它的具体类型。void *类型是一个指针类型，这个指针本身占4个字节，但是指针指向的类型是不确定的，换句话说这个指针在需要的时候可以被强制转化成其他任何一种确定类型的指针，也就是说这个指针可以指向任何类型的元素。

(3)malloc的返回值：成功申请空间后返回这个内存空间的指针，申请失败时返回NULL。所以malloc获取的内存指针使用前一定要先检验是否为NULL。

(4)malloc申请的内存时用完后要free释放。free(p);会告诉堆管理器这段内存我用完了你可以回收了。堆管理器回收了这段内存后这段内存当前进程就不应该再使用了。因为释放后堆管理器就可能把这段内存再次分配给别的进程，所以你就不能再使用了。

(5)再调用free归还这段内存之前，指向这段内存的指针p一定不能丢（也就是不能给p另外赋值）。因为p一旦丢失这段malloc来的内存就永远的丢失了（内存泄漏），直到当前程序结束时操作系统才会回收这段内存。

// 第一步：申请和绑定

  int *p = (int *)malloc(1000*sizeof(int));

  // 第二步：检验分配是否成功

  if (NULL == p)

  {

​    printf("malloc error.\n");

​    return -1;

  }

  

  // 第三步：使用申请到的内存

  //p = NULL;

//p = &a;    // 如果在free之前给p另外赋值，那么malloc申请的那段内存就丢失掉了

// malloc后p和返回的内存相绑定，p是那段内存在当前进程的唯一联系人

// 如果p没有free之前就丢了，那么这段内存就永远丢了。丢了的概念就是

// 在操作系统的堆管理器中这段内存是当前进程拿着的，但是你也用不了

// 所以你想申请新的内存来替换使用，这就叫程序“吃内存”，学名叫内存泄漏

（6）malloc 使用四部曲：

//第一步分配

  int *p = (int *)malloc(20);

  // 第二步：检验分配是否成功

  if (NULL == p)

  {  

​    printf("malloc error.\n");

​    return -1;

  }；

  //第三步使用

  *(p+3) = 12;

  *(p+300000) = 1234;

  printf("*(p+3) = %d.\n", *(p+3));

  printf("*(p+300000) = %d.\n", *(p+300000));   

  //第四步释放：

free(p);

 

​                  

### 4.5.2.3、malloc的一些细节表现

​    malloc(0)  分配16Byte

malloc申请0字节内存本身就是一件无厘头事情，一般不会碰到这个需要。

如果真的malloc(0)返回的是NULL还是一个有效指针？答案是：实际分配了16Byte的一段内存并且返回了这段内存的地址。这个答案不是确定的，因为C语言并没有明确规定malloc(0)时的表现，由各malloc函数库的实现者来定义。

 

​    malloc(4) 分配16Byte

gcc中的malloc默认最小是以16B为分配单位的。如果malloc小于16B的大小时都会返回一个16字节的大小的内存。malloc实现时没有实现任意自己的分配而是允许一些大小的块内存的分配。

​    

​    malloc(20)去访问第25、第250、第2500····会怎么样

实战中：120字节处正确，1200字节处正确····终于继续往后访问总有一个数字处开始段错误了。

 C 语言还有很多不是很严谨的地方，也就是没有给你在使用上加以限定，这就会导致你程序出错你还不知道，所以在使用malloc还是严格按照要求，分配多大的内存内进行访问读写操作。

​    

## 4.5.4.程序中内存从哪里来3

### 4.5.4.1、代码段、数据段、bss段

(1)编译器在编译程序的时候，将程序中的所有的元素分成了一些组成部分，各部分构成一个段，所以说段是可执行程序的组成部分。

(2)代码段：代码段就是程序中的可执行部分，直观理解代码段就是函数堆叠组成的。

(3)数据段（也被称为数据区、静态数据区、静态区）：数据段就是程序中的数据，直观理解就是C语言程序中的全局变量。（注意：全局变量才算是程序的数据，局部变量不算程序的数据，只能算是函数的数据）

(4)bss段（又叫ZI(zero initial)段）：bss段的特点就是被初始化为0，bss段本质上也是属于数据段，bss段就是被初始化为0的数据段。

注意区分：数据段（.data）和bss段的区别和联系：二者本来没有本质区别，都是用来存放C程序中的全局变量的。区别在于把显示初始化为非零的全局变量存在.data段中，而把显式初始化为0或者并未显式初始化（C语言规定未显式初始化的全局变量值默认为0）的全局变量存在bss段。

 

4.5.4.2、有些特殊数据会被放到代码段

(1)C语言中使用char *p = "linux";定义字符串时，字符串"linux"实际被分配在代码段，也就是说这个"linux"字符串实际上是一个常量字符串而不是变量字符串。

(2)const型常量：C语言中const关键字用来定义常量，常量就是不能被改变的量。const的实现方法至少有2种：

第一种就是编译将const修饰的变量放在代码段去以实现不能修改（普遍见于各种单片机的编译器）；

第二种就是由编译器来检查以确保const型的常量不会被修改，实际上const型的常量还是和普通变量一样放在数据段的（gcc中就是这样实现的）。

 

### 4.5.4.3、显式初始化为非零的全局变量和静态局部变量放在数据段

(1)放在.data段的变量有2种：第一种是显式初始化为非零的全局变量。第二种是静态局部变量，也就是static修饰的局部变量。（普通局部变量分配在栈上，静态局部变量分配在.data段）

 

### 4.5.4.4、未初始化或显式初始化为0的全局变量放在bss段

(1)bss段和.data段并没有本质区别，几乎可以不用明确去区分这两种。

 

### 4.5.4.5、总结：C语言中所有变量和常量所使用的内存无非以上三种情况。

(1)相同点：三种获取内存的方法，都可以给程序提供可用内存，都可以用来定义变量给程序用。

(2)不同点：栈内存对应C中的普通局部变量（别的变量还用不了栈，而且栈是自动的，由编译器和运行时环境共同来提供服务的，程序员无法手工控制）；堆内存完全是独立于我们的程序存在和管理的，程序需要内存时可以去手工申请malloc，使用完成后必须尽快free释放。（堆内存对程序就好象公共图书馆对于人）；数据段对于程序来说对应C程序中的全局变量和静态局部变量。

(3)如果我需要一段内存来存储数据，我究竟应该把这个数据存储在哪里？

char str[] = "linux";    // 第二种方法：定义成全局变量，放在数据段

 

int main(void)

{

  char a[] = "linux";   // 第一种方法：定义成局部变量，放在栈上

  

  char *p = (char *)malloc(10); // 第三种方法： 放在malloc申请的堆内存中 

  if (NULL == p)

  {

​    printf("malloc error.\n");

​    return -1;

  }

  memset(p, 0, 10);    

  strcpy(p, "linux");

（或者说我要定义一个变量，我究竟应该定义为局部变量还是全局变量还是用malloc来实现）。不同的存储方式有不同的特点，简单总结如下：

​    \* 函数内部临时使用，出了函数不会用到，就**定义局部变量**

​    \* 堆内存和数据段几乎拥有完全相同的属性，大部分时候是可以完全替换的。但是生命周期不一，堆内存的生命周期是从malloc开始到free结束，而全局变量是从整个程序一开始执行就开始，直到整个程序结束才会消灭，伴随程序运行的一生。

启示：如果你这个变量只是在程序的一个阶段有用，用完就不用了，就适合用**堆内存**；

如果这个变量本身和程序是一生相伴的，那就适合用**全局变量**。（堆内存就好象租房、数据段就好象买房。堆内存就好象图书馆借书，数据段就好象自己书店买书）你以后会慢慢发现：买不如租，堆内存的使用比全局变量广泛。

 

## 4.5.5.C语言的字符串类型

### 4.5.5.1、C语言没有原生字符串类型

(1)很多高级语言像java、C#等就有字符串类型，有个String来表示字符串，用法和int这些很像，可以String s1 = "linux";来定义字符串类型的变量。

(2)C语言没有String类型，C语言中的字符串是通过字符指针来间接实现的。

 

### 4.5.5.2、C语言使用指针来管理字符串

(1)C语言中定义字符串方法：char *p = "linux";此时p就叫做字符串，但是实际上p只是一个字符指针（本质上就是一个指针变量，只是p指向了一个字符串的起始地址而已）。

### 4.5.5.3、C语言中字符串的本质：指针指向头、固定尾部的地址相连的一段内存

(1)字符串就是一串字符。字符反映在现实中就是文字、符号、数字等人用来表达的字符，反映在编程中字符就是字符类型的变量。C语言中使用ASCII编码对字符进行编程，编码后可以用char型变量来表示一个字符。字符串就是多个字符打包在一起共同组成的。

(2)字符串在内存中其实就是多个字节连续分布构成的（类似于数组，字符串和字符数组非常像）

(3)C语言中字符串有3个核心要点：第一是用一个指针指向字符串头；第二是固定尾部（字符串总是以'\0'来结尾）；第三是组成字符串的各字符彼此地址相连。

(4)'\0'是一个ASCII字符，其实就是编码为0的那个字符（真正的0，和数字0是不同的，数字0有它自己的ASCII编码）。要注意区分'\0'和'0'和0.（0等于'\0'，'0'等于48）

(5)'\0'作为一个特殊的数字被字符串定义为（幸运的选为）结尾标志。产生的副作用就是：字符串中无法包含'\0'这个字符。（C语言中不可能存在一个包含'\0'字符的字符串），这种思路就叫“魔数”（魔数就是选出来的一个特殊的数字，这个数字表示一个特殊的含义，你的正式内容中不能包含这个魔数作为内容）。

 

### 4.5.5.4、注意：指向字符串的指针和字符串本身是分开的两个东西

(1)char *p = "linux";在这段代码中，p本质上是一个字符指针，占4字节；"linux"分配在代码段，占6个字节；实际上总共耗费了10个字节，这10个字节中：4字节的指针p叫做字符串指针（用来指向字符串的，理解为字符串的引子，但是它本身不是字符串），5字节的用来存linux这5个字符的内存才是真正的字符串，最后一个用来存'\0'的内存是字符串结尾标志（本质上也不属于字符串）。

 

### 4.5.5.5、存储多个字符的2种方式：字符串和字符数组

(1)我们有多个连续字符（典型就是linux这个字符串）需要存储，实际上有两种方式：第一种就是字符串；第二种是字符数组。、

char *p = "linux";     // 字符串

  char a[] = "linux";     // 字符数组

  

  printf("p = %s.\n", p);

  printf("a = %s.\n", a);

 

​    

 

## 4.5.6.字符串和字符数组的细节

### 4.5.6.1、字符数组初始化与sizeof、strlen

(1)sizeof是C语言的一个关键字，也是C语言的一个运算符（sizeof使用时是sizeof(类型或变量名)，所以很多人误以为sizeof是函数，其实不是），sizeof运算符用来返回一个类型或者是变量所占用的内存字节数。为什么需要sizeof？主要原因一是int、double等原生类型占几个字节和平台有关；二是C语言中除了ADT之外还有UDT，这些用户自定义类型占几个字节无法一眼看出，所以用sizeof运算符来让编译器帮忙计算。

 (2)strlen是一个C语言库函数，这个库函数的原型是：size_t strlen(const char *s);这个函数接收一个字符串的指针，返回这个字符串的长度（以字节为单位）。注意一点是：strlen返回的字符串长度是不包含字符串结尾的'\0'的。我们为什么需要strlen库函数？因为从字符串的定义（指针指向头、固定结尾、中间依次相连）可以看出无法直接得到字符串的长度，需要用strlen函数来计算得到字符串的长度。

(3)sizeof(数组名)得到的永远是数组的元素个数（也就是数组的大小），和数组中有无初始化，初始化多、少等是没有关系的；strlen是用来计算字符串的长度的，只能传递合法的字符串进去才有意义，如果随便传递一个字符指针，但是这个字符指针并不是字符串是没有意义的。char a[5] = "windows";

​    printf("sizeof(a) = %d.\n", sizeof(a));   // 5

  printf("strlen(a) = %d.\n", strlen(a));   // 5

 

  

/*

  char a[5] = "lin";

  printf("sizeof(a) = %d.\n", sizeof(a));   // 5

  printf("strlen(a) = %d.\n", strlen(a));   // 3

*/

/*

  char a[5] = {2, 3};

  printf("sizeof(a) = %d.\n", sizeof(a));   // 5

  printf("strlen(a) = %d.\n", strlen(a));   // 2

*/ 

/*

  char a[5] = {0};

  printf("sizeof(a) = %d.\n", sizeof(a));   // 5

  printf("strlen(a) = %d.\n", strlen(a));   // 0

*/

/* 

  char a[5];

  printf("sizeof(a) = %d.\n", sizeof(a));   // 5

  printf("strlen(a) = %d.\n", strlen(a));   // 5

*/ 

 

(4)当我们定义数组时如果没有明确给出数组大小，则必须同时给出初始化式，编译器会根据初始化式去自动计算数组的大小（数组定义时必须给出大小，要么直接给，要么给初始化式）

char a[] = "windows";      // a[0] = 'w', a[1] = 'i', ````a[6] = 's', a[7] = '\0'

  printf("sizeof(a) = %d.\n", sizeof(a));   // 8

  printf("strlen(a) = %d.\n", strlen(a));   // 7

 

### 4.5.6.2、字符串初始化与sizeof、strlen

(1)char *p = "linux"; sizeof(p)得到的永远是4，因为这时候sizeof测的是字符指针p本身的长度，和字符串的长度是无关的。

(2)strlen刚好用来计算字符串的长度。

​       char *p = "linuxddd";

  printf("sizeof(p) = %d.\n", sizeof(p));   // 4

  printf("strlen(p) = %d.\n", strlen(p));   // 8

 

### 4.5.6.3、字符数组与字符串的本质差异（内存分配角度）

(1)字符数组char a[] = "linux";来说，定义了一个数组a，数组a占6字节，右值"linux"本身只存在于编译器中，编译器将它用来初始化字符数组a后丢弃掉（也就是说内存中是没有"linux"这个字符串的）；这句就相当于是：char a[] = {'l', 'i', 'n', 'u', 'x', '\0'};

(2)字符串char *p = "linux";定义了一个字符指针p，p占4字节，分配在栈上；同时还定义了一个字符串"linux"，分配在代码段；然后把代码段中的字符串（一共占6字节）的首地址（也就是'l'的地址）赋值给p。

总结对比：字符数组和字符串有本质差别。字符数组本身是数组，数组自身自带内存空间，可以用来存东西（所以数组类似于容器）；而字符串本身是指针，本身永远只占4字节，而且这4个字节还不能用来存有效数据，所以只能把有效数据存到别的地方，然后把地址存在p中。也就是说字符数组自己存那些字符；字符串一定需要额外的内存来存那些字符，字符串本身只存真正的那些字符所在的内存空间的首地址。

char b[5];

int main(void)

{

  // 字符串存在栈上

  char a[7]; 

  char *p = a;

  

  // 字符串存在数据段

  char *p = b;

  

  // 字符串存在堆空间

  char *p = (char *)malloc(5);

 }

 

 

## 4.5.7.C语言之结构体概述

### 4.5.7.1、结构体类型是一种自定义类型

(1)C语言中的2种类型：原生类型和自定义类型。

// 定义类型

struct people

{

  char name[20];

  int age;

};

 

// 定义类型的同时定义变量。

struct student

{

  char name[20];

  int age;

}s1;                相当于加了 struct student s1;

 

// 将类型struct student重命名为s1，s1是一个类型名，不是变量

typedef struct student

{

  char name[20];

  int age;

}s1;

### 4.5.7.2、结构体使用时先定义结构体类型再用类型定义变量

(1)结构体定义时需要先定义结构体类型，然后再用类型来定义变量。

(2)也可以在定义结构体类型的同时定义结构体变量。

 

### 4.5.7.3、从数组到结构体的进步之处

(1)结构体可以认为是从数组发展而来的。其实数组和结构体都算是数据结构的范畴了，数组就是最简单的数据结构、结构体比数组更复杂一些，链表、哈希表之类的比结构体又复杂一些；二叉树、图等又更复杂一些。

(2)数组有2个明显的缺陷：

第一个是定义时必须明确给出大小，且这个大小在以后不能再更改；

第二个是数组要求所有的元素的类型必须一致。更复杂的数据结构中就致力于解决数组的这两个缺陷。

(3)结构体是用来解决数组的第二个缺陷的，可以将结构体理解为一个其中元素类型可以不相同的数组。结构体完全可以取代数组，只是在数组可用的范围内数组比结构体更简单。

 

### 4.5.7.4、结构体变量中的元素如何访问？

(1)数组中元素的访问方式：表面上有2种方式（数组下标方式和指针方式）；实质上都是指针方式访问。

(2)结构体变量中的元素访问方式：只有一种，用.或者->的方式来访问。（.和->访问结构体元素其实质是一样的，只是C语言规定用结构体变量来访问元素用. 用结构体变量的指针来访问元素用->。实际上在高级语言中已经不区分了.都用.）

(3)结构体的访问方式有点类似于数组下标的方式

思考：结构体变量的点号或者->访问元素的实质是什么？其实本质上还是用指针来访问的。

struct myStruct

{

  int a;     // 4 

  double b;    // 8

  char c;

};

struct myStruct s1;

  s1.a = 12;   // int *p = (int *)&s1; *p = 12;

  s1.b = 4.4;   // double *p = (double *)((int)&s1 + 4); *p = 4.4;

  s1.c = 'a';   // char *p = (char *)((int)&s1 + 12); *p = 'a';

 

 

 

## 4.5.8.结构体的对齐访问1

### 4.5.8.1、举例说明什么是结构体对齐访问

(1)上节讲过结构体中元素的访问其实本质上还是用指针方式，结合这个元素在整个结构体中的偏移量和这个元素的类型来进行访问的。

struct s

{

  char c;     // 1 c实际占4字节，而不是1字节

  int b;     // 4

}; 

struct s s1;

  s1.c = 't';

  s1.b = 12;

  

  char *p1 = (char *)(&s1);

  printf("*p1 = %c.\n", *p1);     // t

  

 

 

 

  int *p2 = (int *)((int)&s1 + 1);    

  printf("*p2 = %d.\n", *p2);     // 201852036.

  

  int *p3 = (int *)((int)&s1 + 4);    

  printf("*p3 = %d.\n", *p3);     // 12.

 

printf("sizeof(struct s) = %d.\n", sizeof(struct s));  // 5 or 8? 结果是8

 

 

(2)但是实际上结构体的元素的偏移量比我们上节讲的还要复杂，因为结构体要考虑元素的对齐访问，所以每个元素时间占的字节数和自己本身的类型所占的字节数不一定完全一样。（譬如char c实际占字节数可能是1，也可以是2，也可能是3，也可以能4····）

(3)一般来说，我们用.的方式来访问结构体元素时，我们是不用考虑结构体的元素对齐的。因为编译器会帮我们处理这个细节。但是因为C语言本身是很底层的语言，而且做嵌入式开发经常需要从内存角度，以指针方式来处理结构体及其中的元素，因此还是需要掌握结构体对齐规则。

 

### 4.5.8.2、结构体为何要对齐访问

(1)结构体中元素对齐访问主要原因是为了配合硬件，也就是说硬件本身有物理上的限制，如果对齐排布和访问会提高效率，否则会大大降低效率。

(2)内存本身是一个物理器件（DDR内存芯片，SoC上的DDR控制器），本身有一定的局限性：如果内存每次访问时按照4字节对齐访问，那么效率是最高的；如果你不对齐访问效率要低很多。

(3)还有很多别的因素和原因，导致我们需要对齐访问。譬如Cache的一些缓存特性，还有其他硬件（譬如MMU、LCD显示器）的一些内存依赖特性，所以会要求内存对齐访问。

(4)对比对齐访问和不对齐访问：对齐访问牺牲了内存空间，换取了速度性能；而非对齐访问牺牲了访问速度性能，换取了内存空间的完全利用。

 

### 4.3.8.3、结构体对齐的规则和运算

(1)编译器本身可以设置内存对齐的规则，有以下的规则需要记住：

第一个：32位编译器，一般编译器默认对齐方式是4字节对齐。

 

总结下：结构体对齐的分析要点和关键：

1、结构体对齐要考虑：结构体整体本身必须安置在4字节对齐处，结构体对齐后的大小必须4的倍数（编译器设置为4字节对齐时，如果编译器设置为8字节对齐，则这里的4是8）

2、结构体中每个元素本身都必须对其存放，而每个元素本身都有自己的对齐规则。

3、编译器考虑结构体存放时，以满足以上2点要求的最少内存需要的排布来算。

​    示例：

struct mystruct1

{          // 1字节对齐  4字节对齐

​    int a;      // 4      4

  char b;     // 1      2(1+1)

  short c;    // 2      2

};

分析过程：

首先是整个结构体，整个结构体变量4字节对齐是由编译器保证的，我们不用操心。

 然后是第一个元素a，a的开始地址就是整个结构体的开始地址，所以自然是4字节对齐的。但是a的结束地址要由下一个元素说了算。然后是第二个元素b，因为上一个元素a本身占4字节，本身就是对齐的。所以留给b的开始地址也是 4字节对齐地址，所以b可以直接放（b放的位置就决定了a一共占4字节，因为不需要填充）。b的起始地址定了后，结束地址不能定（因为可能需要填充），结束地址要看下一个元素来定。 然后是第三个元素c，short类型需要2字节对齐（short类型元素必须放在类似0，2，4，8这样的地址处，不能放在1，3这样的奇数地址处），因此c不能紧挨着b来存放，解决方案是在b之后添加 字节的填充（padding），然后再开始放c。c放完之后还没结束 当整个结构体的所有元素都对齐存放后，还没结束，因为整个结构体大小还要是4的整数倍。

 

多个例子以便理解：  

struct mystruct1

{          // 1字节对齐  4字节对齐

  int a;     // 4      4

  char b;     // 1      2(1+1)

  short c;      // 2      2

};

 

typedef struct mystruct2

{          // 1字节对齐  4字节对齐 8字节对齐 

  char a;     // 1      4(1+3)   2（1+1） 

  int b;     // 4      4      4

  short c;      // 2      4(2+2)   2

}MyS2;

 

typedef struct mystruct2

{          // 1字节对齐  4字节对齐

  char a;     // 1      4(1+3)

  int b;     // 4      4

  short c;      // 2      4(2+2)

}MyS2;

 

 

typedef struct myStruct5

{              // 1字节对齐  4字节对齐

  int a;         // 4      4

  struct mystruct1 s1;  // 7      8

  double b;        // 8      8

  int c;         // 4      4  

}MyS5;

 

Windows 运行环境下的测试： long = 4Byte  

面对8字节对齐

\#include<stdio.h>   1（代表行数）

 

int main()         2

{             3

   \#pragma  pack(1)  4

  

  struct  s1{     5

 short  a;       6

  long  b;       7

 };           8

 

 struct  s2{      9

 char  c;        10

 struct s1  d;     11

 long  long  e;    12

 };           13

 

 \#pragma  pack()

   

  printf("sizeof(s2) = %d\n",sizeof(struct s2));

  

  

  return 0;

  

}

\#pragma  pack(1)  sizeof(struct s2)  =  15 

struct is: 

 1 

 1 1 

 1 1 1 1 

 1 1 1 1 1 1 1 1

 

\#pragma  pack(2)  sizeof(struct s2)  =  16

 struct is: 

 1 0 (0 代表补) 

 1 1 

 1 1 1 1 

 1 1 1 1 1 1 1 1

\#pragma  pack(4)  sizeof(struct s2)  =  20

1 0 0 0 

 1 1 0 0 

 1 1 1 1 

 1 1 1 1 1 1 1 1

\#pragma  pack(8)  sizeof(struct s2)  =  24

1 0 0 0 

 1 1 0 0 

 1 1 1 1 0 0 0 0 

 1 1 1 1 1 1 1 1

如果将第6行的 short  a; 放在第10行 char c；之后

\#pragma  pack(8)  sizeof(struct s2)  =  16

 

 1 0 1 1  //char c 补了一个空后和 shortb 结合 ，构成4字节。

 1 1 1 1

 1 1 1 1 1 1 1 1

这说明 结构体里的变量是不可以和结构体嵌结构体中的变量进行变量字节之间的补齐的。

而且，这个结构体的字节数一定时对其数的整倍数，你就把它当一个子结构体来算就可以。

这里有三点很重要:

 1.每个成员分别按自己的方式对齐,并能最小化长度

 2.复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式,这样在成员是复杂类型时,可以最小化长度

 3.对齐后的长度必须是成员中最大的对齐参数的整数倍,这样在处理数组时可以保证每一项都边界对齐 

Linux 环境下 除了，long =8Byte 运算法则都一样。

 

### 4.5.8.4、gcc支持但不推荐的对齐指令：#pragma pack()  #pragma pack(n) (n=1/2/4/8)

(1)#pragma是用来指挥编译器，或者说设置编译器的对齐方式的。编译器的默认对齐方式是4，但是有时候我不希望对齐方式是4，而希望是别的（譬如希望1字节对齐，也可能希望是8，甚至可能希望128字节对齐）。

(2)常用的设置编译器编译器对齐命令有2种：第一种是#pragma pack()，这种就是设置编译器默认字节对齐（有些人喜欢讲：设置编译器不对齐访问，还有些讲：取消编译器对齐访问）；第二种是#pragma pack(4)，这个括号中的数字就表示我们希望多少字节对齐。

(3)我们需要#prgama pack(n)开头，以#pragma pack()结尾，定义一个区间，这个区间内的对齐参数就是n。

(4)#prgma pack的方式在很多C环境下都是支持的，但是gcc虽然也可以不过不建议使用。

 

### 4.5.8.5、gcc支持但不推荐的对齐指令__attribute__((packed)) __attribute__((aligned(n)))

(1)__attribute__((packed))使用时直接放在要进行内存对齐的类型定义的后面，然后它起作用的范围只有加了这个东西的这一个类型。packed的作用就是取消对齐访问。

(2)__attribute__((aligned(n)))使用时直接放在要进行内存对齐的类型定义的后面，然后它起作用的范围只有加了这个东西的这一个类型。它的作用是让整个结构体变量整体进行n字节对齐（注意是结构体变量整体n字节对齐，而不是结构体内各元素也要n字节对齐）

typedef struct mystruct111

{          // 1字节对齐  4字节对齐    2字节对齐

​    int a;    // 4      4        4

  char b;     // 1      2(1+1)     2

  short c;    // 2      2        2

​    short d;  // 2      4(2+2)     2

}__attribute__((aligned(1024))) My111;

 

### 4.5.8.6、参考阅读blog：

​    http://www.cnblogs.com/dolphin0520/archive/2011/09/17/2179466.html



​    http://blog.csdn.net/sno_guo/article/details/8042332

 

## 4.5.11.offsetof宏与container_of宏

### 4.5.11.1、由结构体指针进而访问各元素的原理

(1)通过结构体整体变量来访问其中各个元素，本质上是通过指针方式来访问的，形式上是通过.的方式来访问的（这时候其实是编译器帮我们自动计算了偏移量）。

### 4.5.11.2、offsetof宏：

(1)offsetof宏的作用是：用宏来计算结构体中某个元素和结构体首地址的偏移量（其实质是通过编译器来帮我们计算）。

**#define offsetof(TYPE, MEMBER) ((int) &((TYPE \*)0)->MEMBER)**

(2)offsetof宏的原理：我们虚拟一个type类型结构体变量，然后用type.member的方式来访问那个member元素，继而得到member相对于整个变量首地址的偏移量。

(3)学习思路：第一步先学会用offsetof宏，第二步再去理解这个宏的实现原理。

**(TYPE \*)0**       这是一个强制类型转换，把0地址强制类型转换成一个指针，这个指针指向一个TYPE类型的结构体变量。    （实际上这个结构体变量可能不存在，但是只要我不去解引用这个指针就不会出错）。

**&((TYPE \*)0)->MEMBER**：分两步来解析

​    (TYPE *)0是一个TYPE类型结构体，变量的指针是骗编译器说有一个指向类（或结构）s的指针，其地址值0。细心的同学可能要发问了：你将0地址强制转换为（TYPE *）类型，0 地址什么概念，能随便转吗？ 其实大可不必担心，我们只是将0地址强制转换了一下，但是没有引用和调用，没什么关系。况且，我们只是在预处理阶段用了一下而已，不会有什么安全隐患的，放心好了。

&((TYPE *)0)->MEMBER：通过指针指针来访问这个结构体变量的member元素 &符号取member的地址，member的地址 = 0 + & member就是偏移量。 

 

### 4.5.11.3、container_of宏：

(1)作用：知道一个结构体中某个元素的指针，反推这个结构体变量的指针。有了container_of宏，我们可以从一个元素的指针得到整个结构体变量的指针，继而得到结构体中其他元素的指针。

**#define container_of(ptr, type, member) ({            \**

​    **const typeof( ((type \*)0)->member ) \*__mptr = (ptr);   \**

​    **(type \*)( (char \*)__mptr - offsetof(type,member) );})**

//这里的反斜杠的意思是不换行继续接着的意思，因为宏太长了放在一行里不好阅读       

(2)typeof关键字的作用是：typepef(a)时由变量a得到a的类型，typeof就是由变量名得到变量数据类型的。

 示例：

1、把y定义成x指向的数据类型： 

typeof(*x) y; 

2、把y定义成x指向数据类型的数组： 

typeof(*x) y[4]; 

3、把y定义成一个字符指针数组： 

typeof(typeof(char *))[4] y; 

这与下面的定义等价： 

char *y[4];

 (3)这个宏的工作原理：先用typeof得到member元素的类型定义成一个指针，然后用这个指针减去该元素相对于整个结构体变量的偏移量（偏移量用offsetof宏得到的），减去之后得到的就是整个结构体变量的首地址了，再把这个地址强制类型转换为type *即可。

分步解析：

1、这个宏比较长，分为三行，中间用 “\” 隔开，表示工鞥上连接为一行。 

2、第一行：是宏的原型，有三个输入参数：ptr type member 

3、第二行：**const typeof( ((type )0)->member ) \*__mptr = (ptr);** 这个比较有意思，定义一个临时变量：__mptr ; （通过**typeof( ((type )0)->member )**获得）与member相同的指针变量**__mptr**，然后用它来保存**ptr**的值。指出一点是，**ptr**指的就是结构体中**member**的地址，所以 **_mptr**的指针类型和**ptr**的类型是一致的。 

这行它的作用是什么呢？ 其实没什么作用（勿喷勿喷，让我把话说完），但就形式而言 _mptr = ptr,  那为什么要要定义一个一样的变量呢？？？ 其实这正是内核人员的牛逼之处：如果开发者使用时输入的参数有问题：ptr与member类型不匹配，编译时便会有warnning， 但是如果去掉改行，那个就没有了，而这个警告恰恰是必须的（防止出错有不知道错误在哪里）。。。这严谨性可以吧）

————————————————

版权声明：本文为CSDN博主「桃花_人面」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/s2603898260/article/details/79371024

4、第三行：先把这个变量转换为**（char ）**类型的指针，为什么转为char 类型呢？因为我们知道指针运算和指针指向的数据类型是有关系的。我们offsetof返回的结果是**int**型的，所以转换成**char \*** 类型说明每次指移动一个字节，这样就和整形的数据运算一一对应了。 然后减去 member在type中的偏移量，最后在强制转换为**（type \*）**类型。

  注解：为什么转为char 类型呢？

​    代码示例：

\#include<stdio.h>

 

int main()

{  

  int a =1;

  int b =2;

  int c;

  c = &a - &b;

  printf("&a = % x\n",&a);    //&a = 62fdfc

  printf("&b = % x\n",&b);    //&b = 62fdf8

  printf("&a-&b =%d\n",c);    //&a-&b =1    他们数值相差了4，但是将他们相减确实1，说明int类型地址相减 是 4 个byte 为1的

  int *pa, *pb;        

  pa = &a;

  pb = &b;

  int cp;

 

  

  printf("pa = %d\n",pa);       // pa = 6487552

  printf("(int)pb = %d\n",pb);     //(int)pb = 6487548

  

  cp = pa -(int)pb;      

  // pa-pb =-19462640 因为 pb地址被强制转换成int，所以pa -pb 相当于

//pa - pb*4 =6487552 -6487548*4 = -19462640

  printf("pa-pb =%d\n",cp);

  

  int cp1 ;          //

  cp1 = (char *)pa -(int)pb;     

   // 将pa转为，指向char类型的地址，这样就可以以1个字节来进行计算 pa -pb = 6487552 - 6487548 =4得到想要的地址偏差  ；

printf("（char）pa-pb =%d\n",cp1);

  return 0;

} 

 

程序示例：container_of(ptr,type,member) 使用示例;

\#include <stdio.h>

\#define offsetof(TYPE, MEMBER) ((int)&(((TYPE *)0)->MEMBER))

/** 

 \* container_of - cast a member of a structure out to the containing structure 

 \* @ptr:    the pointer to the member. 

 \* @type:    the type of the container struct this is embedded in. 

 \* @member:   the name of the member within the struct. 

 \* @ptr   ：  指向成员的指针。

 \* @type  ：  需要返回的结构体实例类型。

 \* @member ：  成员在结构实例内部的名称，如果为数组，需要指定下标。

 */ 

 

\#define container_of(ptr, type, member) ({            \

​    const typeof( ((type *)0)->member ) *__mptr = (ptr);   \

​    (type *)( (char *)__mptr - offsetof(type,member) );})

 

typedef struct 

{

  char a[20];

  int b;

  float c;

}mystruct_type;

 

int main(void)

{

  mystruct_type s1 = {"hello world !", 100, 12.83} ;

 

  printf("offsetof(s1,c) = %d, \n",(offsetof(mystruct_type,c)));

 

 

  printf("container_of(&s1.b, mystruct_type, b) = %p \n" ,container_of(&s1.b, mystruct_type, b));

  printf("container_of(&s1.b, mystruct_type, b) = %p \n" ,container_of(&s1.c, mystruct_type, c));

  printf("&s1 = %p \n", &s1);

 

  return 0;

}

版权声明：本文为CSDN博主「静静流淌的柯溪」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/u014421520/article/details/77857148

 

### 4.5.11.4、学习指南和要求：

(1)最基本要求是：必须要会这两个宏的使用。就是说能知道这两个宏接收什么参数，返回什么值，会用这两个宏来写代码。看见代码中别人用这两个宏能理解什么意思。

(2)升级要求：能理解这两个宏的工作原理，能表述出来。（有些面试笔试题会这么要求）

(3)更高级要求：能自己写出这两个宏（不要着急，慢慢来）

 

## 4.5.12.共用体union

### 4.5.12.1、共用体类型的定义、变量定义和使用

(1)共用体union和结构体struct在类型定义、变量定义、使用方法上很相似。

(2)共用体和结构体的不同：结构体类似于一个包裹，结构体中的成员彼此是独立存在的，分布在内存的不同单元中，他们只是被打包成一个整体叫做结构体而已；共用体中的各个成员其实是一体的，彼此不独立，他们使用同一个内存单元。可以理解为：有时候是这个元素，有时候是那个元素。更准确的说法是同一个内存空间有多种解释方式。

(3)共用体union就是对同一块内存中存储的二进制的不同的理解方式。

(4)在有些书中把union翻译成联合（联合体），这个名字不好。现在翻译成共用体比较合适。

(5)union的sizeof测到的大小实际是union中各个元素里面占用内存最大的那个元素的大小。因为可以存的下这个就一定能够存的下其他的元素。

(6)union中的元素不存在内存对齐的问题，因为union中实际只有1个内存空间，都是从同一个地址开始的（开始地址就是整个union占有的内存空间的首地址），所以不涉及内存对齐。

\#include <stdio.h>

// 共用体类型的定义

 

struct mystruct

{

​    int a;

​    char b;

};

 

// a和b其实指向同一块内存空间，只是对这块内存空间的2种不同的解析方式。

// 如果我们使用u1.a那么就按照int类型来解析这个内存空间；如果我们使用u1.b那么就按照char类型

// 来解析这块内存空间。

 

union myunion

{

  int a;

  char b;

};

int main(void)

{

// test1

  struct mystruct s1;

  s1.a = 23;

  printf("s1.b = %d.\n", s1.b);    // s1.b = 0. 结论是s1.a和s1.b是独立无关的

  printf("&s1.a = %p.\n", &s1.a);

  printf("&s1.b = %p.\n", &s1.b);

  

  union myunion u1;    // 共用体变量的定义

  u1.a = 23;       // 共用体元素的使用

  printf("u1.b = %d.\n", u1.b);    // u1.b = 23.结论是u1.a和u1.b是相关的

  // a和b的地址一样，充分说明a和b指向同一块内存，只是对这块内存的不同解析规则

  printf("&u1.a = %p.\n", &u1.a);

  printf("&u1.b = %p.\n", &u1.b);

return 0;

}

### 4.5.12.2、共用体和结构体的相同和不同

(1)相同点就是操作语法几乎相同。

(2)不同点是本质上的不同。struct是多个独立元素（内存空间）打包在一起；union是一个元素（内存空间）的多种不同解析方式。

 

### 4.5.12.3、共用体的主要用途

(1)共用体就用在那种对同一个内存单元进行多种不同规则解析的这种情况下。

union test

{

  int a;

  float b;

};

 

int main(void)

{

  union test t1;

  t1.a = 1123477881;

  printf("value = %f.\n", t1.b);

  

  int a = 1123477881;

  printf("指针方式：%f.\n", *((float *)&a));  

 

*（（float*）&a）和union实现的功能是一样的，都是用不同的类型去解析内存中的数据，C语言中其实是可以没有共用体的，用指针和强制类型转换可以替代共用体完成同样的功能，但是共用体的方式更简单、更便捷、更好理解。

 

## 4.5.13.大小端模式1

### 4.5.13.1、什么是大小端模式

(1)大端模式（big endian）和小端模式（little endian）。最早是小说中出现的词，和计算机本来没关系的。

(2)后来计算机通信发展起来后，遇到一个问题就是：在串口等串行通信中，一次只能发送1个字节。这时候我要发送一个int类型的数就遇到一个问题。int类型有4个字节，我是按照：byte0 byte1 byte2 byte3这样的顺序发送，还是按照byte3 byte2 byte1 byte0这样的顺序发送。规则就是发送方和接收方必须按照同样的字节顺序来通信，否则就会出现错误。这就叫通信系统中的大小端模式。这是大小端这个词和计算机挂钩的最早问题。

(3)现在我们讲的这个大小端模式，更多是指计算机存储系统的大小端。在计算机内存/硬盘/Nnad中。因为存储系统是32位的，但是数据仍然是按照字节为单位的。于是乎一个32位的二进制在内存中存储时有2种分布方式：

一种是将低序字节存储在起始地址，这称为小端(little-endian)字节序；·

另一种方法是将高序字节存储在起始地址，这称为大端(big-endian)字节序。                               

(4)大端模式和小端模式本身没有对错，没有优劣，理论上按照大端或小端都可以，但是要求必须存储时和读取时按照同样的大小端模式来进行，否则会出错。

(5)现实的情况就是：有些CPU公司用大端（譬如C51单片机）；有些CPU用小端（譬如ARM）。（大部分是用小端模式，大端模式的不算多）。于是乎我们写代码时，当不知道当前环境是用大端模式还是小端模式时就需要用代码来检测当前系统的大小端。

 

经典笔试题：用C语言写一个函数来测试当前机器的大小端模式。

 

### 4.5.13.2、用union来测试机器的大小端模式、指针方式来测试机器的大小端

\#include <stdio.h>

 

// 共用体中很重要的一点：a和b都是从u1的低地址开始的。

// 假设u1所在的4字节地址分别是：0、1、2、3的话，那么a自然就是0、1、2、3；

// b所在的地址是0而不是3.

union myunion

{

  int a;

  char b;

};

 

// 如果是小端模式则返回1，大端模式则返回0

int is_little_endian(void)

{

  union myunion u1;

  u1.a = 1;        // 地址0的那个字节内是1（小端）或者0（大端）

  return u1.b;

}

 

int is_little_endian2(void)

{

  int a = 1;

  char b = *((char *)(&a));    // 指针方式其实就是共用体的本质

  

  return b;

}

 

int main(void)

{

  int i = is_little_endian2();

  if (i == 1)

  {

​    printf("小端模式\n");

  }

  else

  {

​    printf("大端模式\n");

  }

  

  return 0;

}

 

## 4.5.14.大小端模式2

### 4.5.14.1、看似可行实则不行的测试大小端方式：位与、移位、强制类型转化

(1)位与运算。

结论：位与的方式无法测试机器的大小端模式。（表现就是大端机器和小端机器的&运算后的值相同的）

理论分析：位与运算是编译器提供的运算，这个运算是高于内存层次的（或者说&运算在二进制层次具有可移植性，也就是说&的时候一定是高字节&高字节，低字节&低字节，和二进制存储无关）。

(2)移位

结论：移位的方式也不能测试机器大小端。

理论分析：原因和&运算符不能测试一样，因为C语言对运算符的级别是高于二进制层次的。右移运算永远是将低字节移除，而和二进制存储时这个低字节在高位还是低位无关的。

(3)强制类型转换

 

同上

 

4.5.14.2、通信系统中的大小端（数组的大小端）

(1)譬如要通过串口发送一个0x12345678给接收方，但是因为串口本身限制，只能以字节为单位来发送，所以需要发4次；接收方分4次接收，内容分别是：0x12、0x34、0x56、0x78.接收方接收到这4个字节之后需要去重组得到0x12345678（而不是得到0x78563412）.

(2)所以在通信双方需要有一个默契，就是：先发/先接的是高位还是低位？这就是通信中的大小端问题。

(3)一般来说是：先发低字节叫小端；先发高字节就叫大端。（我不能确定）实际操作中，在通信协议里面会去定义大小端，明确告诉你先发的是低字节还是高字节。

(4)在通信协议中，大小端是非常重要的，大家使用别人定义的通信协议还是自己要去定义通信协议，一定都要注意标明通信协议中大小端的问题。

 

## 4.5.15.枚举

### 4.5.15.1、枚举是用来干嘛的？

(1)枚举在C语言中其实是一些符号常量集。直白点说：枚举定义了一些符号，这些符号的本质就是int类型的常量，每个符号和一个常量绑定。这个符号就表示一个自定义的一个识别码，编译器对枚举的认知就是符号常量所绑定的那个int类型的数字。

(2)枚举中的枚举值都是常量，怎么验证？

(3)枚举符号常量和其对应的常量数字相对来说，数字不重要，符号才重要。符号对应的数字只要彼此不相同即可，没有别的要求。所以一般情况下我们都不明确指定这个符号所对应的数字，而让编译器自动分配。（编译器自动分配的原则是：从0开始依次增加。如果用户自己定义了一个值，则从那个值开始往后依次增加）

4.5.15.2、C语言为何需要枚举

(1)C语言没有枚举是可以的。使用枚举其实就是对1、0这些数字进行符号化编码，这样的好处就是编程时可以不用看数字而直接看符号。符号的意义是显然的，一眼可以看出。而数字所代表的含义除非看文档或者注释。

(2)宏定义的目的和意义是：不用数字而用符号。从这里可以看出：宏定义和枚举有内在联系。宏定义和枚举经常用来解决类似的问题，他们俩基本相当可以互换，但是有一些细微差别。

### 4.5.15.3、宏定义和枚举的区别

(1)枚举是将多个有关联的符号封装在一个枚举中，而宏定义是完全散的。也就是说枚举其实是多选一。

(2)什么情况下用枚举？当我们要定义的常量是一个有限集合时（譬如一星期有7天，譬如一个月有31天，譬如一年有12个月····），最适合用枚举。（其实宏定义也行，但是枚举更好）

\#include <stdio.h> 

 

// 宏定义来解决返回值问题

\#define FALSE 0

\#define TRUE 1

 

// 这个枚举用来表示函数返回值，ERROR表示错，RIGHT表示对

enum return_value

{

  ERROR,       // 枚举值常量是全局的，直接自己就可以用。

  RIGHT,

};

 

enum return_value func1(void);

 

int main(void)

{

  enum return_value r = func1();

 

  if (r == RIGHT)     // 不是r.RIGHT，也不是return_value.RIGHT

  {

​    printf("函数执行正确\n");

  }

  else

  {

​    printf("函数执行错误\n");

  }

  

  printf("ERROR = %d.\n", ERROR);

  printf("RIGHT = %d.\n", RIGHT);

  

  

  return 0;

}




enum return_value func1(void)

{

  enum return_value r1;

  r1 = ERROR;

  return r1;

}

 

// 返回1表示执行成功，返回0表示执行失败

int func2(void)

{

  return 1;

}

 

int func3(void)

{

  return FALSE;

}

 

 (3)不能用枚举的情况下（定义的常量符号之间无关联，或者无限的）用宏定义。

总结：宏定义先出现，用来解决符号常量的问题；后来人们发现有时候定义的符号常量彼此之间有关联（多选一的关系），用宏定义来做虽然可以但是不贴切，于是乎发明了枚举来解决这种情况。

 

### 4.5.15.3、枚举的定义和使用

\#include "stdio.h"

 

/*

****************************************************************

 \* enumeration 类型定义

****************************************************************

 */ 

/*   // 定义方法1，定义类型和定义变量分离开

enum week

{

  SUN,    // SUN = 0

  MON,    // MON = 1;

  TUE,

  WEN,

  THU,

  FRI,

  SAT,

};

 

enum week today;

*/

 

/*   // 定义方法2,定义类型的同时定义变量

enum week

{

  SUN,    // SUN = 0

  MON,    // MON = 1;

  TUE,

  WEN,

  THU,

  FRI,

  SAT,

}today,yesterday;

*/

 

/*   // 定义方法3,定义类型的同时定义变量

enum 

{

  SUN,    // SUN = 0

  MON,    // MON = 1;

  TUE,

  WEN,

  THU,

  FRI,

  SAT,

}today,yesterday;

*/

 

/*   // 定义方法4,用typedef定义枚举类型别名，并在后面使用别名进行变量定义

typedef enum week

{

  SUN,    // SUN = 0

  MON,    // MON = 1;

  TUE,

  WEN,

  THU,

  FRI,

SAT,

 

 

}week;

*/

 

/*   // 定义方法5,用typedef定义枚举类型别名，并在后面使用别名进行变量定义

typedef enum 

{

  SUN,    // SUN = 0

  MON,    // MON = 1;

  TUE,

  WEN,

  THU,

  FRI,

  SAT,

}week;

*/

 

/*

******************************************************************

 \* 错误类型举例

 */

 

/* // 错误1，枚举类型重名，编译时报错：error: conflicting types for ‘DAY’

typedef enum workday

{

  MON,    // MON = 1;

  TUE,

  WEN,

  THU,

  FRI,

}DAY;

 

typedef enum weekend

{

  SAT,

  SUN,

}DAY;

*/

 

/* // 错误2，枚举成员重名，编译时报错：redeclaration of enumerator ‘MON’

typedef enum workday

{

  MON,    // MON = 1;

  TUE,

  WEN,

  THU,

  FRI,

}workday;

 

typedef enum weekend

{

  MON,

  SAT,

  SUN,

}weekend;

// 结构体中元素可以重名

typedef struct 

{

  int a;

  char b;

}st1;

 

typedef struct 

{

  int a;

  char b;

}st2;

*/

 

/*   // #define宏可以重复定义(没有error但是有warning)，结果以最后一次定义为准。

\#define MACRO1 12

\#define MACRO1 24

*/

 

/*

 *

 \* 测试代码

 */

 

int main(int argc, char **argv)

{

  printf("%d\n", MACRO1);

 

/*     // 测试定义方法4,5

  week today;

  today = WEN;

  printf("today is the %dth day in week\n", today);

*/

 

/*   // 测试定义方法2

  today = WEN;

  printf("today is the %dth day in week\n", today);

*/

 

/*   // 测试enum变量的类型

  enum week w1;

  w1 = TUE;

  printf("%d\n", w1);

*/ 

} 

 

 

 

/*

 *测试结论记录

*******************************************************************

1、编译以下代码

​    enum week w1;      

​    w1 = TUE;       

​    printf("%s\n", w1);     

出现警告，enum.c:28: warning: format ‘%s’ expects type ‘char *’, but argument 2 has type ‘unsigned int’ 

分析：典型的格式化输出和类型不匹配，从警告信息可以看出enum变量的类型为unsigned int

​    既然是unsigned int，那自然使用%d打印是正确的了。

 

2、不能有重名的枚举类型。即在一个文件中不能有两个或两个以上的enum被typedef成相同的别名。

分析：这很好理解，因为将两种不同类型重命名为相同的别名，这会让gcc在还原别名时遇到困惑。比如你定义了

typedef int INT;   typedef char INT; 那么INT到底被译为int还是char呢？

3、不能有重名的枚举成员。

分析：经过测试，两个struct类型内的成员名称可以重名，而两个enum类型中的成员不可以重名。实际上从两者的成员

在访问方式上的不同就可以看出了。struct类型成员的访问方式是：变量名.成员，而enum成员的访问方式为：成员名。

因此若两个enum类型中有重名的成员，那代码中访问这个成员时到底指的是哪个enum中的成员呢？

两个#define宏定义是可以重名的，该宏名真正的值取决于最后一次定义的值。编译器会给出警告但不会error

 

********************************************************************

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

# 第六章、语言宏定义与预处理、函数和函数库

## 4.6.0 .章节概要

**4.6.1.C语言预处理理论**

​    本节向大家引入C语言预处理，讲解预处理进行的时间段和意义，引入常见的几种预处理技术及其相关的关键字，最后介绍gcc中用于预处理的编译选项。

**4.6.2.C语言预处理代码实战**

​    本节向大家演示几种常见的预处理，通过代码实例让大家明白这几种预处理技巧的使用方法和使用环境，目的是使大家真正学会使用这些预处理技巧。

**4.6.3.宏定义1**

​    本节首先讲解宏定义的一般规则和使用方法，然后用两个宏定义向大家演示宏定义中的关键点和易错点，这两个宏定义都是面试题中非常常见的典型题目。

**4.6.4.宏定义2**

​    本节深入对比带参宏、带参函数的相同相异点，并且借此引入内联函数，让大家明白这三者之间的联系，知道在什么情况下编程应该选择哪种技术来达到最好的效果。

**4.6.5.函数的本质**

​    本节首先引入函数，讲解函数出现的原因，函数书写的一般规则，同时扩展了函数在面向对象领域出现的形式（方法），最后向大家揭示了函数的本质：数据处理器。

**4.6.6.函数的基本使用**

​    本节主讲函数三要素：函数定义、函数声明和函数调用。通过三要素让大家进一步掌握函数的基本功能原则和方法。

**4.6.7.递归函数**

​    本节讲述函数中的一类特殊分支：递归函数。通过求阶乘的示例让大家理解递归函数的“递归”二字的真实含义，并且总结了递归函数的要点。

**4.6.8.函数库**

​    本节引入函数库，告诉大家函数库的来源和意义，以及常规的使用方法。

**4.6.9.字符串函数**

​    本节讲述函数库中一类特殊函数：字符串函数，这个是编程中经常需要用到的一类函数。

**4.6.10.数学库函数**

​    本节讲述函数库中另一个分支：数学库函数。通过数学库函数的使用示例引入了-lm这种链接参数，为后面讲述动态和静态链接库打下了基础。

**4.6.11.自己制作静态链接库并使用**

​    本节演示自己制作静态链接库，并且使用自己写的静态链接库。

**4.6.12.自己制作动态链接库并使用**

​    本节演示自己编写编译动态链接库，并且使用自己编写的动态链接库，通过本节希望大家能够掌握库的使用（编译时、连接时和运行时下的不同要求）。

## 4.6.1.C语言预处理理论

### 4.6.1.1、由源码到可执行程序的过程

(1)源码.c->(编译)->elf可执行程序（最粗略的）

(2)源码.c->(编译)->目标文件.o->(链接)->elf可执行程序

(3)源码.c->(编译)->汇编文件.S->(汇编)->目标文件.o->(链接)->elf可执行程序

(4)源码.c->(预处理)->预处理过的.i源文件（其实本质还是个,.c文件，只不过用.i来与其区分）->(编译)->汇编文件.S->(汇编)->目标文件.o->(链接)->elf可执行程序（这才是完整的）

 

预处理用预处理器，编译用编译器，汇编用汇编器，链接用链接器，这几个工具再加上其他一些额外的会用到的可用工具，合起来叫编译工具链。gcc就是一个编译工具链。

 

 

### 4.6.1.2、预处理的意义

(1)编译器本身的主要目的是编译源代码，将C的源代码转化成.S的汇编代码。编译器聚焦核心功能后，就剥离出了一些非核心的功能到预处理器去了。

(2)预处理器帮编译器做一些编译前的杂事。

 

### 4.6.1.3、编程中常见的预处理

(1)#include（#include <>和#include ""的区别）

(2)注释

(3)#if #elif #endif     #ifdef

(4)宏定义

 

4.6.1.4、gcc中只预处理不编译的方法

(1)gcc编译时可以给一些参数来做一些设置，譬如gcc xx.c -o xx可以指定可执行程序的名称；譬如gcc xx.c -c -o xx.o可以指定只编译不连接，也可以生成.o的目标文件。

(2)gcc -E xx.c -o xx.i可以实现只预处理不编译。一般情况下没必要只预处理不编译，但有时候这种技巧可以用来帮助我们研究预处理过程，帮助debug程序。

 

\#define pchar char *

typedef char * PCHAR

 

int main(void)

{

  pchar p3;

  pchar p1, p2;

  

  return 0;

}

预处理后的c文件  .i

\# 1 "4.6.1.preprocess.c"

\# 1 "<built-in>"

\# 1 "<command-line>"

\# 31 "<command-line>"

\# 1 "/usr/include/stdc-predef.h" 1 3 4

\# 32 "<command-line>" 2

\# 1 "4.6.1.preprocess.c"




typedef char * PCHAR

 

int main(void)

{

 char * p3;

 char * p1, p2;

 return 0;

}

 

总结：宏定义被预处理时的现象有：第一，宏定义语句本身不见了（可见编译器根本就不认识#define，编译器根本不知道还有个宏定义）；第二，typedef重命名语言还在，说明它和宏定义是有本质区别的（说明typedef是由编译器来处理而不是预处理器处理的）；

 

## 4.6.2.C语言预处理代码实战

### 4.6.2.1、头文件包含

(1)#include <> 和 #include""的区别：<>专门用来包含系统提供的头文件（就是系统自带的，不是程序员自己写的），""用来包含自己写的头文件；

更深层次来说：<>的话C语言编译器只会到系统指定目录(编译器中配置的或者操作系统配置的寻找目录，譬如在ubuntu中是/usr/include目录，编译器还允许用-I来附加指定其他的包含路径)去寻找这个头文件（隐含意思就是不会找当前目录下），如果找不到就会提示这个头文件不存在。

(2)""包含的头文件，编译器默认会先在当前目录下寻找相应的头文件，如果没找到然后再到系统指定目录去寻找，如果还没找到则提示文件不存在。

总结+注意：规则虽然允许用双引号来包含系统指定目录，但是一般的使用原则是：如果是系统指定的自带的用<>，如果是自己写的在当前目录下放着用""，如果是自己写的但是集中放在了一起专门存放头文件的目录下将来在编译器中用-I参数来寻找，这种情况下用<>。

(3)头文件包含的真实含义就是：在#include<xx.h>的那一行，将xx.h这个头文件的内容原地展开替换这一行#include语句。过程在预处理中进行。

 

### 4.6.2.2、注释

(1)注释是给人看的，不是给编译器看的。

(2)编译器既然不看注释，那么编译时最好没有注释的。实际上在预处理阶段，预处理器会拿掉程序中所有的注释语句，到了编译器编译阶段程序中其实已经没有注释了。

 

### 4.6.2.3、条件编译

(1)有时候我们希望程序有多种配置，我们在源代码编写时写好了各种配置的代码，然后给个配置开关，在源代码级别去修改配置开关来让程序编译出不同的效果。

(2)条件编译中用的两种条件判定方法分别是#ifdef 和 #if区别：

\#ifdef XXX判定条件成立与否时主要是看XXX这个符号在本语句之前有没有被定义，只要定义了（我们可以直接#define XXX或者#define XXX 12或者#define XXX YYY）这个符号就是成立的。

\#if (条件表达式)，它的判定标准是()中的表达式是否为true还是flase，跟C中的if语句有点像。

 

\#include "test.h"

\#include "stdio.h"

 

\#define NUM 1

 

// 注释1

int main(void)

{

  int a = 0;

  \#if (NUM == 0)   // 如果前面有定义NUM这个符号，成立

  a = 111;

  printf("#ifdef NUM.\n");

  \#else      // 如果前面没有定义NUM这个符号，则执行下面的语句

  a = 222;

  printf("#elif.\n");

  \#endif

 

 

## 4.6.3.宏定义1

## 4.6.3.1、宏定义的规则和使用解析

(1)宏定义的解析规则就是：在预处理阶段由预处理器进行替换，这个替换是原封不动的替换。

(2)宏定义替换会递归进行，直到替换出来的值本身不再是一个宏为止。

(3)一个正确的宏定义式子本身分为3部分：第一部分是#dedine ，第二部分是宏名 ，剩下的所有为第三部分。

(4)宏可以带参数，称为带参宏。带参宏的使用和带参函数非常像，但是使用上有一些差异。在定义带参宏时，每一个参数在宏体中引用时都必须加括号，最后整体再加括号，括号缺一不可。

 

### 4.6.3.2、宏定义示例1：MAX宏，求2个数中较大的一个

\#define MAX(a, b) (((a)>(b)) ? (a) : (b))

关键：

​    第一点：要想到使用三目运算符来完成。

​    第二点：注意括号的使用

 

### 4.6.3.3、宏定义示例2：SEC_PER_YEAR，用宏定义表示一年中有多少秒

\#define SEC_PER_YEAR (365*24*60*60UL)

关键：

​    第一点:当一个数字直接出现在程序中时，它的是类型默认是int

​    第二点：一年有多少秒，这个数字刚好超过了int类型存储的范围

 

 

## 4.6.4.宏定义2

### 4.6.4.1、带参宏和带参函数的区别（宏定义的缺陷）

(1)宏定义是在预处理期间处理的，而函数是在编译期间处理的。这个区别带来的实质差异是：宏定义最终是在调用宏的地方把宏体原地展开，而函数是在调用函数处跳转到函数中去执行，执行完后再跳转回来。

注：宏定义和函数的最大差别就是：宏定义是原地展开，因此没有调用开销；而函数是跳转执行再返回，因此函数有比较大的调用开销。所以宏定义和函数相比，优势就是没有调用开销，没有传参开销，所以当函数体很短（尤其是只有一句话时）可以用宏定义来替代，这样效率高。

(2)带参宏和带参函数的一个重要差别就是：宏定义不会检查参数的类型，返回值也不会附带类型；而函数有明确的参数类型和返回值类型。当我们调用函数时编译器会帮我们做参数的静态类型检查，如果编译器发现我们实际传参和参数声明不同时会报警告或错误。

注：用函数的时候程序员不太用操心类型不匹配因为编译器会检查，如果不匹配编译器会叫；用宏的时候程序员必须很注意实际传参和宏所希望的参数类型一致，否则可能编译不报错但是运行有误。

总结：宏和函数各有千秋，各有优劣。总的来说，如果代码比较多用函数适合而且不影响效率；但是对于那些只有一两句话的函数开销就太大了，适合用带参宏。但是用带参宏又有缺点：不检查参数类型。

 

### 4.6.4.2、内联函数和inline关键字

(1)内联函数通过在函数定义前加inline关键字实现。

(2)内联函数本质上是函数，所以有函数的优点（内联函数是编译器负责处理的，编译器可以帮我们做参数的静态类型检查）；但是他同时也有带参宏的优点（不用调用开销，而是原地展开）。所以几乎可以这样认为：内联函数就是带了参数静态类型检查的宏。

(3)当我们的函数内函数体很短（譬如只有一两句话）的时候，我们又希望利用编译器的参数类型检查来排错，我还希望没有调用开销时，最适合使用内联函数。

 

### 4.6.4.3、宏定义来实现条件编译（#define #undef #ifdef）

  

(1)程序有DEBUG版本和RELEASE版本，区别就是编译时有无定义DEBUG宏。

\#define DEBUG

\#ifdef DEBUG

\#define debug(x)    printf(x)

\#else

\#define debug(x)

\#endif 

 

\#undef DEBUG // 如果前面有定义DEBUG宏，则取消这个宏，如果没有则取消这个宏。

 

## 4.6.5.函数的本质

### 4.6.5.1、C语言为什么会有函数

(1)整个程序分成多个源文件，一个文件分成多个函数，一个函数分成多个语句，这就是整个程序的组织形式。这样组织的好处在于：分化问题、便于编写程序、便于分工。

(2)函数的出现是人（程序员和架构师）的需要，而不是机器（编译器、CPU）的需要。

(3)函数的目的就是实现模块化编程。说白了就是为了提供程序的可移植性。

 

### 4.6.5.2、函数书写的一般原则：

第一：遵循一定格式。函数的返回类型、函数名、参数列表等。

第二：一个函数只做一件事：函数不能太长也不宜太短，原则是一个函数只做一件事情。

第三：传参不宜过多：在ARM体系下，传参不宜超过4个。如果传参确实需要多则考虑结构体打包。

第四：尽量少碰全局变量：函数最好用传参返回值来和外部交换数据，不要用全局变量。

 

### 4.6.5.3、函数是动词、变量是名词（面相对象中分别叫方法和成员变量）

(1)函数将来被编译成可执行代码段，变量（主要指全局变量）经过编译后变成数据或者在运行时变成数据。一个程序的运行需要代码和数据两方向的结合才能完成。

(2)代码和数据需要彼此配合，代码是为了加工数据，数据必须借助代码来起作用。拿现实中的工厂来比喻：数据是原材料，代码是加工流水线。名词性的数据必须经过动词性的加工才能变成最终我们需要的产出的数据。这个加工的过程就是程序的执行过程。

 

### 4.6.5.4、函数的实质是：数据处理器

(1)程序的主体是数据，也就是说程序运行的主要目标是生成目标数据，我们写代码也是为了目标数据。我们如何得到目标数据？必须2个因素：原材料+加工算法。原材料就是程序的输入数据，加工算法就是程序。

(2)程序的编写和运行就是为了把原数据加工成目标数据，所以程序的实质就是一个数据处理器。

(3)函数就是程序的一个缩影，函数的参数列表其实就是为了给函数输入原材料数据，函数的返回值和输出型参数就是为了向外部输出目标数据，函数的函数体里的那些代码就是加工算法。

(4)函数在静止没有执行（乖乖的躺在硬盘里）的时候就好象一台没有开动的机器，此时只占一些存储空间但是并不占用资源（CPU+内存）；函数的每一次运行就好象机器的每一次开机运行，运行时需要耗费资源（CPU+内存），运行时可以对数据加工生成目标数据；函数运行完毕会释放占用的资源。

(5)整个程序的运行其实就是很多个函数相继运行的连续过程。

 

 

## 4.6.6.函数的基本使用

### 4.6.6.1、函数三要素：定义、声明、调用

(1)函数的定义就是函数体、函数声明是函数原型、函数调用就是使用函数

(2)函数定义是函数的根本，函数定义中的函数名表示了这个函数在内存中的首地址，所以可以用函数名来调用执行这个函数（实质是指针解引用访问）；函数定义中的函数体是函数的执行关键，函数将来执行时主要就是执行函数体。所以一个函数没有定义就是无基之塔。

(3)函数声明的主要作用是告诉编译器函数的原型。

(4)函数调用就是调用执行一个函数。

 

### 4.6.6.2、函数原型和作用

(1)函数原型就是函数的声明，说白了就是函数的函数名、返回值类型、参数列表。

(2)函数原型的主要作用就是给编译器提供原型，让编译器在编译程序时帮我们进行参数的静态类型检查。

(3)必须明白：编译器在编译程序时是以单个源文件为单位的（所以一定要在哪里调用在哪里声明），而且编译器工作时已经经过预处理处理了，最最重要的是编译器编译文件时是按照文件中语句的先后顺序执行的。

(4)编译器从源文件的第一行开始编译，遇到函数声明时就会收到编译器的函数声明表中，然后继续向后。当遇到一个函数调用时，就在我的本文件的函数声明表中去查这个函数，看有没有原型相对应的一个函数（这个相对应的函数有且只能有一个）。如果没有或者只有部分匹配则会报错或报警告；如果发现多个则会报错或报警告（函数重复了，C语言中不允许2个函数原型完全一样，这个过程其实是在编译器遇到函数定义时完成的。所以函数可以重复声明但是不能重复定义）。

 

### 4.6.6.3、函数传参

 

 

## 4.6.7.递归函数

### 4.6.7.1、什么是递归函数

(1)递归函数就是函数中调用了自己本身这个函数的函数。

(2)递归函数和循环的区别。递归不等于循环。

(3)递归函数解决问题的典型就是：求阶乘、求斐波那契数列。

（4）对递归函数的理解

 

\#include<stdio.h>

 

void digui(int n);

 

int main(void)

{

  digui(3);

 

  //int a = 5;

  //printf("%d的阶乘是：%d.\n", a, jiecheng(a));

 

  return 0;

}

 

void digui(int n)

{

  int a[100];

  printf("递归前：n = %d.\n", n);

  if (n > 1)

  {

​    digui(n-1);

  }

  else

  {

​    printf("结束递归，n = %d.\n", n);

  }

  printf("递归后：n = %d.\n", n);

}

​    输出：递归前：n = 3.

递归前：n = 2.

递归前：n = 1.

结束递归，n = 1.

递归后：n = 1.

递归后：n = 2.

递归后：n = 3.

### 4.6.7.2、函数的递归调用原理

(1)实际上递归函数是在栈内存上递归执行的，每次递归执行一次就需要耗费一些栈内存。

(2)栈内存的大小是限制递归深度的重要因素。

 

### 4.6.7.3、使用递归函数的原则：收敛性、栈溢出

(1)收敛性就是说：递归函数必须有一个终止递归的条件。当每次这个函数被执行时，我们判断一个条件决定是否继续递归，这个条件最终必须能够被满足。如果没有递归终止条件或者这个条件永远不能被满足，则这个递归没有收敛性，这个递归最终要失败。

(2)因为递归是占用栈内存的，每次递归调用都会消耗一些栈内存。因此必须在栈内存耗尽之前递归收敛（终止），否则就会栈溢出。

(3)递归函数的使用是有一定风险的，必须把握好。

 

## 4.6.8.函数库

### 4.6.8.1、什么是函数库？

(1)函数库就是一些事先写好的函数的集合，给别人复用。

(2)函数是模块化的，因此可以被复用。我们写好了一个函数，可以被反复使用。也可以A写好了一个函数然后共享出来，当B有相同的需求时就不需自己写直接用A写好的这个函数即可。

 

### 4.6.8.2、函数库的由来

(1)最开始是没有函数库，每个人写程序都要从零开始自己写。时间长了慢慢的早期的程序员就积累下来了一些有用的函数。

(2)早期的程序员经常参加行业聚会，在聚会上大家互相交换各自的函数库。

(3)后来程序员中的一些大神就提出把大家各自的函数库收拢在一起，然后经过校准和整理，最后形成了一份标准化的函数库，就是现在的标准的函数库，譬如说glibc。

 

### 4.6.8.3、函数库的提供形式：动态链接库与静态链接库

(1)早期的函数共享都是以源代码的形式进行的。这种方式共享是最彻底的（后来这种源码共享的方向就形成了我们现在的开源社区）。但是这种方式有它的缺点，缺点就是无法以商业化形式来发布函数库。

(2)商业公司需要将自己的有用的函数库共享给被人（当然是付费的），但是又不能给客户源代码。这时候的解决方案就是以库（主要有2种：静态库和动态库）的形式来提供。

(3)比较早出现的是静态链接库。静态库其实就是商业公司将自己的函数库源代码经过只编译不连接形成.o的目标文件，然后用ar工具将.o文件归档成.a的归档文件（.a的归档文件又叫静态链接库文件）。商业公司通过发布.a库文件和.h头文件来提供静态库给客户使用；客户拿到.a和.h文件后，通过.h头文件得知库中的库函数的原型，然后在自己的.c文件中直接调用这些库文件，在连接的时候链接器会去.a文件中拿出被调用的那个函数的编译后的.o二进制代码段链接进去形成最终的可执行程序。

(4)动态链接库比静态链接库出现的晚一些，效率更高一些，是改进型的。现在我们一般都是使用动态库。静态库在用户链接自己的可执行程序时就已经把调用的库中的函数的代码段链接进最终可执行程序中了，这样好处是可以执行，坏处是太占地方了。尤其是有多个应用程序都使用了这个库函数时，实际上在多个应用程序最后生成的可执行程序中都各自有一份这个库函数的代码段。当这些应用程序同时在内存中运行时，实际上在内存中有多个这个库函数的代码段，这完全重复了。而动态链接库本身不将库函数的代码段链接入可执行程序，只是做个标记。然后当应用程序在内存中执行时，运行时环境发现它调用了一个动态库中的

 

 

库函数时，会去加载这个动态库到内存中，然后以后不管有多少个应用程序去调用这个库中的函数都会跳转到第一次加载的地方去执行（不会重复加载）。

 

### 4.6.8.4、函数库中库函数的使用

(1)gcc中编译链接程序默认是使用动态库的，要想静态链接需要显式用-static来强制静态链接。

(2)库函数的使用需要注意3点：

第一，包含相应的头文件；

第二，调用库函数时注意函数原型； 

第三，有些库函数链接时需要额外用-lxxx来指定链接；

第四，如果是动态库，要注意-L指定动态库的地址。

 

## 4.6.9.字符串函数（重点）

### 4.6.9.1、什么是字符串

(1)字符串就是由多个字符在内存中连续分布组成的字符结构。字符串的特点是指定了开头（字符串的指针）和结尾（结尾固定为字符'\0'），而没有指定长度（长度由开头地址和结尾地址相减得到）。

 

### 4.6.9.2、为什么要讲字符串处理函数

(1)函数库为什么要包含字符串处理函数？因为字符串处理的需求是客观的，所以从很早开始人们就在写很多关于字符串处理的函数，然后逐渐形成了现在的字符串处理函数库。

(2)**面试笔试时，常用字符串处理函数也是经常考到的点。**

 

### 4.6.9.3、常用字符串处理函数

(1)C库中字符串处理函数包含在string.h中，这个文件在ubuntu系统中在/usr/include中

(2)常见字符串处理函数及作用：

​    memcpy    确定src和dst不会overlap，则使用memcpy效率高

​    memmove      确定会overlap或者不确定但是有可能overlap，则使用memove比较保险

​    memset

 

​    memcmp

​    memchr

​    strcpy

​    strncpy

​    strcat

​    strncat

​    strcmp

​    strncmp

​    strdup

​    strndup

​    strchr

​    strstr

​    strtok

​    ·······

​    

 

## 4.6.10.数学库函数

### 4.6.10.1、math.h

(1)真正的数学运算的函数定义在：/usr/include/i386-linux-gnu/bits/mathcalls.h

(2)使用数学库函数的时候，只需要包含math.h即可。

### 4.6.10.2、计算开平方

(1)库函数： double sqrt(double x);

 

 

注意区分编译时警告/错误，和链接时的错误：

编译时警告/错误：

### 4.6.10.math.c:9:13: warning: incompatible implicit declaration of built-in function ‘sqrt’ [enabled by default]

 double b = sqrt(a);

链接时错误：

### 4.6.10.math.c:(.text+0x1b): undefined reference to `sqrt'

collect2: error: ld returned 1 exit status

 

分析；这个链接错误的意思是：sqrt函数有声明（声明就在math.h中）有引用（在math.c）但是没有定义，链接器找不到函数体。sqrt本来是库函数，在编译器库中是有.a和.so链接库的（函数体在链接库中的）。

C链接器的工作特点：因为库函数有很多，链接器去库函数目录搜索的时间比较久。为了提升速度想了一个折中的方案：链接器只是默认的寻找几个最常用的库，如果是一些不常用的库中的函数被调用，需要程序员在链接时明确给出要扩展查找的库的名字。链接时可以用-lxxx来指示链接器去到libxxx.so中去查找这个函数。

 

### 4.6.10.3、链接时加-lm

(1)-lm就是告诉链接器到libm中去查找用到的函数。

(2)实战中发现在高版本的gcc中，经常会出现没加-lm也可以编译链接的。

(3)ldd 命令  ldd + 可知执行文件，可以查看程序中使用了哪些库函数。

 

## 4.6.11.自己制作静态链接库并使用

all: 

​    gcc aston.c -o aston.o -c 

​    ar -rc libaston.a aston.o

(1)第一步：自己制作静态链接库

​    首先使用gcc -c只编译不连接，生成.o文件；然后使用ar工具进行打包成.a归档文件

​    库名不能随便乱起，一般是lib+库名称，后缀名是.a表示是一个归档文件

注意：制作出来了静态库之后，发布时需要发布.a文件和.h文件。

 

(2)第二步：使用静态链接库

​    把.a和.h都放在我引用的文件夹下，然后在.c文件中包含库的.h，然后直接使用库函数。

第一次，编译方法：gcc test.c -o test

报错信息：test.c:(.text+0xa): undefined reference to `func1'

test.c:(.text+0x1e): undefined reference to `func2'

第二次，编译方法：gcc test.c -o test -laston

报错信息：/usr/bin/ld: cannot find -laston

collect2: error: ld returned 1 exit status

第三次，编译方法：gcc test.c -o test -laston -L.

无报错，生成test，执行正确。（-L. 表示当前路径）。

(3)除了ar名另外，还有个nm命令也很有用，它可以用来查看一个.a文件中都有哪些符号

 例如：nm libaston.a

 

### 4.6.12.自己制作动态链接库并使用

(1)动态链接库的后缀名是.so（对应windows系统中的dll），静态库的扩展名是.a

(2)第一步：创建一个动态链接库。

​    gcc aston.c -o aston.o -c -fPIC

​    gcc -o libaston.so aston.o -shared 

​       -fPIC是位置无关码（position independent code），-shared是按照共享库的方式来链接。

注意：做库的人给用库的人发布库时，发布libxxx.so和xxx.h即可。

(3)第二步：使用自己创建的共享库。

第一步，编译方法：gcc test.c -o test

报错信息：test.c:(.text+0xa): undefined reference to `func1'

test.c:(.text+0x1e): undefined reference to `func2'

collect2: error: ld returned 1 exit status

 

第二步，编译方法：gcc test.c -o test -laston

报错信息：/usr/bin/ld: cannot find -laston

collect2: error: ld returned 1 exit status

 

第三步，编译方法：gcc test.c -o test -laston -L.

编译成功

 

但是运行出错，报错信息：

error while loading shared libraries: libaston.so: cannot open shared object file: No such file or directory

 

错误原因：动态链接库运行时需要被加载（运行时环境在执行test程序的时候发现他动态链接了libaston.so，于是乎会去固定目录尝试加载libaston.so，如果加载失败则会打印以上错误信息。）

 

**解决方法一：**

将libaston.so放到固定目录下就可以了，这个固定目录一般是/usr/lib目录。

cp libaston.so /usr/lib即可

 

**解决方法二：**

使用环境变量LD_LIBRARY_PATH。操作系统在加载固定目录/usr/lib之前，会先去LD_LIBRARY_PATH这个环境变量所指定的目录下去寻找，如果找到就不用去/usr/lib下面找了，如果没找到再去/usr/lib下面找。所以解决方案就是将libaston.so所在的目录导出到环境变量LD_LIBRARY_PATH中即可。

export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/mnt/hgfs/Winshare/s5pv210/AdvancedC/4.6.PreprocessFunction/4.6.12.sharedobject.c/sotest

**注意：=于前后不能用空格**

 

**在ubuntu中还有个解决方案三**，用ldconfig

 

 

(4)**ldd****命令：**作用是可以在一个使用了共享库的程序执行之前解析出这个程序使用了哪些共享库，并且查看这些共享库是否能被找到，能被解析（决定这个程序是否能正确执行）。

​    比如 ldd test  就可以查看引用了哪些库

 

 

 

 

 

 

 

 

 



 

# 第七章 存储类&作用域&生命周期&链接属性

## 4.7.0.章节概要

**4.7.1.概念解析**

​    本节详细介绍了存储类、作用域、生命周期、链接属性这几个概念。

**4.7.2.linux下C程序的内存映像**

​    本节讲述linux下C语言程序的内存映像，进一步提出代码段、数据段、bss段、栈、堆的概念，方便后面内容的讲述

**4.7.3、存储类相关的关键字1**

​    本节讲述存储类关键字auto、static、register，其中重点是static。

**4.7.4.存储类相关的关键字2**

​    本节讲述存储类关键字extern、volatile、restrict、typedef，其中重点是extern和volatile。

**4.7.5.作用域详解**

​    本节详细讲述作用域，分析了各种不同属性的变量的作用域规则。

**4.7.6.变量的生命周期**

​    本节重点分析变量的生命周期，从该角度并联系前面的概念对各种变量进行了分析。

**4.7.7.链接属性**

​    本节详细讲解C语言的三种链接属性：外连接、内链接、无连接，重点解释了static的第二种用法。

**4.7.8.最后的总结**

​    本节对前面7节讲述的内容进行了综合和总结，通过总结希望大家彻底联系上面几节的分知识点，能从整体上认识C语言的工作规则。

## 4.7.1.概念解析

### 4.7.1.1、存储类

(1)存储类就是存储类型，也就是描述C语言变量在何种地方存储。

(2)内存有多种管理方法：栈、堆、数据段、bss段、.text段······一个变量的存储类属性就是描述这个变量存储在何种内存段中。

(3)譬如：局部变量分配在栈上，所以它的存储类就是栈；显式初始化为非0的全局变量分配在数据段，显式初始化为0和没有显示初始化（默认为0）的全局变量分配在bss段。

 

### 4.7.1.2、作用域

\#include<stdio.h>

Int var = 10;

Int main(){

  int i;

  for (i=0; i<10; i++)

  {

​    int a = 5;

​    printf("i = %d.\n", i);

  }

  a++;      // error: ‘a’ undeclared

*/ 1

}

 

 

 (1)作用域是描述这个变量起作用的代码范围。

(2)基本来说，C语言变量的作用域规则是代码块作用域。意思就是这个变量起作用的范围是当前的代码块。代码块就是一对大括号{}括起来的范围，所以一个变量的作用域是：**这个变量定义所在的{}范围内从这个变量定义开始往后的部分。出了这个{}，这个定义的变量就消失了**。(这就解释了为什么变量定义总是在一个函数的最前面)。

(3)规则：近水楼台先得月，离哪个范围内（大括号）近, 哪个就先作用。

 

int var = 10;

 

int main(void)

{

  printf("in mian， var = %d.\n", var);    // var = 10;

  int var = 5;

  

  if (1)

  {

​    int var = 2;

​    printf("in if, var = %d.\n", var);   //var = 2

  }

  

  printf("var = %d.\n", var);       //var = 5

 

### 4.7.1.3、生命周期

(1)生命周期是描述这个变量什么时候诞生（运行时分配内存空间给这个变量）及什么时候死亡（运行时收回这个内存空间，此后再不能访问这个内存地址，或者访问这个内存地址已经和这个变量无关了）的。

(2)变量和内存的关系，就和人（变量）去图书馆借书（内存）一样。变量的生命周期就好象我人借书的这段周期一样。

(3)研究变量的生命周期可以我们理解程序运行的一些现象、理解C语言的一些规则。

 

### 4.7.1.4、链接属性

(1)大家知道程序从源代码到最终可执行程序，经历的过程：编译、链接。

(2)编译阶段就是把源代码搞成.o目标文件，目标文件里面有很多**符号**和**代码段**、**数据段**、**bss段**等分段。

**符号**就是编程中的变量名、函数名等。运行时变量名、函数名能够和相应的内存对应起来，靠符号来做链接的。

(3).o的目标文件链接生成最终可执行程序的时候，其实就是把符号和相对应的段给链接起来。

C语言中的符号有三种链接属性：外连接属性、内链接属性、无连接属性。

 

总结：以上4个概念，其实就是从4个不同角度来分析C语言的一些运行规则。综合这4种分析角度能够让程序员完全掌握C语言程序的运行规则和方法。

 

## 4.7.2.linux下C程序的内存映像

### 4.7.2.1、代码段、只读数据段

 

(1)对应着程序中的代码（函数），代码段在linux中又叫文本段(.text)

(2)只读数据段就是在程序运行期间只能读不能写的数据，const修饰的常量有可能是存在只读数据段的（但是不一定，const常量的实现方法在不同平台是不一样的）

### 4.7.2.2、数据段、bss段

(1**)****数据段存：**1、显式初始化为非0的全局变量；2、显式初始化为非0的static局部变量。

(2)**bss****段存：**1、显式初始化为0或者未显式初始化的全局变量；2、显式初始化为0或未显式初始化的static局部变量。

### 4.7.2.3、堆

(3)C语言中什么样变量存在堆内存中？

C语言不会自动向堆中存放东西，堆的操作是程序员自己手工操作的。程序员根据需求自己判断要不要使用堆内存，用的时候自己申请，自己使用，完了自己释放。

### 4.7.2.4、文件映射区

(1)文件映射区就是进程打开了文件后，将这个文件的内容从硬盘读到进程的文件映射区，以后就直接在内存中操作这个文件，读写完了后在保存时再将内存中的文件写到硬盘中去。

### 4.7.2.5、栈

(1)栈内存区，局部变量分配在栈上；函数调用传参过程也会用到栈

### 4.7.2.6、内核映射区

(1)内核映射区就是将操作系统内核程序映射到这个区域了。

(2)对于linux中的每一个进程来说，它都以为整个系统中只有它自己和内核而已。它认为内存地址0xC0000000以下都是它自己的活动空间，0xC0000000以上是OS内核的活动空间。

(3)每一个进程都活在自己独立的进程空间中，0-3G的空间每一个进程是不同的（因为用了虚拟地址技术），但是内核是唯一的。

### 4.7.2.7、OS下和裸机下C程序加载执行的差异

(1)C语言程序运行时环境有一定要求，意思是单独个人写的C语言程序没法直接在内存中运行，需要外部一定的协助，这段协助的代码叫加载运行代码（或者叫构建C运行时环境的代码，这一段代码在操作系统下是别人写好的，会自动添加到我们写的程序上，这段代码的主要作用是：给全局变量赋值、清bss段）。

(2)ARM裸机第十六部分，写shell时有一次定义了一个全局变量初始化为0但是实际不为0，后来在裸机的start.S中加了清bss段代码就变0了。这就说明在裸机程序中没人帮我们来做这一段加载运行时代码，要程序员自己做（start.S中的重定位和清bss段就是在做这个事）；在操作系统中运行程序时程序员自己不用操心，会自动完成重定位和清bss，所以我们看到的现象：C语言中未初始化的全局变量默认为0·····。

(3)数据段的全局变量或静态局部变量都是有非0的初值的，这些初值在main函数运行之前就已经被初始化了，是重定位期间完成的初始化。

 

 

## 4.7.3、存储类相关的关键字1

### 4.7.3.1、auto

(1)auto关键字在C语言中只有一个作用，那就是修饰局部变量。

(2)auto修饰局部变量，表示这个局部变量是自动局部变量，自动局部变量分配在栈上。（既然在栈上，说明它如果不初始化那么值就是随机的······）。

(3)平时定义局部变量时就是定义的auto的，只是省略了auto关键字而已。可见，auto的局部变量其实就是**默认定义的普通的局部变量**。

### 4.7.3.2、static

(1)static关键字在C语言中有**2****种用法**，而且这两种用法彼此没有任何关联、完全是独立的。其实当年本应该多发明一个关键字，但是C语言的作者觉得关键字太多不好，于是给static增加了一种用法，导致static一个关键字竟然有两种截然不同的含义。

(2)**static****的第一种用法是**：用来修饰局部变量，形成静态局部变量。要搞清楚静态局部变量和非静态局部变量的区别。本质区别是存储类不同（存储类不同就衍生出很多不同）：**非静态局部变量分配在栈上，而静态局部变量分配在数据段/bss段上（没有初始化和初始化为零放在bss段，初始化后放在数据段）**。

分析：

​       1、静态局部变量在存储类方面和全局变量一样。

​       2、静态局部变量在生命周期方面和全局变量一样。

​       3、静态局部变量和全局变量的**区别**是：**作用域**、**连接属性**。

静态局部变量作用域是代码块作用域（和普通局部变量是一样的）、链接属性是无连接；全局变量作用域是文件作用域（和函数是一样的）、链接属性方面是外连接。

 

(3**)static****的第二种用法是**：用来修饰全局变量，形成静态全局变量。要搞清楚静态全局变量和非静态全局变量的区别。区别是在链接属性上不同，讲到链接属性时详细讲。

把全局变量和函数的外部链接变为内部链接。

注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。

（3）c语言中static的语义

1.static变量:

1).局部

a.静态局部变量在函数内定义,生存期为整个源程序，但作用域与自动变量相同，只能在定义该变量的函数内使用。退出该函数后， 尽管该变量还继续存在，但不能使用它。

b.对基本类型的静态局部变量若在说明时未赋以初值，则系统自动赋予0值。而对自动变量不赋初值，则其值是不定的。

2).全局

全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。但是他们的

 

作用域，非静态全局 变量的作用域是整个源程序（多个源文件可以共同使用）； 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。

————————————————

版权声明：本文为CSDN博主「寂寞的泡面」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/piaojun_pj/article/details/5890186

### 4.7.3.3、register

(1)register关键字不常用，也只有一个作用，那就是：register修饰的变量。编译器会尽量将它分配在寄存器中。（平时分配的一般的变量都是在内存中的）。分配在寄存器中一样的用，但是**读写效率会高很多**。所以register修饰的变量用在那种变量被反复高频率的使用，通过改善这个变量的访问效率可以极大的提升程序运行效率时。所以register是一种极致提升程序运行效率的手段。

(2)uboot中用到了一个register类型的变量，gd这个变量是用来存uboot的全局变量（gd就是global data）。因为这个全局变量在整个uboot中到处都被访问，所以定义成register的。

(3)平时写代码要被定义成register这种情况很少，一般慎用。

(4)register编译器只能承诺尽量将register修饰的变量放在寄存器中，但是不保证一定放在寄存器中。主要原因是因为寄存器数量有限，不一定有空用。

 

 

## 4.7.4.存储类相关的关键字2

### 4.7.4.1、extern

(1)**extern**主要用来声明全局变量。声明的目的主要是在a.c中定义全局变量而在b.c中使用该变量。

(2)C语言中程序的编译时以单个.c源文件为单位的，因此编译a.c时只考虑a.c中的内容（不会考了b.c的内容），这就导致a.c中使用了b.c中定义的变量时在编译时报错。解决方案是声明

(3)应该在a.c中使用g_b之前先声明g_b，声明就是告诉a.c我在别的文件中定义了g_b，并且它的原型和声明的一样，将来在链接的时候链接器会在别的.o文件中找到这个同名变量。声明一个全局变量就要用到extern关键字。

 

*示例：  a.c 文件*

\#include<stdio.h>

   Extern int g_b; //注意这个申明是不可以初始化

​    Int main()

 

  {

​    Printf（“g_b = %d\n”,g_b）

}

 

​    *_____________________________________________________________________________*

​       *b.c  文件*

​       

int g_b;

### 4.7.4.2、volatile

(1)volatile的字面意思：可变的、易变的。C语言中volatile用来修饰一个变量，表示这个变量可以被编译器之外的东西改变。编译器之内的意思是变量的值的改变是代码的作用，编译器之外的改变就是这个改变不是代码造成的，或者不是当前代码造成的，编译器在编译当前代码时无法预知。譬如在中断处理程序isr中更改了这个变量的值，譬如多线程中在别的线程更改了这个变量的值，譬如硬件自动更改了这个变量的值（一般这个变量是一个寄存器的值）。

(2)以上说的三种情况（**中断isr中引用的变量，多线程中共用的变量，硬件会更改的变量**）都是编译器在编译时无法预知的更改，此时应用使用volatile告诉编译器这个变量属于这种（可变的、易变的）情况。编译器在遇到volatile修饰的变量时就不会对改变量的访问进行优化，就不会出现错误。

 

*例子：*

​    

int a, b, c ;      //等效于 c = b = a = 3;

​     a = 3;

​    b = a;

​    c = b;

​    *//在无优化的情况下， cpu要先把 3 赋值给a, 在把a 的值读取出来赋值给b，然后依次类推。这样内存要读取3次，写3次；*

​    *//编译器优化为：内存只要读1次，写3次；*

​    *比如在这样的情况下：a = 3 之后，来了个外部中断，a的值被改变了，这时的a的值已经被改变了，b 和 c的值就不等于3了，但是由于没有加volatile 编译器优化过语句 c=b=a=3； 在中断来之前已经全变为3了 ，这时候就不是我们想要的结果，结果就出错了。*

**_______________________________________________________________________________________________**

(3)编译器的优化在一般情况下非常好，可以帮助提升程序效率。但是在特殊情况（volatile）下，变量会被编译器想象之外的力量所改变，此时如果编译器没有意识到而去优化则就会造成优化错误，优化错误就会带来执行时错误。而且这种错误很难被发现。

(4)volatile是程序员意识到需要volatile然后在定义变量时加上volatile，如果你遇到了应该加volatile的情况而没有加程序可能会被错误的优化。如果在不应该加volatile而加了的情况程序不会出错只是会降低效率。所以我们**对于volatile的态度**应该是：正确区分，

 

该加的时候加不该加的时候不加，如果不能确定该不该加为了保险起见就加上。

### 4.7.4.3、restrict

(1)c99中才支持的，所以很多延续c89的编译器是不支持restrict关键字，gcc支持的。

(2)restrict也是和编译器行为特征有关的。

(3)restrict**只用来修饰指针，不能修饰普通变量**。

(4)http://blog.chinaunix.net/uid-22197900-id-359209.html

(5)memcpy和memmove的区别

c99中新增加了一个类型定义，就是restrict。

看了下网上的相关贴子，但还是问题解决的不够。下面是相关一个文章，我将在后面再加相关说明：

那么restrict的意义是什么呢？

 

概括的说，关键字restrict只用于限定指针；该关键字用于告知编译器，所有修改该指针所指向内容的操作全部都是基于(base on)该指针的，即不存在其它进行修改操作的途径；这样的后果是帮助编译器进行更好的代码优化，生成更有效率的汇编代码。

 

举个简单的例子

 

int foo (int* x, int* y)

...{

*x = 0;

*y = 1;

return *x;

}

 

 

很显然函数foo()的返回值是0，除非参数x和y的值相同。可以想象，99％的情况下该函数都会返回0而不是1。然而编译起必须保证生成100%正确的代码，因此，编译器不能将原有代码替换成下面的更优版本

 

​       int f (int* x, int* y)

...{

*x = 0;

*y = 1;

return 0;

}

 

 

啊哈，现在我们有了restrict这个关键字，就可以利用它来帮助编译器安全的进行代码优化了

 

int f (int *restrict x, int *restrict y)

...{

*x = 0;

*y = 1;

return *x;

}

 

 

此时，由于指针 x 是修改 *x的唯一途径，编译起可以确认 “*y=1; ”这行代码不会修改 *x的内容，因此可以安全的优化为

 

int f (int *restrict x, int *restrict y)

...{

*x = 0;

*y = 1;

return 0;

}

 

最后注意一点，restrict是C99中定义的关键字，C++目前并未引入；在GCC可通过使用参数" -std=c99"

来开启对C99的支持

 

 

下面是我从C语言核心技术一书上摘的：

void *memcpy( void * restrict dest ,const void * restrict src,sizi_t n) 这是一个很有用的内存复制函数，由于两个参数都加了restrict限定，所以两块区域不能重叠，即 dest指针所指的区域，不能让别的指针来修改，即src的指针不能修改. 相对应的别一个函数 memmove(void *dest,const void * src,size_t)则可以重叠。

### 4.7.4.4、typedef

(1)之前讲过了

(2)typedef在C语言关键字归类上属于存储类关键字，但是实际上和存储类没关系。

 

 

## 4.7.5.作用域详解

### 4.7.5.1、局部变量的代码块作用域

(1)代码块基本可以理解为一对大括号{}括起来的部分。

(2)代码块不等于函数，因为if while for都有{}。所以代码块<=函数

(3)**局部变量**的作用域是代码块作用域，也就是说一个局部变量可以被访问和使用的范围仅限于定义这个局部变量的代码块中定义式之后的部分。

示例：

 

### 4.7.5.2、函数名和全局变量的文件作用域

(1)**文件作用域**的意思就是全局的访问权限，也就是说整个.c文件中都可以访问这些东西。这就是平时所说的局部和全局，**全局就是文件作用域**。

(2)详细准确的说：函数和全局变量的作用域是定义所在的整个.c文件之内定义式之后的部分。

 

 

**总结：**

(1)不管是局部变量、全局变量、函数，都要先定义才能使用

(2)严格来说我们上面的总结是错误的。准确的说：全局变量/函数的作用域都是自己所在的文件，但是定义式之前的部分因为缺少声明所以没法用，

解决方案是：1、把它定义到前面去；

2、定义到后面但是在前面加声明；局部变量因为没法声明，所以只能定义在前面去。

(3)在c89标准的编译器中（现在很多编译器还延续使用c89标准），所有的**局部变量**必须先定义在最前面，在变量定义之前不能有一句执行代码。在c99标准的编译器中（gcc兼容c99标准）可以允许在代码块内任意地方定义变量。但是允许定义的变量还是只能使用在定义了之后，定义之前还是不能用的。

 

### 4.7.5.3、同名变量的掩蔽规则

(1)问题：编程时，不可避免会出现同名变量。变量同名后不一定会出错。

(2)首先，如果两个同名变量作用域不同且没有交叠，这种情况下同名没有任何影响。

(3)其次，如果两个同名变量作用域有交叠，C语言规定在作用域交叠范围内，作用域小的一个变量会掩蔽掉作用域大的那个（县官不如现管）。

## 4.7.6.变量的生命周期

### 4.7.6.1、研究变量生命周期的意义

(1)研究变量生命周期，有助于理解变量的行为特征。

### 4.7.6.2、栈变量的生命周期

(1)局部变量（栈变量）存储在栈上，生命周期是临时的。临时的意思就是说：代码执行过程中按照需要去创建、使用、消亡的。

(2)譬如一个函数内定义的局部变量，在这个函数每一次被调用时都会创建一次，然后使用，最后在函数返回的时候消亡。

(3)思考：一个函数内的局部变量为什么在函数外不能使用？

(4)思考：局部变量为什么分配在栈上？或者说局部变量为什么是临时生命周期？

 

### 4.7.6.3、堆变量的生命周期

(1)首先要明白：堆内存空间是客观存在的，是由操作系统维护的。我们程序只是去申请然后使用然后释放。

(2)我们只关心我们程序使用堆内存的这一段时间，因此堆变量也有了自己的生命周期，就是：从malloc申请时诞生，然后使用，直到free时消亡。

(3)所以堆内存在malloc之前和free之后不能再去访问，因此堆内存在实践编程时都是被反复的malloc和free的。

 

### 4.7.6.4、数据段、bss段变量的生命周期

(1)全局变量的生命周期是永久的。永久的意思就是在程序被执行时诞生，在程序终止时消亡。

(2)全局变量所占用的内存是不能被程序自己释放的，所以程序如果申请了过多的全局变量会导致这个程序一直占用大量内存。

(3)**如果说堆内存是图书馆借的书，那么全局变量就是自己买的书**。

 

 

### 4.7.6.5、代码段、只读段的生命周期

(1)其实就是程序执行的代码，其实就是函数，它的生命周期是永久的。不过一般代码的生命周期我们并不关注。

 

 

 

 

 

 

 

 

(2)有时候放在代码段的不只是代码，还有const类型的常量，还有字符串常量。（const类型的常量、字符串常量有时候放在rodata段，有时候放在代码段，取决于平台）。

 

## 4.7.7.链接属性

### 4.7.7.1、C语言程序的组织架构：多个C文件+多个h文件

(1)庞大、完整的一个C语言程序（譬如linux内核、uboot）由多个c文件和多个h文件组成的。

(2)程序的生成过程就是：编译+链接。编译是为了将函数/变量等变成.o二进制的机器码格式，链接是为了将各个独立分开的二进制的函数链接起来形成一个整体的二进制可执行程序。

### 4.7.7.2、编译以文件为单位、链接以工程为单位

(1)编译器工作时是将所有源文件依次读进来，单个为单位进行编译的。

(2)链接的时候实际上是把第一步编译生成个单个的.o文件整体的输入，然后处理链接成一个可执行程序。

### 4.7.7.3、三种链接属性：外连接、内链接、无链接

(1)外连接的意思就是外部链接属性，也就是说这家伙可以在整个程序范围内（言下之意就是可以跨文件）进行链接，**譬如普通的函数和全局变量属于外连接**。

(2)内链接的意思就是（c文件内部）内部链接属性，也就是说这家伙可以在当前c文件内部范围内进行链接（言下之意就是不能在当前c文件外面的其他c文件中进行访问、链接）。**static修饰的函数/全局变量属于内链接。**

(3)无连接的意思就是这个符号本身不参与链接，它跟链接没关系。**所有的局部变量（auto的、static的）都是无连接的**

### 4.7.7.4、函数和全局变量的同名冲突

(1)因为函数和全局变量是外部链接属性，就是说每一个函数和全局变量将来在整个程序中所有的c文件都能被访问，因此在一个程序中的所有c文件中不能出现同名的函数/同名的全局变量。

(2)最简单的解决方案就是起名字不要重复，但是很难做到。主要原因是一个很大的工程中函数和全局变量名字太多了，而且一个大工程不是一个人完成的，是很多人协作完成，所以很难保证不会重名。解决方案呢？

(3)现代高级语言中完美解决这个问题的方法是命名空间namespace（其实就是给一个变量带上各个级别的前缀）。但是C语言不是这么解决的。

(4)C语言比较早碰到这个问题，当时还没发明namespace概念，当时C语言就发明了一种不是很完美但是凑活能用的解决方案，就是三种链接属性的方法。

(5)**C****语言的链接属性解决重名问题思路是这样的：**我们将明显不会在其他c文件中引用（只在当前c文件中引用）的函数/全局变量，使用static修饰使其成为内链接属性，这样在将来连接时即使2个c文件中有重名的函数/全局变量，只要其中一个或2个为内链接属性就没事。

​    打个比方 delay（）；函数a.c和b.c都有，但是a.c只需要内部用，那么申明的时候只要加static，。这样两个函数就互相不干扰了。

(6)这种解决方案在一定程度上解决了问题。但是没有从根本上解决问题，留下了很多麻烦。所以这个就导致了C语言写很大型的项目难度很大。

 

### 4.7.7.5、static的第二种用法：修饰全局变量和函数

(1)普通的（非静态）的函数/全局变量，默认的链接属性是外部的

(2)static（静态）的函数/全局变量，链接属性是内部链接。

 

### 4.7.7.6、一般用法总结：

思考：为什么static一个关键字可以有2种完全不同的意思？因为这两种用法是互斥的。

 

## 4.7.8.最后的总结

(1)**普通（自动）局部变量**分配在栈上，作用域为代码块作用域，生命周期是临时，连接属性为无连接。定义时如果未显式初始化则其值随机，变量地址由运行时在栈上分配得到，多次执行时地址不一定相同，函数不能返回该类变量的地址（指针）作为返回值。

(2)**静态局部变量**分配在数据段/bss段（显式初始化为非0则在数据段，显式初始化为0或未显示初始化则在bss段），作用域为代码块作用域（人为规定的），生命周期为永久（天然的），链接属性为无连接（天然的）。定义时如果未显式初始化则其值为0（天然的），变量地址由运行时环境在加载程序时确定，整个程序运行过程中唯一不变；**静态局部变量其实就是作用域为代码块作用域（同时链接属性为无连接）的全局变量**。静态局部变量可以改为用全局变量实现（程序中尽量避免用全局变量，因为会破坏结构性）。

(3)**静态全局变量**/**静态函数和普通全局变量**/**普通函数**的**唯一差别是**：static使全局变量/函数的链接属性由外部链接（整个程序所有文件范围）转为内部链接（当前c文件内）。这是为了解决全局变量/函数的重名问题（C语言没有命名空间namespace的概念，因此在程序中文件变多之后全局变量/函数的重名问题非常严重，将不必要被其他文件引用的全局变量/函数声明为static可以很大程度上改善重名问题，但是仍未彻底解决）。

(4)写程序尽量避免使用全局变量，尤其是非static类型的全局变量。能确定不会被其他文件引用的全局变量一定要static修饰。

(5)**注意区分全局变量的定义和声明**。一般规律如下：如果定义的同时有初始化则一定会被认为是定义；如果只是定义而没有初始化则有可能被编译器认为是定义，也可能被认为是声明，要具体分析；如果使用extern则肯定会被认为是声明（实际上使用extern也可以有定义，实际上加extern就是明确声明这个变量为外部链接属性）。

(6)全局变量应该定义在c文件中并且在头文件中声明，而不要定义在头文件中（因为如果定义在头文件中，则该头文件被多个c文件包含时该全局变量会重复定义）。

(7)在b.c中引用a.c中定义的全局变量/函数有2种方法：一是在a.h中声明该函数/全局变量，然后在b.c中#include <a.h>；二是在b.c中使用extern显式声明要引用的函数/全局变量。其中第一种方法比较正式。

(8)存储类决定生命周期，作用域决定链接属性

(9)宏和inline函数的链接属性为无连接。

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

# 第八章 一些杂散但值得讨论的问题

## 4.8.0 章节概要

4.8.1.操作系统究竟是个什么玩意？

​    本节使用类比手法直观简单的告诉大家操作系统到底充当什么角色，有什么意义。

4.8.2.main函数返回给谁？

​    本节分析main函数的返回值，使大家明白程序调用的方法和返回值的收集机制。

4.8.3.argc、argv与main函数的传参

​    本节研究main函数的传参，教会大家使用argc和argv以获取程序调用时的传参。

4.8.4.void类型的本质

​    本节分析void类型的本质，空型其实并不空。

4.8.5.C语言中的NULL

​    本节详细解析NULL的含义，结合前面讲过的野指针，使大家细致理解相关的代码。

4.8.6.运算中的临时匿名变量

​    本节讲了C语言中的一个隐藏问题，临时匿名变量。结合本节内容可以让你更加深刻了解C语言的运行规则和工作方法，加深对C程序的理解。

4.8.7.顺序结构

​    本节分析C的三种程序结构之一的顺序结构，让大家思考顺序结构的本质和广泛用途，增加你对C语言工作原理的理解和认识。

4.8.8.程序调试的debug宏

​    本节介绍了C中的调试宏debug，这种一种程序调试中的利器，掌握调试技巧才能让自己不断提升水平而且能够解决问题而不是被问题解决。

## 4.8.1.操作系统究竟是个什么玩意？

### 4.8.1.1、像人类社会一样的计算机软件系统（有些人只埋头干活，有些人只做管理）

(1)人类社会最开始时人人都干活，这时候没有专业分工，所有人都直接做产生价值的工作。当时是合适的，因为当时生产力低下，人口稀少。这就像裸机程序一样（裸机程序的特点是：代码量小，功能简单、所有代码都和直接目的有关，没有服务性代码）。

(2)后来人口增加生产力提高，有一部分人脱离了直接产生价值的体力劳动专职指挥（诞生了阶级）。本质上来说是合理的，因为资源得到了更大限度的使用，优化了配置，提升了整体效率。程序也是一样，当计算机技术发展，计算机性能和资源大量增加，这时候写代码也要产生阶级也要进行分工，不然如果所有代码都去参加直接性的工作，则整体系统效率不高。（因为代码很难进行资源的优化配置）。

(3)解决方案就是操作系统。操作系统就是分出来的管理阶级，操作系统的代码本身并不直接产生价值，它的主要任务是管理所有资源，它主要为直接产生价值、直接劳动的那些程序（各种应用程序）提供服务。所以操作系统既是管理者也是服务者。

(4)裸机程序就好象小公司，操作系统下的程序就好象大型跨国公司；裸机程序就好象小国家，操作系统下程序就好象大国家；如果我们要做一个产品，软件系统到底应该是裸机还是基于操作系统呢？本质上取决于产品本身的复杂度。只有极简单的功能、使用极简单的CPU（譬如单片机）的产品才会选择用裸机开发；一般的复杂性产品都会选择基于操作系统来开发。

 

### 4.8.1.2、操作系统的调用通道：API函数

(1)操作系统负责管理和资源调配，应用程序负责具体的直接劳动，他们之间的接口就是API函数。当应用程序需要使用系统资源（譬如内存、譬如CPU、譬如硬件操作）时就通过API向操作系统发出申请，然后操作系统响应申请帮助应用程序执行功能。

 

### 4.8.1.3、C库函数和API的关系

(1)单纯的API只是提供了极简单没有任何封装的服务函数，这些函数应用程序是可用的，但是不太好用。应用程序为了好用，就对这个API进行了二次封装，把它变得好用一些，于是就成了C库函数。

(2)有时完成一个功能，有相应的库函数可以完成，也有API可以完成，用哪个都行。譬如读写文件，API的接口是open write read close；库函数的接口是fopen fwrite fread fclose。fopen本质上是使用open实现的，只是进行了封装。封装肯定有目的（添加缓冲机制）。

### 4.8.1.4、不同平台（windows、linux、裸机）下库函数的差异

(1)不同操作系统API是不同的，但是都能完成所有的任务，只是完成一个任务所调用的API不同。

(2)库函数在不同操作系统下也不同，但是相似性要更高一些。这是人为的，因为人下意识想要屏蔽不同操作系统的差异，因此在封装API成库函数的时候，尽量使用了同一套接口，所以封装出来的库函数挺像的。但是还是有差异，所以在一个操作系统上写的应用程序不可能直接在另一个操作系统上面编译运行。于是乎就有个可移植性出来了。

(3)跨操作系统可移植平台，譬如QT、譬如Java语言。

 

4.8.1.5、操作系统的重大意义：软件体系分工

(1)有了操作系统后，我们做一个产品可以首先分成2部分：一部分人负责做操作系统（开发驱动的）；一部分人负责用操作系统实现具体功能（开发应用）。实际上上层应用层的功能进一步复杂化后又分了好多层。

 

## 4.8.2.main函数返回给谁？

### 4.8.2.1、函数为什么需要返回值

(1)函数在设计的时候设计了参数和返回值，参数是函数的输入，返回值是函数的输出。

(2)因为函数需要对外输出数据（实际上是函数运行的一些结果值）因此需要返回值

(3)形式上来说，函数被另一个函数所调用，返回值作为函数式的值返回给调用这个函数的地方

总结：函数的返回值就是给调用它的人返回一个值

### 4.8.2.2、main函数被谁调用

(1)main函数是特殊的，首先这个名字是特殊的。因为C语言规定了main函数是整个程序的入口。其他的函数只有直接或间接被main函数所调用才能被执行，如果没有被main直接/间接调用则这个函数在整个程序中无用。

(2)main函数从某种角度来讲代表了我当前这个程序，或者说代表了整个程序。main函数的开始意味着整个程序开始执行，main函数的结束返回意味着整个程序的结束。

(3)谁执行了这个程序，谁就调用了main。

(4)谁执行了程序？或者说程序有哪几种被调用执行的方法？

 

### 4.8.2.3、linux下一个新程序执行的本质

(1)表面来看，linux中在命令行中去./xx执行一个可执行程序

(2)我们还可以通过shell脚本来调用执行一个程序

(3)我们还可以在程序中去调用执行一个程序（fork exec）

总结：我们有多种方法都可以执行一个程序，但是本质上是相同的。linux中一个新程序的执行本质上是一个进程的创建、加载、运行、消亡。linux中执行一个程序其实就是创建一个新进程然后把这个程序丢进这个进程中去执行直到结束。

**新进程是被谁开启**？在linux中进程都是被它的**父进程**fork出来的。

**分析：**命令行本身就是一个进程，在命令行底下去./xx执行一个程序，其实这个新程序是作为命令行进程的一个**子进程**去执行的。

总之一句话：一个程序被它的父进程所调用。

**结论：**main函数返回给调用这个函数的父进程。父进程要这个返回值干嘛？父进程调用子进程来执行一个任务，然后字进程执行完后通过main函数的返回值返回给父进程一个答复。这个答复一般是表示子进程的任务执行结果完成了还是错误了。（0表示执行成功，负数表示失败）。

 

### 4.8.2.4、实践验证获取main的返回值

(1)用shell脚本执行程序可以获取程序的返回值并且打印出来

(2)linux shell中用$?这个符号来存储和表示上一个程序执行结果。

 

### 4.8.2.5、启示

(1)任何人任何事物都是有妈生的，不会无缘无故出现或消亡。

(2)看起来没用、改掉或去掉没错的，也不见得就真的没用没错。要大胆总结更要小心求证。

## 4.8.3.argc、argv与main函数的传参

### 4.8.3.1、谁给main函数传参

(1)调用main函数所在的程序的它的父进程给main函数传参，并且接收main的返回值。

### 4.8.3.2、为什么需要给main函数传参

(1)首先，main函数不传参是可以的，也就是说父进程调用子程序并且给子程序传参不是必须的。 int main(void)这种形式就表示我们认为不必要给main传参。

(2)有时候我们希望程序有一种灵活性，所以选择在执行程序时通过传参来控制程序中的运行，达到不需要重新编译程序就可以改变程序运行结果的效果。

 

### 4.8.3.3、表面上：给main传参是怎样实现的？

(1)给main传参通过argc和argv这两个C语言预订的参数来实现

(2)argc是int类型，表示运行程序的时候给main函数传递了几个参数；argv是一个字符串数组，这个数组用来存储多个字符串，每个字符串就是我们给main函数传的一个参数。argv[0]就是我们给main函数的第一个传参，argv[1]就是传给main的第二个参数····

 

### 4.8.3.4、本质上：给main传参是怎样实现的？

(1)上节课讲过，程序调用有各种方法但是本质上都是父进程fork一个子进程，然后字进程和一个程序绑定起来去执行（exec函数族），我们在exec的时候可以给他同时传参。

(2)程序调用时可以被传参（也就是main的传参）是操作系统层面的支持完成的。

 

### 4.8.3.5、给main传参要注意什么

(1)main函数传参都是通过字符串传进去的。

(2)程序被调用时传参，各个参数之间是通过空格来间隔的。

(3)在程序内部如果要使用argv，那么一定要先检验argc。

 

题目：写个计算器，然后运行时可以 ./calculator 3 + 5，程序执行返回8

 

 

## 4.8.4.void类型的本质

### 4.8.4.1、C语言属强类型语言

(1)编程语言分2种：**强类型语言**和**弱类型语言**

**强类型语言**中所有的变量都有自己固定的类型，这个类型有固定的内存占用，有固定的解析方法；

**弱类型语言**中没有类型的概念，所有变量全都是一个类型（一般都是字符串的），程序在用的时候再根据需要来处理变量。

(2)**C****语言就是典型的强类型语言**，C语言中所有的变量都有明确的类型。因为C语言中的一个变量都要对应内存中的一段内存，编译器需要这个变量的类型来确定这个变量占用内存的字节数和这一段内存的解析方法。

 

### 4.8.4.2、数据类型的本质含义

(1)数据类型的本质就决定变量的内存占用数，和内存的解析方法。

(2)所以得出结论：c语言中变量必须有确定的数据类型，如果一个变量没有确定的类型（就是所谓的无类型）会导致编译器无法给这个变量分配内存，也无法解析这个变量对应的内存。因此得出结论不可能有没有类型的变量。

(3)但是C语言中可以有没有类型的内存。在内存还没有和具体的变量相绑定之前，内存就可以没有类型。实际上纯粹的内存就是没有类型的，内存只是因为和具体的变量相关联后才有了确定的类型（其实内存自己本身是不知道的，而编译器知道，我们程序在使用这个内存时知道类型所以会按照类型的含义去进行内存的读和写）。

 

### 4.8.4.3、void类型的本质

(1)void类型的正确的含义是：不知道类型，不确定类型，还没确定类型。

(2)void a;定义了一个void类型的变量，含义就是说a是一个变量，而且a肯定有确定的类型，只是目前我还不知道a的类型，还不确定，所以标记为void。

 

### 4.8.4.4、为什么需要void类型

(1)什么情况下需要void类型？其实就是在描述一段还没有具体使用的内存时需要使用void类型。

(2)void的一个典型应用案例就是malloc的返回值。我们知道malloc函数向系统堆管理器申请一段内存给当前程序使用，malloc返回的是一个指针，这个指针指向申请的那段内存。malloc刚申请的这段内存尚未用来存储数据，malloc函数也无法预知这段内存将来被存放什么类型的数据，所以malloc无法返回具体类型的指针，解决方法就是返回一个void *类型，告诉外部我返回的是一段干净的内存空间，尚未确定类型。所以我们在malloc之后可以给这段内存读写任意类型的数据。

(3)void *类型的指针指向的内存是尚未确定类型的，因此我们后续可以使用强制类型转换强行将其转为各种类型。**这就是void类型的最终归宿，就是被强制类型转换成一个具体类型。**

(4)void类型使用时一般都是和**指针相关联**的用void *，而不是仅仅使用void。

 

 

## 4.8.5.C语言中的NULL

### 4.8.5.1、NULL在C/C++中的标准定义

(1)NULL不是C语言关键字，本质上是一个宏定义

(2)NULL的标准定义：

\#ifdef _cplusplus      // 条件编译

\#define NULL 0

\#else

\#define NULL (void *)0   // 这里对应C语言的情况

\#endif

 

 

解释：C++的编译环境中，编译器预先定义了一个宏_cplusplus，程序中可以用条件编译来判断当前的编译环境是C++的还是C的。

NULL的本质解析：NULL的本质是0，但是这个0不是当一个数字解析，而是当一个内存地址来解析的，这个0其实是0x00000000，代表内存的0地址。(void *)0这个整体表达式表示一个指针，这个指针变量本身占4字节，地址在哪里取决于指针变量本身，但是这个指针变量的值是0，也就是说这个指针变量指向0地址（实际是0地址开始的一段内存）。

 

### 4.8.5.2、从指针角度理解NULL的本质

(1)int *p;    // p是一个函数内的局部变量，则p的值是随机的，也就是说p是一个野指针。

(2)int *p = NULL;  // p是一个局部变量，分配在栈上的地址是由编译器决定的，我们不必关心，但是p的值是(void *)0，实际就是0，意思是指针p指向内存的0地址处。这时候p就不是野指针了。

(3)为什么要让一个野指针指向内存地址0处？主要是因为在大部分的CPU中，内存的0地址处都不是可以随便访问的（一般都是操作系统严密管控区域，所以应用程序不能随便访问）。所以野指针指向了这个区域可以保证野指针不会造成误伤。如果程序无意识的解引

 

用指向0地址处的野指针则会触发段错误。这样就可以提示你帮助你找到程序中的错误。

（4）为什么是（void *），因为不知道是怎么类型，比如int *p = (void *)0,因为编译器不知道你要用char 还是int ，假如用了，int*，那么如果不用（void*）的话编译器将会报警告，类型不匹配。

### 4.8.5.3、为什么需要NULL

(1)第一个作用就是让野指针指向0地址处安全。

(2)第二个作用就是一个特殊标记。按照标准的指针使用步骤是：

int *p = NULL;   // 定义p时立即初始化为NULL

p = xx;

if (NULL != p)

{

​    *p       // 在确认p不等于NULL的情况下才去解引用p

}

p = NULL      // 用完之后p再次等于NULL

 

 

注意：一般比较一个指针和NULL是否相等不写成if (p == NULL)，而写成if (NULL == p)。原因是第一种写法中如果不小心把==写成了=，则编译器不会报错，但是程序的意思完全不一样了；而第二种写法如果不小心把==写成了=则编译器会发现并报错。

 

### 4.8.5.4、注意不要混用NULL与'\0'

(1)'\0' 和 '0' 和 0 和 NULL几个区分开。

(2)'\0'是一个转义字符，他对应的ASCII编码值是0，本质就是0

(3)'0'是一个字符，他对应的ASCII编码值是48，本质是48

(4)0是一个数字，他就是0，本质就是0

(4)NULL是一个表达式，是强制类型转换为void *类型的0，本质是0.

 

总结：**'\0'用法是C语言字符串的结尾标志，一般用来比较字符串中的字符以判断字符串有没有到头；'0'是字符0，对应0这个字符的ASCII编码，一般用来获取0的ASCII码值；0是数字，一般用来比较一个int类型的数字是否等于0；NULL是一个表达式，一般用来比较指针是否是一个野指针。**

 

 

## 4.8.6.运算中的临时匿名变量

### 4.8.6.1、C语言和汇编的区别（汇编完全对应机器操作，C对应逻辑操作）

(1)C语言叫高级语言，汇编语言叫低级语言。

(2)低级语言的意思是汇编语言和机器操作相对应，汇编语言只是CPU的机器码的助记符，用汇编语言写程序必须拥有机器的思维。因为不同的CPU设计时指令集差异很大，因此用汇编编程的差异很大。

(3)高级语言（C语言）它对低级语言进行了封装（C语言的编译器来完成），给程序员提供了一个靠近人类思维的一些语法特征，人类不用过于考虑机器原理，而可以按照自己的逻辑原理来编程。譬如数组、结构体、指针····

(4)更高级的语言如java、C#等只是进一步强化了C语言提供的人性化的操作界面语法，在易用性上、安全性上进行了提升。

 

### 4.8.6.2、C语言的一些“小动作”

(1)高级语言中有一些元素是机器中没有的

(2)高级语言在运算中允许我们大跨度的运算。意思就是低级语言中需要好几步才能完成的一个运算，在高级语言中只要一步即可完成。譬如C语言中一个变量i要加1，在C中只需要i++即可，看起来只有一句代码。但实际上翻译到汇编阶段需要3步才能完成：第1步从内存中读取i到寄存器，第2步对寄存器中的i进行加1，第3步将加1后的i写回内存中的i。

 

### 4.8.6.3、使用临时变量来理解强制类型转换

 

 float a = 12.34;

  int b = (int)a;   // a被强制类型转换后自己本身竟然没变

​            // (int)a强制类型转换并赋值在底层实际分了4个步骤：

​            //第一步先在另外的地方找一个内存构建一个临时变量x（x的类型是int，x的值等于a的整数部分），

​            //第二步将float a的值的整数部分赋值给x，第三步将x赋值给b，第四步销毁x。

​            // 最后结果：a还是float而且值保持不变，b是a的整数部分。

  

  printf("a = %f, b = %d.\n", a, b);//a =12.34, b =12

 

### 4.8.6.4、使用临时变量来理解不同数据类型之间的运算

 

int b;

  float a;

  b = 10;

  a = b / 3;   // 第一步先算 b/3，

​          //第二步将第一步的结果强制类型转换为float生成一个临时变量，

​          //第三步将第二步生成的临时变量赋值给a，第四步销毁临时变量。

​          //如果需要正确的运算结果需要将b或者3 这两个数其中一个转换为float类型

  printf("a = %f.\n", a); //3.0000000

 

## 4.8.7.顺序结构

### 4.8.7.1、最浅显的顺序结构：三种结构之一

(1)代码执行的时候如果没有遇到判断跳转或者循环，默认是顺序执行的。执行完上一句则开始执行下一句。

(2)顺序结构说明CPU的工作状态，就是以时间轴来顺序执行所有的代码语句直到停机。

 

### 4.8.7.2、选择和循环结构内部的顺序结构

(1)譬如if(){}在{}内部是if的代码段，在代码段内部还是按照顺序结构来执行的。

(2)switch case内部也一样，也是按照顺序结构执行的。

(3)while for内部也是按照顺序结构来执行的。

 

### 4.8.7.3、编译过程中的顺序结构

(1)一个C程序有多个.c文件组成，编译的时候多个.c文件是独立分开编译的。每个c文件编译的时候，编译器是按照从前到后的顺序逐行进行编译的。

(2)编译器编程时的顺序编译会导致函数/变量必须先定义/声明才能调用，这也是C语言中函数/变量声明的来源。

(3)链接过程中呢？应该说链接过程链接器实际上是在链接脚本指导下完成的。所以链接时的.o文件的顺序是由链接脚本指定的。如果链接脚本中明确指定了顺序则会优先考虑这个规则按照这个指定的顺序排布，如果链接脚本中没有指定具体的顺序则链接器会自动的排布。

 

### 4.8.7.4、思考：为什么本质都是顺序结构？

(1)顺序结构本质上符号CPU的设计原理，CPU又是人设计的，所以CPU的设计符合人的思考原理

 

 

### 4.8.8.程序调试的debug宏

### 4.8.8.1、程序调试的常见方案：单步调试、裸机LED调试、打印信息、log文件

(1)利用调试器进行单步调试（譬如IDE中，Jlink）适用于新手，最大的好处就是直观，能够帮助找到问题。缺点是限制性大、速度慢。

(2)裸机使用LED、蜂鸣器等硬件调试，适合单片机裸机程序

(3)printf函数打印调试，比较常用，作为程序员必须学会使用打印信息调试。好处是具有普遍性，**几乎在所有的情况下都能用**。

(4)log文件（日志文件）是系统运行过程中在特定时候会打印一些调试信息，日志文件记录下来这些调试信息以供后续查找追查问题。**适合于系统级或者大型程序的调试**。

 

### 4.8.8.2、打印信息不能太多也不能太少

(1)调试信息太少会不够信息找到问题所在。

(2)调试信息太多会有大量的无用的信息淹没有用信息，导致有用信息无法看见，等于没有。

 

### 4.8.8.3、调试(DEBUG)版本和发行(RELEASE)版本的区别

(1)DEBUG版本就是包含了调试信息输出的版本，在程序测试过程中会发布debug版本，这种版本的程序运行时会打印出来调试信息/log文件，这些信息可以辅助测试人员判断程序的问题所在。DEBUG版本的坏处是输出调试信息占用了系统资源，拖慢了系统运行速度。因此DEBUG版本的性能低于RELEASE版本。

(2)RELEASE版本就是最终的发布版本，相较于DEBUG版本的功能代码是一样的，但是

 

去掉了所有的调试信息。适合最终测试通过要发布的程序，因为去掉了调试信息所以程序的运行效率要更高。

(3)DEBUG和RELASE版本其实是一套源代码。源代码中是有很多的打印调试信息的语句的，如何来控制生成DEBUG和RELEEASE版本？靠条件编译，靠一个宏。

 

### 4.8.8.4、debug宏的实现原理

(1)DEBUG宏大概的原理是：

\#ifdef DEBUG

\#define dbg()    printf()

\#else

\#define dbg()  

\#endif

 

 (2)工作方式是：如果我们要输出DEBUG版本则在条件编译语句前加上#define DEBUG即可，这样程序中的调试语句dbg()就会被替换成printf从而输出；如果我们要输出RELEASE版本则去掉#define DEBUG，则dbg()就会被替换成空，则程序中所有的dbg()语句直接蒸发了，这样的程序编译时就会生成没有任何调试信息的代码。

 

### 4.8.8.5、debug宏的使用方法

 

### 4.5.8.6、分析几个DEBUG宏

(1)应用程序中DEBUG宏

\#ifdef DEBUG

\#define DBG(...) fprintf(stderr, " DBG(%s, %s(), %d): ", __FILE__, __FUNCTION__, __LINE__); fprintf(stderr, __VA_ARGS__)

\#else

\#define DBG(...)

\#endif

 

 

注：__FILE__等是C语言中的预定义宏，就是说这个东西是个宏定义，但是是C语言自己定义的。这些宏具有特殊的含义，譬如__FILE__表示当前正在编译的c文件的文件名。

 

(2)内核中的DEBUG宏

\#ifdef DEBUG_S3C_MEM

\#define DEBUG(fmt, args...)   printk(fmt, ##args)

\#else

\#define DEBUG(fmt, args...)   do {} while (0)

\#endif

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

# 第九章 链表&状态机与多线程

## 4.9.0 章节概要

**4.9.1.链表的引入**

​    本节从数组的缺陷说起引入链表的概念，目的是让大家自然认识到链表的意义和用途。

**4.9.2.单链表的实现**

​    本节介绍单链表的思路和编程实现，重点是链表节点的封装和实现。

**4.9.3.单链表的算法之插入节点**

​    本节讲述单链表操作的第一个算法，节点插入。主要介绍了头部插入和尾部插入这两种不同算法。

**4.9.4.单链表的算法之插入节点续**

​    本节为链表尾部插入的编程实践，带大家写代码实现从尾部插入节点。

**4.9.5.从链表头部插入新节点**

​    本节为链表头部插入的编程实践，带大家写代码实现从头部插入节点。

**4.9.6.单链表的算法之遍历节点**

​    本节是单链表的第二个算法：遍历链表的原理与编程实现。

**4.9.7.单链表的算法之删除节点**

​    本节实现单链表的第3个算法：删除指定节点。

**4.9.8.单链表的算法之逆序**

​    本节介绍单链表的最后一个算法：链表逆序，这也是我们处理的难度最大的一个算法了。

**4.9.9.双链表的引入和基本实现**

​    本节分析单链表的缺陷并同时引入双链表，并且编程实现双链表的节点。

**4.9.10.双链表的算法之插入节点**

​    本节讲解双链表的第一个算法：插入节点。同样分为头部插入和尾部插入两种。

**4.9.11.双链表的算法之遍历节点**

​    本节讲解双链表的第二个算法：遍历节点。

**4.9.12.双链表的算法之删除节点**

​    本节介绍双链表的删除节点的算法，并进行编程实践。

**4.9.13.linux内核链表**

​    本节通过分析我们讲的链表的一些缺陷来引入内核链表，介绍了内核链表的设计思路和主要特点。

**4.9.14.内核链表的基本算法和使用简介**  

​    本节介绍内核链表的基本算法实现和内核链表的使用方法，在内核代码尤其是各种驱动中广安的使用了内核链表。

**4.9.15.什么是状态机**

​    本节从理论介绍了状态机的定义和分类，然后分析了状态机的主要用途，状态机的应用方向和解决的问题，目的是使大家理解为什么要有状态机。

**4.9.16.C语言实现简单的状态机**

​    本节课使用C语言实现了一个简单的状态机，目的是结合上节的理论让大家进一步理解状态机的实现、理解状态机实现了什么、解决了什么问题。

**4.9.17.多线程简介**

​    本节课简单介绍了多线程的概念，多线程编程，为后面应用编程部分使用多线程开了个头。

## 4.9.1.链表的引入

### 4.9.1.1、从数组的缺陷说起

(1)数组有2个缺陷，一个是数组中所有元素的类型必须一致；第二个是数组的元素个数必须事先制定并且一旦指定之后不能更改。

(2)如何解决数组的2个缺陷：数组的第一个缺陷靠结构体去解决。结构体允许其中的元素的类型不相同，因此解决了数组的第一个缺陷。所以说结构体是因为数组不能解决某些问题所以才发明的。

(3)如何解决数组的第二个缺陷？我们希望数组的大小能够实时扩展。譬如我刚开始定了一个元素个数是10，后来程序运行时觉得不够因此动态扩展为20.普通的数组显然不行，我们可以对数组进行封装以达到这种目的；我们还可以使用一个新的数据结构来解决，这个新的数据结构就是链表。

总结：几乎可以这样理解：链表就是一个元素个数可以实时变大/变小的数组。

 

### 4.9.1.2、大学为什么都有新校区？

(1)学校初建的时候（类似于变量定义并初始化时），这时候因为旁边都是荒地而没有建筑，因此学校的校园大小由自己定的；但是学校建立了之后旁边慢慢的也有了其他建筑（类似于这个变量分配了之后，内存的相邻区域又分配了其他变量与这个变量地址相连），这时候你的校园随着发展感觉不够用了想要扩展，却发现邻居已经住满了，校园的四周全部都是别人的建筑。

这时候学校要扩展有2个办法：**第一个是拆迁，第二个是搬迁，第三个是外部扩展**。

①拆迁基本行不通，因为成本太高了。

②搬迁可以行的通。程序中解决数组大小扩展的一个思路就是整体搬迁。

具体步骤是：

先在另外的空白内存处建立一个大的数组，

再把原来的数组中的元素的值整个复制到新数组的头部，

然后再释放掉原来数组的内存空间，并且把新的数组去替代原来的数组。

这种可变数组在C语言中不支持，但是在更高级语言如C++、Java等里面是支持的。

③**外部扩展的思路是最常见的，基本可以说是最合理的**：它的一个思路就是化整为零，在原来的不动的前提下去外部扩展新的分基地。外部扩展在学校的例子中就是新校区；外部扩展在编程解决数组问题的点上就是链表。

 

### 4.9.1.3、链表是什么样的？

(1)顾名思义，链表就是用锁链连接起来的表。这里的表指的是一个一个的节点（一个节点就是一个校区），节点中有一些内存可以用来存储数据（所以叫表，表就是数据表）；这里的锁链指的是链接各个表的方法，C语言中用来连接2个表（其实就是2块内存）的方法就是指针。

(2)链表是由若干个节点组成的（链表的各个节点结构是完全类似的），节点是由有效数据和指针组成的。有效数据区域用来存储信息完成任务的，指针区域用于指向链表的下一个节点从而构成链表。

 

### 4.9.1.4、时刻别忘了链表是用来干嘛的

(1)时刻谨记：链表就是用来解决数组的大小不能动态扩展的问题，所以链表其实就是当数组用的。直白点：链表能完成的任务用数组也能完成，数组能完成的任务用链表也能完成。但是灵活性不一样。

(2)简单说：链表就是用来存储数据的。链表用来存数据相对于数组来说优点就是灵活性，需要多少个动态分配多少个，不占用额外的内存。数组的优势是使用简单（简单粗暴）。

 

 

## 4.9.2.单链表的实现

### 4.9.2.1、单链表的节点构成

(1)链表是由节点组成的，节点中包含：有效数据和指针。

(2)定义的struct node只是一个结构体，本身并没有变量生成，也不占用内存。结构体定义相当于为链表节点定义了一个模板，但是还没有一个节点，将来在实际创建链表时需要一个节点时用这个模板来复制一个即可。

 

struct node{

  int data;

  struct node* pNext;

};

 

 

### 4.9.2.2、堆内存的申请和使用

(1)链表的内存要求比较灵活，不能用栈，也不能用data数据段。只能用堆内存。

(2)使用堆内存来创建一个链表节点的步骤：

1、申请堆内存，大小为一个节点的大小（检查申请结果是否正确）；

2、清理申请到的堆内存；

3、把申请到的堆内存当作一个新节点；

4、填充你哦个新节点的有效数据和指针区域。

 

### 4.9.2.3、链表的头指针

(1)头指针并不是节点，而是一个普通指针，只占4字节。头指针的类型是struct node *类型的，所以它才能指向链表的节点。

(2)一个典型的链表的实现就是：头指针指向链表的第1个节点，然后第1个节点中的指针指向下一个节点，然后依次类推一直到最后一个节点。这样就构成了一个链。

 

### 4.9.2.4、实战：构建一个简单的单链表

(1)目标：构建一个链表，然后将一些数据（譬如1，2，3三个数字）存储在链表中

\#include<stdio.h>

\#include<string.h>

 

struct node{

  int data;

  struct node* pNext;

};




int main(void)

{

  struct node *pHeader = NULL;

/**********************************************************/

  //创建一个链表节点

  struct node *p =(struct node*)malloc(sizeof(struct node));

  if(NULL == p)

  {

​    printf("malloc error!");

​    return -1;

  }

  //清理申请到的堆内存；

  bzero(p, sizeof(struct node));

  //填充节点

  p->data = 1;

  p->pNext = NULL;    //将要要指向下一节点首地址

​              //// 实际操作时将下一个节点malloc返回的指针赋值给这个

  pHeader = p;

 

  struct node *p1 = (struct node*)malloc (sizeof(struct node));

  if(NULL == p1)

  {

​    printf("malloc eorror!\n");

​    return 1;

  }

  p1->data = 2;

  p1->pNext = NULL;

  p->pNext = p1;

}

 

## 4.9.3.单链表的算法之插入节点

### 4.9.3.1、继续上节，访问链表中各个节点的数据

(1)只能用头指针，不能用各个节点自己的指针。因为在实际当中我们保存链表的时候是不会保存各个节点的指针的，只能通过头指针来访问链表节点。

(2)前一个节点内部的pNext指针能帮助我们找到下一个节点。

### 4.9.3.2、将创建节点的代码封装成一个函数

(1)封装时的关键点就是函数的接口（函数参数和返回值）的设计

### 4.9.3.3、从链表头部插入新节点

 

### 4.9.3.4、从链表尾部插入新节点

(1)尾部插入简单点，因为前面已经建立好的链表不用动。直接动最后一个就可以了。

// 思路：由头指正向后遍历，直到走到原来的最后一个节点。原来的最后一个节点里面的pNext

//是NULL，现在我们只要将它改成new就可以了。添加了之后新节点就变成了最后一个。

void insert_tail(struct node *pH, struct node *new)

{

  //分两步来插入

  //第一步，先找到链表中最后一个节点

  struct node *p = pH;

  while(NULL != p->pNext)

  {

​    p = p->pNext;    //往后走一个节点吗

  }

 

  //第二部，将新节点插入到最后一个节点尾部

  p->pNext = new;

}

 

## 4.9.4.单链表的算法之插入节点续

### 4.9.4.1、详解链表头部插入函数

// 思路：由头指正向后遍历，直到走到原来的最后一个节点。原来的最后一个节点里面的pNext

//是NULL，现在我们只要将它改成new就可以了。添加了之后新节点就变成了最后一个。

//计算添加了新的节点后总共有多少个节点，然后写入头结点中

void insert_tail(struct node *pH, struct node *new)

{

  int cnt = 0;

  //分两步来插入

 

  //第一步，先找到链表中最后一个节点

  struct node *p = pH;

  while(NULL != p->pNext)

  {

​    p = p->pNext;    //往后走一个节点吗

​    cnt ++;

  }

 

  //第二步，将新节点插入到最后一个节点尾部

  p->pNext = new;

  pH->data = cnt + 1;

}

 

### 4.9.4.2、什么是头节点

void insert_tail(struct node *pH, struct node *new)

{

  //分两步来插入

  //第一步，先找到链表中最后一个节点

  struct node *p = pH;

  while(NULL != p->pNext)

  {

​    p = p->pNext;    //往后走一个节点吗

  }

 

  //第二部，将新节点插入到最后一个节点尾部

  p->pNext = new;

}

 

int main(void)

{

// struct node *pHeader = NULL;这样会段错误，因为inser_tail我们写的判断有问题,

  //因为 NULL是不能insert_tail 插入元素是解引用的NULL,会出错

  //初始化要这么初始化struct node *pHeader = (sturct node* )malloc(sizeof(stuct node));

  struct node *pHeader = create_node(1);

  insert_tail(pHeader,create_node(21));

  insert_tail(pHeader,create_node(31));

  insert_tail(pHeader,create_node(41));

 

(1)问题：因为我们在insert_tail中直接默认了头指针指向的有一个节点，因此如果

 

程序中直接定义了头指针后就直接insert_tail就会报段错误。我们不得不在定义头指针之后先create_node创建一个新节点给头指针初始化，否则不能避免这个错误；但是这样解决让程序看起来逻辑有点不太顺，因为看起来第一个节点和后面的节点的创建、添加方式有点不同。

(2)链表还有另外一种用法，就是把头指针指向的第一个节点作为头节点使用。头节点的特点是：

**第一**，它紧跟在头指针后面。

**第二**，头节点的数据部分是空的（有时候不是空的，而是存储整个链表的节点数），指针部分指向下一个节点，也就是第一个节点。

(3)这样看来，头节点确实和其他节点不同。我们在创建一个链表时添加节点的方法也不同。头节点在创建头指针时一并创建并且和头指针关联起来；后面的真正的存储数据的节点用节点添加的函数来完成，譬如insert_tail.

(4)链表有没有头节点是不同的。体现在链表的插入节点、删除节点、遍历节点、解析链表的各个算法函数都不同。所以如果一个链表设计的时候就有头节点那么后面的所有算法都应该这样来处理；如果设计时就没有头节点，那么后面的所有算法都应该按照没有头节点来做。实际编程中两种链表都有人用，所以大家在看别人写的代码时一定要注意看它有没有头节点。

 

 

## 4.9.5.从链表头部插入新节点

(1)注意写代码过程中的箭头符号，和说话过程中的指针指向。这是两码事，容易搞混。箭头符号实际上是用指针方式来访问结构体，所以箭头符号的实质是访问结构体中的成员。更清楚一点说程序中的箭头和链表的连接没有任何关系；

链表中的节点通过指针指向来连接，编程中表现为一个赋值语句（用=来进行连接），实质是把后一个节点的首地址，赋值给前一个节点中的pNext元素做为值。

(2)链表可以从头部插入，也可以从尾部插入。也可以两头插入。头部插入和尾部插入对链表来说几乎没有差别。对链表本身无差别，但是有时候对业务逻辑有差别。

 

 

 

void insert_header(struct node *pH, struct node *new)

{

  //第一步新节点的next指向第一个节点   ，这个顺序不可以换，第二步放第一步的话，第一个节点的地址会丢失

  new->pNext = pH->pNext;

 

  //第二步头结点指向新地址

  pH->pNext = new;

  

  //第三步头节点中的计数要加1

  pH->data += 1;

}

 

## 4.9.6.单链表的算法之遍历节点

### 4.9.6.1、什么是遍历

(1)遍历就是把单链表中的各个节点挨个拿出来，就叫遍历。

(2)遍历的要点：一是不能遗漏、二是不能重复、追求效率。

### 4.9.6.2、如何遍历单链表

(1)分析一个数据结构如何遍历，关键是分析这个数据结构本身的特点。然后根据本身特点来制定它的遍历算法。

(2)单链表的特点就是由很多个节点组成，头指针+头节点为整个链表的起始，最后一个节点的特征是它内部的pNext指针值为NULL。从起始到结尾中间由各个节点内部的pNext指针来挂接。由起始到结尾的路径有且只有一条。单链表的这些特点就决定了它的遍历算法。

(3)遍历方法：从头指针+头节点开始，顺着链表挂接指针依次访问链表的各个节点，取出这个节点的数据，然后再往下一个节点，直到最后一个节点，结束返回。

 

### 4.9.6.3、编程实战

(1)写一个链表遍历的函数，void bianli(struct node*pH);

  //遍历单链表，pH为单链表的头指针

void bianli(struct node *pH)

{

  //pH->data

  struct node *p = pH->pNext;     //直接走到第一个节点

  printf("开始遍历！\n");

  while(NULL != p->pNext)

  {

​    printf("node data :%d.\n",p->data);

​    p = p->pNext;          

  }

   printf("node data :%d.\n",p->data);  //补了一刀，解决最后一个节点丢失问题，但是程序不美

 

   printf("遍历完成！\n"); 

}

 

//1、思考下为什么这样能解决问题；2、思考下设计莲表示为什么要设计头节点

void bianli2(struct node *pH)

{

  //pH->data

  struct node *p = p;     //直接走到第一个节点

  printf("开始遍历！\n");

  while(NULL != p->pNext)

  {  

​    p = p->pNext; 

​    printf("node data :%d.\n",p->data);

​             

  }

   printf("遍历完成！\n"); 

}

 

 

 

## 4.9.7.单链表的算法之删除节点

### 4.9.7.1、为什么要删除节点

(1)一直在强调，链表到底用来干嘛的？

(2)有时候链表节点中的数据不想要了，因此要删掉这个节点。

### 4.9.7.2、删除节点的2个步骤

(1)第一步：找到要删除的节点；

(2)第二步：删除这个节点。

### 4.9.7.3、如何找到待删除的节点

(1)通过遍历来查找节点。从头指针+头节点开始，顺着链表依次将各个节点拿出来，按照一定的方法比对，找到我们要删除的那个节点。

### 4.9.7.4、如何删除一个节点

(1)**待删除的节点不是尾节点的情况**:

首先把待删除的节点的前一个节点的pNext指针指向待删除的节点的后一个节点的首地址（这样就把这个节点从链表中摘出来了），

然后再将这个摘出来的节点free掉接口。

(2)**待删除的节点是尾节点的情况**：首先把待删除的尾节点的前一个节点的pNext指针指向null（这时候就相当于原来尾节点前面的一个节点变成了新的尾节点），然后将摘出来的节点free掉。

 

### 4.9.7.5、注意堆内存的释放

(1)前面几节课我们写的代码最终都没有释放堆内存。当程序都结束了的情况下那些没有free的堆内存也被释放了。

(2)有时候我们的程序运行时间很久，这时候malloc的内存如果没有free会一直被占用直到你free释放它或者整个程序终止。

 

 

 

 

//从我们链表pH中删除节点，待删除的节点的特征是数据区等于data

//方绘制：当找到并且成功删除返回0，当未找到返回-1

int delete_node(struct node *pH, int data)

{

  //找到这个待删除的节点，通过遍历链表来查找

   struct node *p = pH;     //直接走到第一个节点

   struct node *pPrev = NULL;    //用来指向当前节点的前一个节点

  while(NULL != p->pNext)

  {  

​    pPrev = p;      //保存当前指正的前一个节点；

​    p = p->pNext; 

​    

​    if(p->data == data){

​     //找到了节点，处理这个节点

​     //分为两种，一个是找到了普通节点，另一个是找到了为节点

​     //删除节点的困点在于：通过链表的遍历一次访问各个节点，找到这个节点后

​     //p指向了这个节点，但是要删除这个节点的关键要操作前一个节点，但是这个时候

​     //已经没有指针指向前一个节点了，所以没法操作。解决方案就是增加一个指正指向

​     //当前节点的前一个节点

​      if(NULL ==p->pNext){

​     //尾节点

​        pPrev->pNext = NULL;// 原来的为节点变成新的尾节点

​        free(p);      //释放删掉节点的内存

​      }else{

​      //普通节点

​        pPrev->pNext = p->pNext;//要删除的节点前一个节点和他的后一个节点相连，这样

​      //这样就把要删除的节点给摘出来了   

​        free(p);

 

​      }

 

​      //处理完成之后推出循环

​      return 0;

​    }

​         

  }

  //到这里还没找，说明链表里没有我们想要的节点  

  printf("没找到节点\n");  

  return -1; 

}

 

## 4.9.8.单链表的算法之逆序

### 4.9.8.1、什么是链表的逆序

(1)链表的逆序又叫反向，意思就是把链表中所有的**有效节点**（不包含头节点）在链表中的顺序给反过来。

 

### 4.9.8.2、单链表逆序算法分析

(1)当我们对一个数据结构进行一个操作时，我们就需要一套算法。这就是数据结构和算法的关系。

(2)我总结：算法有2个层次：

第一个层次是数学和逻辑上的算法；

第二次个层次是用编程语言来实现算法；

(3)从逻辑上来讲，链表的逆序有很多种方法。这些方法都能实现最终的需要，但是效率是不一样的。彼此的可扩展性、容错性等不同。

(4)思路：首先遍历原链表，然后将原链表中的头指针和头节点作为新链表的头指针和头节点，原链表中的有效节点挨个依次取出来，采用头插入的方法插入新链表中即可。

(5)链表逆序 = 遍历 + 头插入

 

### 4.9.8.3、编程实战

//将pH指向的链表逆序

void reverse_linklist(struct node *pH)

{

  struct node *p = pH->pNext; //pH指向头节点，p指向第一个有效节点

  struct node *pBack;     //保存当前节点的后一个节点地址

  //当链表没有有效节点或者只有一个有效节点时，逆序不用做任何操作

  if((NULL == pH->pNext)||(NULL == p->pNext))

​    return;

 

  //当链表有两个及两个一上节点时才需要真正的逆序操作；

  while(NULL != p->pNext)

  {

​    int i = 0;

​    pBack = p->pNext;

​    //原链表中第一个有效节点将是逆序后新链表的为节点，尾节点的pNext指向NULL

​    if(p == pH->pNext)

​    {

​      //原链表第一个有有效节点

​      p->pNext = NULL;

​    }

​    else

​    {

​      

​      //原链表的非第一个有效节点

​      p->pNext = pH->pNext; //后端挂接

​      pH->pNext = p;     //前端挂接

​    }

 

​    //相当于跳到下一个节点

​     p = pBack;  

  }

  //循环结束后最后一个节点丢掉了

  insert_header(pH, p);

}

 

 

## 4.9.9.双链表的引入和基本实现

### 4.9.9.1、单链表的局限性

(1)**单链表是对数组的一个扩展**，解决了数组的大小比较死板不容易扩展的问题。使用堆内存来存储数据，将数据分散到各个节点之间，其各个节点在内存中可以不相连，节点之间通过指针进行单向链接。链表中的各个节点内存不相连，有利于利用碎片化的内存。

(2)单链表各个节点之间只由一个指针单向链接，这样实现有一些局限性。局限性主要体现在单链表只能经由指针单向移动（一旦指针移动过某个节点就无法再回来，如果要再次操作这个节点除非从头指针开始再次遍历一次），因此单链表的某些操作就比较麻烦（算法比较有局限）。回忆之前单链表的所有操作（插入、删除节点、 遍历、从单链表中取某个节点的数·····），因为单链表的单向移动性导致了不少麻烦。

总结：单链表的单向移动性导致我们在操作单链表时，当前节点只能向后移动不能向前移动，因此不自由，不利于解决更复杂的算法。

 

### 4.9.9.2、解决思路：有效数据+2个指针的节点（双链表）

(1)单链表的节点 = 有效数据 + 指针（指针指向后一个节点）

(2)双向链表的节点 = 有效数据 + 2个指针（一个指向后一个节点，另一个指向前一个节点）

 

### 4.9.9.3、双链表的封装和编程实现

 

struct node

{

  int data;        //有效数据

  struct node *pPrev;   //前项指针，指向前一个节点

  struct node *pNext;   //后项指针，指向后一个节点

};

 

struct node * create_node(int data)

{

  struct node *p = (struct node *)malloc(sizeof(struct node));

  if(NULL == p)

  {

​    printf("malloc error!\n");

​    return NULL;

  }

  p->data = data;

  p->pPrev = NULL;

  p->pNext = NULL;     //默认创建的节点前项后项指正都指向NULL

 

  return p;

}

 

## 4.9.10.双链表的算法之插入节点

 

### 4.9.10.1、尾部插入

 

 

void insert_tail(struct node*pH, struct node*new)

{

  //第一步先走到链表的末尾

  struct node *p = pH;

  

 

 while(NULL != p->pNext)

  {

​    p = p->pNext;    //第一次循环走过了头节点

  }

  //循环结束后，p就指向了最后一个节点

  //第二步：将新节点插入到原来的尾节点的后面

  p->pNext = new;   //后项指针关联好了。新节点的地址和前节点的next关联起来了

  new->pPrev = p;    //后项指正关联好了。新节点的地址和前节点的prev关联借来了

​            //前节点的prev和新节点的next指针未变动

 

}

 

### 4.9.10.2、头部插入

 

//将新节点new前插入链表pH中

//算法参照图示进行连接，一共有4个指针需要赋值。注意的是顺序

void insert_header(struct node *pH, struct node *new)

{

  //新节点的next指针指向原来的第一有效节点的地址

  new->pNext = pH->pNext;

 

  //原来第一个有效节点prve指针指向新节点的地址

  if(NULL != pH->pNext)      //当链表只有头的话，这句就不执行，因为pH->pNext  指向NULL

​    pH->pNext->pPrev = new;

 

  //头节点的next指针指向新节点的地址

  pH->pNext = new;

 

  //新节点的prev指针指向头节点的地址

  new->pPrev = pH;

 

}

 

 

## 4.9.11.双链表的算法之遍历节点

(1)**双链表是单链表的一个父集**。双链表中如何完全无视pPrev指针，则双链表就变成了单链表。这就决定了双链表的正向遍历（后向遍历）和单链表是完全相同的。

(2)双链表中因为多了pPrev指针，因此双链表还可以前向遍历（从链表的尾节点向前面依次遍历直到头节点）。但是前向遍历的意义并不大，主要是因为很少有当前当了尾节点需要前向遍历的情况。

(3)总结：双链表是对单链表的一种有成本的扩展，但是这个扩展在有些时候意义不大，在另一些时候意义就比较大。因此在实践用途中要根据业务要求选择适合的链表。比若说在链表中很随意的左右移动。

 //后向遍历一个双链表

void qianxiang_bianli(struct node *pH)

{

  struct node *p = pH;

 

  while(NULL != p->pNext)

  {

​    p = p->pNext;

​    printf("data = %d.\n",p->data);

  }

 

}

 

//前向遍历，参数pTail 要指向末尾

void houxiang_bianli(struct node *pTail)

{

  struct node *p = pTail;

 

  while(NULL != p->pPrev)

  {    

​    printf("data = %d.\n",p->data);

​    p = p->pPrev;           //注意 printf 和这句的前后顺序

  }

}

 

 

 

## 4.9.12.双链表的算法之删除节点

 

 

//删除节点

int delete_node(struct node *pH, int data)

{

  struct node *p = pH;

 

  while(NULL != p->pNext)

  {      

​    p = p->pNext;  

​    //在这里判断当前节点是不是我们要删除的那个节点

​     if(p->data == data){

​      //找到了，删除。当前的上下文：当前的节点为p，

​     if(NULL == p->pNext){

​        //尾节点

​        //p表示当前节点地址，p->pNext 表示后一个节点地址，pPrve是前一个；

​        p->pPrev->pNext = NULL;

​        //p->pPrev = NULL;这句不要是因为后面free掉了这个节点，连带把这个指针销毁了

​        //销毁p节点

​        //free(p);

​      }else {

​        //不是为节点

​        //前项节点的next指针指向后一个节点的首地址

​        p->pPrev->pNext = p->pNext;

 

​        //当前接地恩的prey和next的指针都不用管，因为后面free都会整体销毁

 

​        //后一个节点prev指针指向前一个节点的首地址

​        p->pNext->pPrev = p->pPrev;

 

​        // free(p);

​      }

​     free(p);

​     return 0; 

​    }  

​           

  }

  printf("Not found!\n");

  return -1;

}

 

 

## 4.9.13.linux内核链表

### 4.9.13.1、前述链表数据区域的局限性

(1)之前定义数据区域时直接int data;我们认为我们的链表中需要存储的是一个int类型的数。但是实际上现实编程中链接中的节点不可能这么简单，而是多种多样的。

(2)一般实际项目中的链表，节点中存储的数据其实是一个结构体，这个结构体中包含若干的成员，这些成员加起来构成了我们的节点数据区域。

 

 

 

 

### 4.9.13.2、一般性解决思路：数据区封装为一个结构体

(1)因为链表实际解决的问题是多种多样的，所以内部数据区域的结构体构成也是多种多样的。这样也导致了不同程序当中的链表总体构成是多种多样的。导致的问题是：我们无法通过一个泛性的、普遍适用的操作函数来访问所有的链表。这就意味着我们设计一个链表就得写一套链表的操作函数（节点创建、插入、删除、遍历······）

(2)实际上深层次分析会发现：不同的链表虽然这些方法不能通用需要单独写，但是实际上内部的思路和方法是相同的，只是函数的局部地区有不同。（实际上链表操作是相同的，而涉及到数据区域的操作就有不同）

(3)鉴于以上2点：我们的理念就是，能不能有一种办法把所有链表中操作方法里共同的部分提取出来用一套标准方法实现，然后把不同的部分留着让具体链表的实现者自己去处理（节点创建、插入、删除、遍历······），数据那部分还是自己去写。

 

### 4.9.13.3、内核链表的设计思路

(1)内核链表中自己实现了一个纯链表（纯链表就是没有数据区域，只有前后向指针）的封装，以及纯链表的各种操作函数（节点创建、插入、删除、遍历······）。这个纯链表本身自己没有任何用处，它的用法是给我们具体链表作为核心来调用。

 

### 4.9.13.4、list.h文件简介

(1)内核中核心纯链表的实现在include/linux/list.h文件中。

(2)list.h中就是一个纯链表的完整封装，包含节点定义和各种链表操作方法。

 

 

 

 

## 4.9.14.内核链表的基本算法和使用简介

### 4.9.14.1、内核链表的节点创建、删除、遍历等

### 4.9.14.2、内核链表的使用实践

(1)问题：内核链表只有纯链表，没有数据区域，怎么使用？

(2)设计的使用方法是将内核链表作为将来整个数据结构的结构体的一个成员内嵌进去。

 

 

\#include <linux/list.h>

 

struct driver_info

{

  int data;

};

 

// driver结构体用来管理内核中的驱动

struct driver

{

  char name[20];       // 驱动名称

  int id;           // 驱动id编号

  struct driver_info info;  // 驱动信息

  struct list_head head;   // 内嵌的内核链表成员

};

 

struct driver2

{

  char name[20];       // 驱动名称

  int id;           // 驱动id编号

  struct driver_info info;  // 驱动信息

  //struct list_head head;    // 内嵌的内核链表成员

  struct driver *prev;

  struct driver *next;

};

 

// 分析driver结构体，可知：前三个成员都是数据区域成员（就是我们之前简化为int data的东西），第4个成员是一个struct list_head类型的变量，这就是一个纯链表。

// 本来driver结构体是没有链表的，也无法用链表来管理。但是我们driver内嵌的head成员本身就是一个纯链表，所以driver通过head成员给自己扩展了链表的功能。

// driver通过内嵌的方式扩展链表成员，本身不只是有了一个链表成员，关键是可以通过利用list_head本身事先实现的链表的各种操作方法来操作head。

 

// 最终效果：我们可以通过遍历head来实现driver的遍历；遍历head的函数在list.h中已经事先写好了，所以我们内核中去遍历driver时就不用重复去写了。

// 通过操作head来操作driver，实质上就是通过操作结构体的某个成员变量来操作整个结构体变量。这里面要借助container_of宏。

 

 

## 4.9.15.什么是状态机

### 4.9.15.1、有限状态机

(1)常说的状态机是**有限状态机FSM**。FSM指的是有有限个状态（一般是一个状态变量的值），这个机器同时能够从外部接收信号和信息输入，机器在接收到外部输入的信号后会综合考虑当前自己的状态和用户输入的信息，然后机器做出动作：跳转到另一个状态。

(2)考虑状态机的关键点：当前状态、外部输入、下一个状态

这个有点像水的状态，液态碰到加热变成水蒸气，但是已经处于水蒸气状态了，再加热也没有用，所以状态机步进入不仅要有外部输入、还要当前状态，以及下一个状态。

### 4.9.15.2、两种状态机：Moore型和Mealy型

(1)**Moore****型状态机特点是**：输出只与当前状态有关（与输入信号无关）。相对简单，考虑状态机的下一个状态时只需要考虑它的当前状态就行了。

(2)**Mealy****型状态机的特点是**：输出不只和当前状态有关，还与输入信号有关。状态机接收到一个输入信号需要跳转到下一个状态时，状态机综合考虑2个条件（当前状态、输入值）后才决定跳转到哪个状态。

### 4.9.15.3、状态机的主要用途：电路设计、FPGA程序设计、软件设计

(1)电路设计中广泛使用了状态机思想。

(2)FPGA程序设计，就是电路设计。FPGA是比CPU的编程高一级别的，他是写程序编译成二进制码，这个二进制码是可以改变硬件的，是硬件编程。而我们写的程序编译成二进制程序其实是CPU预先设置的机器码，而不改变硬件。

(3)软件设计（框架类型的设计，譬如操作系统的GUI系统、消息机制）

 

### 4.9.15.4、状态机解决了什么问题

(1)我们平时写程序都是顺序执行的，这种程序有个特点：程序的大体执行流程是既定的，程序的执行是遵照一定的大的方向有迹可寻的。

(2)但是偶尔会碰到这样的程序：外部不一定会按照既定流程来给程序输入信息，而程序还需要完全能够接收并响应外部的这些输入信号，还要能做出符合逻辑的输出。

 

 

## 4.9.16.C语言实现简单的状态机

### 4.9.16.1、题目

：开锁状态机。功能描述：用户连续输入正确的密码则会开锁，如果密码输入过程错误则锁会退回到初始状态重新计入密码，即：用户只需要连续输入出正确的密码即可开锁（输入错误不用撤销、也不用删除）

### 4.9.16.2、题目分析

lude<stdio.h>

 

//给状态机 定义状态集

typedef enum

{

  STATE1,

  STATE2,

  STATE3,

  STATE4,

  STATE5,

  STATE6,

  STATE7,

}STATE;




int main(void)

{

  int num = 0;

  //current_state 纪律状态急的当前状态，初始状态为STAT1

  //密码STATE就走一步，一直到STATE6后所就开；期间只要用户输入的不对，就回到STAT1

 

  STATE current_state =STATE1;    //状态急初始状态为STATE1

 

  //第一步：实现一个用户循环输入密码的循环

  printf("请输入密码，密码正确开锁\n");

  while(1)

  {

​    scanf("%d",&num);

​    //printf("num = %d\n",num);

 

​    //在这里处理用户的本次输入

​    switch(current_state)

​    {

​      case STATE1 :

​        if(num == 1)

​          {

​            current_state = STATE2;//用户对了一步，STATE走一步

​          }

​        else

​        {

​            current_state == STATE1; 

​        }break;

 

​      case STATE2 :

​        if(num == 2)

​          {

​            current_state = STATE3;//用户对了一步，STATE走一步

​          }

​      else

​        {

​            current_state == STATE1; 

​        }break;

 

​      case STATE3 :

​        if(num == 3)

​          {

​            current_state = STATE4;//用户对了一步，STATE走一步

​          }

​      else

​        {

​            current_state == STATE1; 

​        }break;

​      case STATE4 :

​        if(num == 4)

​          {

​            current_state = STATE5;//用户对了一步，STATE走一步

​          }

​      else

​        {

​            

current_state == STATE1; 

​        }break;

​      case STATE5 :

​        if(num == 5)

​          {

​            current_state = STATE6;//用户对了一步，STATE走一步

​          }

​        else

​          {

​            current_state == STATE1; 

​          }break;

​      case STATE6 :

​        if(num == 6)

​          {

​            current_state = STATE7;//用户对了一步，STATE走一步

​          }break;

​      default :

​        current_state == STATE1;

 

​    }

​    if(current_state == STATE7)

​    {

​      printf("锁开了\n");

​      break;

​    }

  }

  return 0;

}

 

 

## 4.9.17.多线程简介

### 4.9.17.1、操作系统下的并行执行机制

(1)并行就是说多个任务同时被执行。并行分微观上的并行和宏观上的并行。

(2)宏观上的并行就是从长时间段（相对于人来说）来看，多个任务是同时进行的；微观上的并行就是真的在并行执行。

(3)操作系统要求实现宏观上的并行。宏观上的并行有2种情况：第一种是微观上的串行，第二种是微观上的并行。

(4)理论来说，单核CPU本身只有一个核心，同时只能执行一条指令，这种CPU只能实现宏观上的并行，微观上一定是串行的。微观上的并行要求多核心CPU。多核CPU中的多个核心可以同时微观上执行多个指令，因此可以达到微观上的并行，从而提升宏观上的并行度。

 

### 4.9.17.2、进程和线程的区别和联系

(1)进程和线程是操作系统的两种不同软件技术，目的是实现宏观上的并行（通俗一点就是让多个程序同时在一个机器上运行，达到宏观上看起来并行执行的效果）。

(2)进程和线程在实现并行效果的原理上不同。而且这个差异和操作系统有关。譬如windows中进程和线程差异比较大，在linux中进程和线程差异不大（linux中线程就是轻量级的进程）。

(3)不管是多进程还是多线程，最终目标都是实现并行执行。

(4)简单来说，多进程适合单核CPU，多线程适合多核CPU

 

### 4.9.17.3、多线程的优势

(1)前些年多进程多一些，近些年多线程开始用得多。

(2)现代操作系统设计时考虑到了多核心CPU的优化问题，保证了：多线程程序在运行的时候，操作系统会优先将多个线程放在多个核心中分别单独运行。所以说多核心CPU给多线程程序提供了完美的运行环境。所以在多核心CPU上使用多线程程序有极大的好处。

 

### 4.9.17.4、线程同步和锁

(1)多线程程序运行时要注意线程之间的同步。

### 4.9.17.5、详细情况敬请期待：《3.linux应用编程和网络编程》

 

 

 

 

 

 

 

 

 

 



 

# 第十章 番外篇-程序员和编译器之间的暧昧

## 4.10.0 章节概要

**4.10.1.编程工作的演进史**

​    本节从编程人员的工作演进史讲起，从本质上给大家分析了编程的实质，这有助于理解程序员和程序、机器之间的关联。

**4.10.2.程序员、编译器、CPU之间的三角恋**

​    本节分析程序员、编译器和机器（CPU）之间的关系，目的是让大家从本质上认识到编译器的作用，从而理解编译器的行为和对我们写程序的约束。

**4.10.3.像编译器一样思考吧**

​    本节为总结性章节，以前面2节的分析为基础提出一个观点，程序员只有像编译器一样思考才能让自己的程序正确且更快更好的运行。

## 4.10.1.编程工作的演进史

### 4.10.1.1、CPU需要的只是1和0组成的二进制数据

(1)不管编程怎么变，最终编程得到的可执行二进制程序都是给CPU运行的。CPU需要的只是按照CPU设计时的规律（机器指令）排布的一串二进制1和0组成的数字（机器码），CPU根本不关心这些二进制是怎么来的。

(2)这些二进制可能是一个很厉害的程序员直接用1和0拼出来的；也可以是用汇编语言编写最终编译得到的；也可以是用C语言编写最终编译得到的；也可以是用java C# php bash等语言编写然后解释得到的；

(3)编程工作的演进其实一直是在**处理上一个层次段落**：就是使用何种语言编写程序（用某种语言进行编程），然后如何把这种程序源代码转成二进制（编译器的发明）。

(4)CPU接收到一串1010序列后如何工作达到目的，这就是设计制造CPU的公司要考虑的事情了，与软件工程师完全无关。

 

### 4.10.1.2、早期的纸卡打孔编程者

(1)最早期的时候，CPU也很简单，指令集很少，二进制位数也不多。那时候编译器也没被发明，编程语言也没被发明，那时候就是用二进制直接编程的。

(2)总结：最早的编程没有语言也没有编译器，程序员直接使用二进制和机器（CPU）对话。

(3)这种方式的坏处就是不容易扩展，随着CPU的进一步复杂化，指令的变多，指令位数的变多，编程难度呈几何倍数增长。人的大脑慢慢就跟不上这个节奏。

 

### 4.10.1.3、编程工作的第一次革命：由二进制机器码到汇编语言

(1)第一次革命就是：发明了汇编语言。汇编语言的本质就是用一个符号来代替一串二进制。

MOV 10101010101010

SUB 01010101010101

(2)有了汇编语言之后，程序员就不用再去记忆二进制序列了。编程时只需要用汇编指令来编程即可，汇编指令就是一个符号（符号就是由文字构成的，如MOV）。因为人类大脑天生对文字符号更加友好，因此用符号编程更简单。

(3)用汇编语言编写的源程序不能直接给CPU运行，必须通过一个翻译过程，把源代码翻译成二进制序列才能给CPU。这个翻译的过程就叫汇编，执行翻译动作的就是汇编器。

 

### 4.10.1.4、编程工作的第二次革命：由汇编语言到C语言

(1)汇编语言也有一些不尽如人意的地方，譬如：没有可移植性。在这个CPU上写的汇编程序无法直接在另一个CPU上运行。因此汇编语言是和CPU一一对应的。

(2)为了可移植性于是乎发明了高级语言。第一个高级语言就是C语言。C语言进一步靠近人的思维，为人的思维发明了很多CPU没有的东西，譬如数组。最终的目的就是降低编程难度，让高级语言更接近人的思维，然后通过编译器、汇编器等的翻译将这些源代码变成二进制然后给CPU运行。

 

### 4.10.1.5、革命无穷尽、层次变更多

(1)在C语言之上还有更高级语言，譬如：C++、Java、C#、bash等。越往上越靠近人的思维，越往上语言本身提供的封装越多，越往上编程难度越低、语言的掌握越容易。

 

 

## 4.10.2.程序员、编译器、CPU之间的三角恋

### 4.10.2.1、CPU只认识二进制机器指令

(1)CPU是最终干活的，而CPU只认识只接受二进制。

### 4.10.2.2、人类喜欢符号而不是二进制

(1)人类的大脑本身不喜欢二进制而喜欢符号、文字。

(2)人类和机器之间天生有代沟，于是乎编程不容易。

 

### 4.10.2.3、连接人（程序员）与机器（CPU）的桥梁：编译器

(1)编译器降低了编程难度。编译器的代表就是编程语言，每一种编程语言都有对应的编译器，这个编译器的作用就是把这种语言的源文件编译成可执行程序。

(2)关键是：有了编译器（高级语言）之后，我们程序员就不再盯着CPU（二进制），而是改为盯着编译器（编程语言、编程语言的语法），所以我们学习编程的关键变成了学习编译器的习性，也就是编程语言的语法。

 

### 4.10.2.4、发明一门语言关键就在于发明它的编译器

(1)编译语言的关键就是编译器。yacc和lex工具就是用来发明编程语言的。

 

### 4.10.2.5、高级语言与低级语言的差别

(1)越高级的语言越靠近人类思维；越低级的语言越靠近机器的需要。

(2)**人与机器总劳动量（总复杂度）守恒**。人要是复杂一点机器就可以简单一点；人简单一点机器就需要复杂一点。

这个规律描述的就是：编程语言越简单，人使用起来越简单，编译器设计起来就更复杂；编程语言越复杂、程序员使用起来越麻烦，则编译器设计越简单，CPU执行效率越高。

 

 

## 4.10.3.像编译器一样思考吧

### 4.10.3.1、语法是什么？语法就是编译器的习性

(1)编译器反应在编程中就是语法。

譬如1：

for (i=0; i<10; i++);

{

​    xxx;

}

 

譬如2：

int i;    !!i;

解析：!在C语言中是逻辑取反的意思，逻辑取反意思就是0取反就是1，不是0的数取反就是0.

问题：让你用C语言编程实现：如果一个数i是0则返回0，如果不是0则返回1

一般实现：                if (i == 0){return 0;} else{return 1;}

或者可以用三母运算符：      (i==0)?(0):(1);

极客式写法：              !!i;

 

### 4.10.3.2、习得一门语言就像认识一个朋友

(1)从新开始认识一个人到成为好朋友，这里面要经历：时间、共事。

(2)学习一门编程语言也需要：时间、实践（共事）。

(3)**学习C一定要写项目，而不是做题目。做题目就像在驾校学车，**

**而写项目就像在马路上开车。**

 

### 4.10.3.3、学习编程语言要懂得换位思考

(1)预处理中处理程序注释、空行。

 

 

### 4.10.3.4、注意实践中的摸索和总结

(1)要点一：在实践中

(2)要点二：摸索

(3)要点三：总结

 

 

 