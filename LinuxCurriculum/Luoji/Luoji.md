​                                                                                                                                                                                                                                                                                                                                 

[TOC]

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

# 第一章 ARM那些你得知道的事儿

## 1.1.1、.ARM的成长史  

### 1.1.1.1、ARM发展的里程碑1

•  ARM的前身为艾康电脑（Acorn），于1978年，于英国剑桥创立。

•  在1980年代晚期，苹果电脑开始与艾康电脑合作开发新版的ARM核心。

•  1985年开发出全球第一款商用RISC处理器，即ARM1.

•  1990年艾康电脑财务危机，受苹果和VLSI的投资，分割出独立子公司Advanced RISC Machines (ARM) ，ARM公司正式成立面世。

### 1.1.1.2、ARM发展的里程碑2

•  1991年，ARM推出第一款嵌入式RISC处理器，即ARM6

•  1993年，发布ARM7

•  1997年，发布ARM9TDMI

•  1999年，发布ARM9E

•  2001年，发布ARMv6架构

•  2002年，发布ARM11微架构

### 1.1.1.3、ARM发展的里程碑3

2004年，发布ARMv7架构的Cortex系列处理器，同时推出Cortex-M3

2005年，发布Cortex-A8处理器

2007年，发布Cortex-M1和Cortex-A9

2009年，实现Cortex-A9、发布Cortex-M0

2010年，推出Cortex-M4、成立Linaro，推出Cortex-A15 MPcore高性能处理器

### 1.1.1.4、 ARM发展的里程碑3

•   2011年，推出Cortex-A7，ARMv8发布

•   2012年，开始64位处理器进程

 

## 1.1.2、ARM的商业模式和生态系统

### 1.1.2.1、ARM之前的半导体圈

•  Intel、AMD、Motorola、Zilog、VIA等

•  自己设计IC、自己生产芯片、自己销售。

### 1.1.2.2、ARM的商业模式

•  ARM只负责设计IC，并且出卖自己的设计IP（版权）。

•  ARM自己不生产芯片，而是把设计IP授权给其他半导体厂商来生产芯片。

严格地说，ARM并不是一家半导体厂商

### 1.1.2.3、ARM的合作伙伴

国际大厂商：

SAMSUNG、TI、ST、

NXP、VLSI、Digital Semiconductor、 Sony、Qualcomm、HP、IBM······

中国授权厂商：

华为海思、全志、瑞芯微、MTK（中国台湾）

### 1.1.2.4ARM的启示

•  不要抱怨劣势地位，劣势可能反而是机会。

•  要想成功，先学会帮助别人、成全别人，只想着自己的人是没有机会的。

•  社会越来越成熟，成熟社会的特征就是分工不断细化。

 

## 1.1.3.为什么是三星

### 1.1.3.1为什么选择三星的CPU来讲？

•  本身使用广泛、有很好的企业应用基础

•  资料多、积累好，便于学习

•  开发板和方案商多，软硬件平台好找

•  体系很典型，适合用来学习

### 1.1.3.2三星主要的ARM CPU有哪些？

•  ARM7      44B0

•  ARM9       2440 2410  2416

•  ARM11      6410

•  A8          S5PV210  S5PC100

•  A9          4412       4418

## 1.1.4.先搞清楚各种版本号

### 1.1.4.1ARM的型号命名问题

•  ARM7和ARMv7不是一回事

•  Cortex-A9比Cortex-A7更先出来

•  型号很乱，初学者分不清哪个是哪个，比较迷茫。

### 1.1.4.2 ARM的几种版本号

•  ARM内核版本号      ARMv7

•  ARM SoC版本号      Cortex-A8

•  芯片型号        S5PV210

### 1.1.4.3ARM型号的发展历程 

​                               ![image-1.1.4.3](./image/image-20200728193557495.png)

 

 

### 1.1.4.4注意

•  ARM内核版本号和SoC版本号是由ARM确定的，而SoC型号是由半导体公司确定的。

•  Cortex系列后ARM产品线分割成3个系列，这个是市场细分的需要和选择。

•  ARM已经发布了一些64位架构如A53等，主要面向高性能服务器类应用。

•  ARM下一步重点发展方向是Cortex-M7，特点是低功耗，主要面向物联网终端。

## 1.1.5.SoC和CPU的区别&外设概念的引入

### 1.1.5.1SoC和CPU

•  SoC = System on Chip

•  芯片的发展方向：从CPU到SoC

•  现在已经没有纯粹的CPU了，都是SoC

•  ARM出卖的内核其实就是CPU（当然还需要总线），各种外设是半导体厂商自己添加的。

 ![image-20200728193804273](./image/image-20200728193804273.png)

### 1.1.5.2外设（Peripheral）

•  外设就是外部设备

•  SoC中外设大部分都跑进去了

•  网卡、音频编解码等个别还经常在外面

•  芯片设计的趋势是更大集成度，近年甚至将音视频编解码、DDR都集成进SoC内做成所谓单芯片解决方案。如海思Hi3518E

•  裸机学习其实就是学习SoC的内核（CPU，表现为汇编指令集）和各种外设（如串口）。

## 1.1.6.主流学习型主芯片介绍

### 1.1.6.1三星cpu

•  S3C44B0

•  S3C2440、S3C2410

•  S3C6410

•  S5PV210

•  Exynos4412 S5P4418

### 1.1.6.2其他半导体厂商

•  Freescale i.MX5系列

•  TI Omap系列

•  Qualcomm 骁龙系列

•  全志科技A10 A20 A31 A33等

•  行业专用型SoC如华为海思HI3518系列

### 1.1.6.3学习平台的要求

•  资料多、好找

•  应用多、有市场需求和底蕴

•  底层代码无过度封装

•  难易适中

### 1.1.6.4本课程的平台

•  SoC：三星S5PV210

•  开发板：九鼎科技X210

•  裸机实验方法：USB启动下载+SD卡启动

•  bootloader支持：uboot、xboot

•  操作系统支持：linux2.6.35、linux3.0.8、android2.3、android4.0.4

## 1.1.7.详细说说开发板这货

## 1.1.8.嵌入式和单片机的区别

### 1.1.8.1芯片平台

•  主流的单片机平台：51、PIC、STM32、AVR、MSP430等

•  主流的嵌入式平台：ARM、PPC、MIPS

### 1.1.8.2资源、价格、应用领域

•  单片机片上资源有限、价格低、应用领域多为小家电、终端设备等。

•  嵌入式系统片上资源丰富、价格较高、应用领域宽广，譬如智能手机、平板电脑、游戏机、路由器、摄像机、智能电视机、广告机、智能手表、收银机等。

### 1.1.8.3开发模式

•  单片机开发多为裸机，程序规模小，多为单个程序员独立开发。有些复杂产品也会使用高端单片机如STM32之类，并使用RTOS（uCOS、freeRTOS等）。

•  嵌入式开发几乎全部基于嵌入式操作系统，目前使用最多的是linux和Android。

### 1.1.8.4技术特征1

•  编程语言方面：单片机主要使用C语言（少量用汇编），和标准C略有不同，很少使用结构体、函数指针等C语言高级特性。而嵌入式开发较复杂，一般分底层和应用层。底层使用C语言，应用层使用C、C++、Java等语言均有。嵌入式C语言对结构体、数据结构、算法、函数指针（用来实现面向对象）等高级特性使用比较多。

### 1.1.8.5技术特征2

•  软硬件组件方面：单片机多涉及一些简单外设，譬如串口、I2C、ADC、LCD（小屏幕和分辨率）；而嵌入式系统则涉及更多复杂外设，譬如网络（有线网卡、wifi、蓝牙等）、USB、音视频编解码等。

 

 

### 1.1.8.6职业发展

•  单片机学习路线短，职业平缓，薪资发展很早达到瓶颈，一般瓶颈薪资6～8k

•  嵌入式学习路线长，职业生涯久，薪资发展多年才会达到瓶颈，一般瓶颈薪资12～15k。

## 1.1.9.嵌入式学习和编程语言、英语水平的关系

### 1.1.9.1嵌入式和编程语言

•  嵌入式开发主要使用C语言

•  辅助为汇编语言

•  中间层开发用C++多一些

•  应用层开发用C++、Java、python、tcl/tk、perl等，太多了···

### 1.1.9.2嵌入式学习和英语

•  首先，编程都是用英语写

•  关键的就是关键字

•  看数据手册可以借助桌面词典

### 1.1.9.3嵌入式学习和数电模电

•  嵌入式分嵌入式软件和嵌入式硬件两部分

•  嵌入式软件主要还是软件，硬件辅助

•  数电模电会有帮助，但不是必须

### 1.1.9.4嵌入式学习和专业

•  最适合专业：电子、自动化、通信、测控或其他名字类似的专业。

•  可以选择的专业：所有大学会开C语言或者类似编程课的理工科专业

•  找工作和专业的关系：应届生会有影响，有工作经验者不论大学专业。

### 1.1.9.5嵌入式学习到底和什么有关？

•  兴趣、志向

•  学习能力&专注度

•  态度，这个是最关键的

## 1.1.10.嵌入式系统的构成特点和演进方向

### 1.1.10.1嵌入式系统的特点

•  专用、软硬件可裁剪可配置

•  低功耗、高可靠性、高稳定性

•  软件代码短小精悍

•  代码可固化

•  实时性

•  弱交互性

•  专用开发工具及开发环境

•  专业开发人员

### 1.1.10.2嵌入式系统的组成

•  硬件

微处理器

存储器

I/O接口、输入输出设备等等

•  软件：

 嵌入式操作系统

BSP board support package板级支持包

应用软件

### 1.1.10.3嵌入式系统的发展演进1

•  以单芯片为核心、可编程控制器存在形式

没有操作系统支持

软件以汇编为主

功能单一、处理效率低、存储容器小、没有对外接口

使用简单、价格低

•  以嵌入式CPU为基础、简单操作系统为核心

CPU种类多，通用性弱

系统开销小，效率高

达到一定兼容性，拓展性

用户体验度不高，交互界面不够友好

 

### 1.1.10.4嵌入式系统的发展和演进2

•  以嵌入式操作系统为标志

兼容性好，适用于不同平台

系统开销小，效率高，具有高度模块化及拓展性

图形化界面，用户界面友好

丰富的外部接口

•  以物联网为标志

将传感器技术、互联网技术及传统嵌入式技术综合联系

小型化、智能化、网络化及可视化

低功耗、绿色环保

多核技术SWP、云计算技术及虚拟化技术

## 1.1.11.何为交叉编译

### 1.1.11.1两种开发模式

•  非嵌入式开发，A(类)机编写（源代码）、编译得到可执行程序，发布给A(类)机运行。

•  嵌入式开发，A(类)机编写（源代码）、编译得到可执行程序，发布给B(类)机运行。

### 1.1.11.2为何使用交叉编译

•  嵌入式开发的CPU比较简单，本身无法搭建开发环境，有些甚至操作系统都没有。

•  交叉编译可以用高性能机器为低性能机器开发软件（包括裸机软件、系统级和应用级软件）

### 1.1.11.3交叉编译有什么特点

•  必须使用专用的交叉编译工具链。

•  由于可执行程序不能本地运行调试，因此必须配合一定手段（专用调试器、JTAG调试器、USB下载、串口下载、SD启动、网络共享等）将可执行程序加载到目标嵌入式设备上运行及调试。

## 1.1.12.CPU的设计原理、数据总线和地址总线

### 1.1.12.1CPU和总线示意图

 

### 1.1.12.2地址总线和数据总线

•  CPU通过地址总线寻址，然后通过数据总线与外部设备互换信息。

•  地址总线的位数决定CPU寻址范围；数据总线的位数决定CPU单次通信能交换的信息数量；

•  总线的速度决定CPU和外设互换信息的速度。

 

### 1.1.12.3注意

•  CPU的地址总线位数和数据总线可以不同（典型代表就是51单片机），但是一般都相同。

•  CPU的位数指的是数据总线的位数。

•  32位CPU寻址的范围是4G，所以最多支持4G内存；

•  数据总线是32位的，所以内存是32位的好，所以编程最好用int···

## 1.1.13.为何需要Jlink、SD卡等辅助设备

### 1.1.13.1嵌入式开发特点

•  交叉编译，不便于本机运行调试程序。

•  嵌入式系统需要bootloader来启动，而bootloader必须首先存在于可启动介质中，这个过程需要专用工具。

•  嵌入式系统无法通过纯软件实现单步调试，因此必须借助专用的调试器。

### 1.1.13.2Jlink的作用

•  下载可执行程序到目标机。

•  在目标机上实现单步调试，便于开发bootloader。

### 1.1.13.3SD卡的作用

作为启动介质。工作方式是：事先用读卡器将SD卡连接到开发机（一般是Windows电脑），通过写卡软件将交叉编译得到的可执行程序镜像烧录到SD卡，然后将SD卡插入 嵌入式目标机卡槽，设置正确的启动方式启动，则系统可以从SD卡中烧录的镜像处启动。

### 1.1.13.4 USB转串口线的作用

•  串口本身用来做嵌入式目标机的调试输出，主要目的是用来监视及调试软件。

•  因为现在大部分个人电脑（大部分台式机和几乎全部的笔记本电脑）都未配置DB9串口，因此工作中一般直接使用USB转串口线来连接PC和开发板。

### 1.1.13.5其他开发辅助工具

•  USB OTG线、DB9串口、线交叉网线





 

# 第二章 ARM体系结构与汇编指令

## 1.2.0 章节概要

**1.2.1.可编程器件的编程原理**

​    本课程主要讲解可编程器件的原理，为什么有些IC不能编程控制而有些可以，目的是让大家明白CPU的设计和工作原理

**1.2.2.指令集对CPU的意义**

​    本课程主要讲解汇编指令集和CPU的本质联系，以及编程语言的发展史。目的是使大家彻底理解汇编指令集的意义以及其和高级语言的差异。

**1.2.3.RISC和CISC的区别**

​    本课程主要讲了CISC和RISC这两种不同设计的CPU，并由此进一步讲解指令集对CPU的影响和意义。

**1.2.4.统一编址&独立编址&哈佛结构&冯诺依曼结构**

​    本节主要讲2对概念：IO与内存统一编址和独立编址，哈佛结构和冯诺依曼结构。通过本节希望同学能对总线、内存等有更深刻的认识，方便后续学习。

**1.2.5.软件编程控制硬件的关键-寄存器**

​    本节正式介绍了两类寄存器：通用寄存器和特殊功能寄存器。通过寄存器的讲解，让大家明白CPU设计时软件通过寄存器来控制硬件的原理。

**1.2.6.ARM体系结构要点总结**

​    本节接以上1～5节，总结了ARM SOC的一些体系结构特点。

**1.2.7.S5PV210的内存映射详解**

​    本节讲述S5PV210的地址映射图，其中重点讲解了内存映射关系。

**1.2.8.CPU和外部存储器的接口**

​    本节讲述S5PV210的各种外部存储器接口，其中重点讲解了Flash接口。

**1.2.9.S5PV210的启动过程详解1**

​    详解S5PV210的启动过程，BL0 BL1 BL2各阶段的内容和目的。

**1.2.10.S5PV210的启动过程详解2**

​    详解S5PV210的启动过程，BL0 BL1 BL2各阶段的内容和目的。

**1.2.11.如何在开发板上选择不同启动方式**

​    结合X210开发板，讲述在开发板上如何设置各种启动模式。

**1.2.12.ARM的编程模式和7种模式**

​    讲述ARM的常规编程模式和CPU的7种工作模式。

**1.2.13.ARM的37个寄存器详解**

​    讲述ARM CPU的37个通用寄存器，各个寄存器的常规用法。

**1.2.14.ARM的异常处理方式简单介绍**

​    讲述ARM的异常处理方式，异常向量表的设计和工作原理。

**1.2.15.ARM汇编指令集1**

​    ARM汇编指令集概述，着重讲了ARM汇编的8种寻址方式。

**1.2.16.ARM汇编指令集2**

​    着重介绍ARM的ldr/str架构，指令后缀及条件执行后缀等。

**1.2.17.ARM汇编指令集3**

​    着重介绍ARM的数据传输指令、分支指令、软中断指令等。

**1.2.18.ARM汇编指令集4**

​    本节主要讲述ARM的协处理器cp15以及协处理器指令mrc和mcr。

**1.2.19.ARM汇编指令集5**

​    本节主要讲述ARM的栈操作指令和4种栈、多寄存器批量读写后缀等。

**1.2.20.ARM汇编伪指令**

​    本节主要讲述gnu汇编中常用的伪指令，着重讲了ldr、adr伪指令及其差别

## 1.2.1.可编程器件的编程原理

### 1.2.1.1电子器件的发展方向

•  模拟器件 -> 数字器件

•  ASIC -> 可编程器件

### 1.2.1.2可编程器件的特点

•  CPU在固定频率的时钟控制下节奏运行。

•  CPU可以通过总线读取外部存储设备中的二进制指令集，然后解码执行。

这些可以被CPU解码执行的二进制指令集是CPU设计的时候确定的，是CPU的设计者（ARM公司）定义的，本质上是一串由1和0组成的数字。这就是CPU的汇编指令集

### 1.2.1.3整个编程及运行过程

•  程序员用汇编指令编程 --经汇编器汇编成二进制可执行程序文件-->二进制文件被CPU读取进去-->CPU内部电路对二进制文件解码-->解码通过则CPU执行指令、完成指令动作。

•  如果程序员用C语言等高级语言编程，则编译器先将C语言程序编译为汇编程序，再进行上面的后续部分。

 

### 1.2.1.3从源代码到CPU执行过程

 

## 1.2.2.指令集对CPU的意义

### 1.2.2.1汇编语言与C等高级语言的差异

•  汇编难写，C好写

•  汇编无可移植性，C语言有一定可移植性，Java等更高级语言移植性更强。

•  汇编语言效率最高，C语言次之，Java等更高级语言效率更低。

•  汇编不适合完成大型复杂的项目，更高级语言更适合完成更大、更复杂的项目。

### 1.2.2.2汇编语言的本质

•  汇编的实质是机器指令（机器码）的助记符，是一种低级符号语言。

•  机器指令集是一款CPU的编程特征，是这款CPU的设计者制定的。CPU的内部电路设计就是为了实现这些指令集的功能。机器指令集就好象CPU的API接口一样。

### 1.2.2.3编程语言的发展过程

•  纯机器码编程

•  汇编语言编程

•  C语言编程

•  C++语言编程

•  Java C#等语言编程

•  脚本语言编程

### 1.2.2.4总结

•  汇编语言就是CPU的机器指令集的助记符，是一款CPU的本质特征。

•  不同CPU的机器指令集设计不同，因此汇编程序不能在不同CPU间互相移植。

•  使用汇编编程可以充分发挥CPU的设计特点，所以汇编编程效率最高，因此在操作系统内核中效率极其重要处都需要用汇编处理。

 

 

 

## 1.2.3.RISC和CISC的区别

### 1.2.3.1.CISC

•  complex instruction set computer复杂指令集CPU

•  CISC体系的设计理念是用最少的指令来完成任务（譬如计算乘法只需要一条MUL指令即可），因此CISC的CPU本身设计复杂、工艺复杂，但好处是编译器好设计。CISC出现较早，至今Intel还一直采用CISC设计

### 1.2.3.2RISC

•  Reduced Instruction-Set Computer精简指令集CPU

•  RISC的设计理念是让软件来完成具体的任务，CPU本身仅提供基本功能指令集。因此RISC CPU的指令集中只有很少的指令，这种设计相对于CISC，CPU的设计和工艺简单了，但是编译器的设计变难了。

### 1.2.3.3

•  早期简单CPU，指令和功能都很有限

•  CISC年代 —— CPU功能扩展依赖于指令集的扩展，实质是CPU内部组合逻辑电路的扩展。

•  RISC年代 —— CPU仅提供基础功能指令（譬如内存与寄存器通信指令，基本运算与判断指令等），功能扩展由使用CPU的人利用基础架构来灵活实现。

### 1.2.3.4RISC与CISC指令数对比

•  一般典型CISC CPU指令在300条左右

•  ARM CPU常用指令30条左右

### 1.2.3.4发展趋势

•  没有纯粹的RISC或CISC，发展方向是RISC与CISC结合，形成一种介于2者之间的CPU类型。

## 1.2.4.统一编址&独立编址&哈佛结构&冯诺依曼结构

### 1.2.4.1什么是IO？什么是内存？

•  内存是程序的运行场所，内存和CPU之间通过总线连接，CPU通过一定的地址来访问具体内存单元。

•  IO（input and output）是输入输出接口，是CPU和其他外部设备（如串口、LCD、触摸屏、LED等）之间通信的道路。一般的，IO就是指CPU的各种内部或外部外设。

### 1.2.4.2内存的访问方式

•  内存通过CPU的地址总线来寻址定位，然后通过CPU数据总线来读写。

•  CPU的地址总线的位数是CPU设计时确定的，因此一款CPU所能寻址的范围是一定的，而内存是需要占用CPU的寻址空间的。

•  内存与CPU的这种总线式连接方式是一种直接连接，优点是效率高访问快，缺点是资源有限，扩展性差。

### 1.2.4.3.IO的访问方式

•  IO指的是与CPU连接的各种外设

•  CPU访问各种外设有2种方式：一种是类似于访问内存的方式，即把外设的寄存器当作一个内存地址来读写，从而以访问内存相同的方式来操作外设，叫IO与内存统一编址方式；另一种是使用专用的CPU指令来访问某种特定外设，叫IO与内存独立编址。

### 1.2.4.4对比

•  由于内存访问频率高，因此采用总线式连接，直接地址访问，效率最高。

•  IO与内存统一编址方式，优势是IO当作内存来访问，编程简单；缺点是IO也需要占用一定的CPU地址空间，而CPU的地址空间是有限资源。

•  IO与内存独立编织方式，优势是 不占用CPU地址空间，缺点是CPU设计变复杂了。

### 1.2.4.5程序和数据

•  程序运行时两大核心元素：程序 + 数据

•  程序是我们写好的源代码经过编译、汇编之后得到的机器码，这些机器码可以拿给CPU去解码执行，CPU不会也不应该去修改程序，所以程序是只读的。

•  数据是程序运行过程中定义和产生的变量的值，是可以读写的，程序运行实际就是为了改变数据的值。

### 1.2.4.6冯诺依曼结构与哈佛结构

•  程序和数据都放在内存中，且不彼此分离的结构称为冯诺依曼结构。譬如Intel的CPU均采用冯诺依曼结构。

•  程序和数据分开独立放在不同的内存块中，彼此完全分离的结构称为哈佛结构。譬如大部分的单片机（MCS51、ARM9等）均采用哈佛结构。

### 1.2.4.7优劣对比

•  冯诺依曼结构中程序和数据不区分的放在一起，因此安全和稳定性是个问题，好处是处理起来简单。

•  哈佛结构中程序（一般放在ROM、flash中）和数据（一般放在RAM中）独立分开存放，因此好处是安全和稳定性高，缺点是软件处理复杂一些（需要统一规划链接地址等）

## 1.2.5.软件编程控制硬件的关键-寄存器

### 1.2.5.1什么是寄存器

•  寄存器属于CPU外设的硬件组成部分

•  CPU可以像访问内存一样访问寄存器

•  寄存器是CPU的硬件设计者制定的，目的是留作外设被编程控制的“活动开关”

•  正如汇编指令集是CPU的编程接口API一样，寄存器是外设硬件的软件编程接口API。使用软件编程控制某一硬件，其实就是编程读写该硬件的寄存器。

### 1.2.5.2寄存器的演示

•  请看S5PV210 datasheet

•  编程操作寄存器类似于访问内存

•  寄存器中每个bit位都有特定含义，因此编程操作时需要位操作。

•  单个寄存器的位宽一般和CPU的位宽一样，以实现最佳访问效率

### 1.2.5.3两类寄存器

•  SoC中有2类寄存器：通用寄存器和SFR

•  通用寄存器（ARM中有37个）是CPU的组成部分，CPU的很多活动都需要通用寄存器的支持和参与。

•  SFR（special function register，特殊功能寄存器）不在CPU中，而存在于CPU的外设中，我们通过访问外设的SFR来编程操控这个外设，这就是硬件编程控制的方法。

## 1.2.6.ARM体系结构要点总结

### 1.2.6.1ARM是RISC架构

•  常用ARM汇编指令只有二三十条

•  ARM是低功耗CPU

•  ARM的架构非常适合单片机、嵌入式，尤其是物联网领域；而服务器等高性能领域目前主导还是Intel

### 1.2.6.2ARM是统一编址的

•  大部分ARM（M3 M4 M7 M0 ARM9 ARM11 A8 A9等）都是32位架构

•  32位ARM CPU支持的内存少于4G，通过CPU地址总线来访问

SoC中的各种内部外设通过各自的SFR编程访问，这些SFR的访问方式类似于访问普通内存，这叫IO与内存统一编址.

### 1.2.6.3 ARM是哈佛结构的

•  常见ARM（除ARM7外）都是哈佛结构的

•  哈佛结构保证了ARM CPU运行的稳定性和安全性，因此ARM适用于嵌入式领域

•  哈佛结构也决定了ARM裸机程序（使用实地址即物理地址）的链接比较麻烦，必须使用复杂的链接脚本告知链接器如何组织程序；对于OS之上的应用（工作在虚拟地址之中）则不需考虑这么多

## 1.2.7.S5PV210的内存映射详解

### 1.2.7.1什么是内存映射？

•  S5PV210属于ARM Cortex-A8架构，32位CPU，CPU设计时就有32根地址线&32根数据线。

•  32根地址线决定了CPU的地址空间为4G，那么这4G空间如何分配使用？这个问题就是内存映射问题（好像准确点应该叫地址映射吧，我懒的改标题了，大家注意这个小坑）。

1.2.4.7.1S5PV210 datasheet中内存映射位置

 

### 1.2.4.8一些专业术语1

•  ROM：read only memory 只读存储器

•  RAM：ramdom access memory 随机访问存储器

•  IROM：internal rom 内部ROM，指的是集成到SoC内部的ROM

•  IRAM：internal ram 内部RAM，指的是集成到SoC内部的RAM

•  DRAM：dynamic ram 动态RAM

•  SRAM：static ram 静态RAM

•  SROM：static rom？ sram and rom？

•  ONENAND/NAND: 

•  SFR：special function register

•   

## 1.2.8.CPU和外部存储器的接口

### 1.2.8.1SoC常用外部存储器

•  NorFlash

•  NandFlash

•  eMMC/iNand/moviNand

•  oneNAND

•  SD卡/TF卡/MMC卡

•  eSSD

•  SATA硬盘

### 1.2.8.2、S5PV210支持的外部存储器

•  见datasheet Section2.6 booting sequence

•  见datasheet Section5全部，memory

•  见datasheet Section8.7 SD/MMC部分

### 1.2.8.3. X210开发板支持的外部存储器

•  X210有2个版本，Nand版和iNand版，分别使用Nandflash和iNand为外部存储器。我们使用的是iNand版本，板载4GB iNand

•  S5PV210共支持4个SD/MMC通道，其中通道0和2依次用作启动。X210开发板中SD/MMC0通道用于连接板载MMC，因此外部启动时只能使用SD/MMC2通道（注意通道3不能启动）。见《S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf》中P6

### 1.2.8.4总结

•  1、现代SoC支持多种外部存储器

•  2、外部存储器主要用来存储程序（可执行代码），相当于电脑的硬盘。

•  3、各种不同外部存储器原理不同，大小、性价比不同，一般产品厂家根据需要选择适合自己产品的外存使用。

•  4、外部存储器和CPU连接一般不是通过地址&数据总线直接相连，因为地址空间不够用。一般都是通过专门的接口来连接的。

## 1.2.9、 S5PV210的启动过程详解1

### 1.2.9.1 S5PV210启动过程概述

•  1、210内部有iROM和iRAM，因此启动时分两个阶段：内部启动阶段和外部启动阶段。对于内部启动阶段各种S5PV210的开发板都是相同的，对于外部启动阶段，不同开发板会有不同。

•  启动过程主要参考《S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf》

### 1.2.9.2 iROM和iRAM

•  S5PV210出厂时内置了64KB iROM和96KB iRAM。iROM中预先内置烧录了一些代码（称为iROM代码），iRAM属于SRAM（不需软件初始化，上电即可使用）。210启动时首先在内部运行iROM代码，然后由iROM代码开启外部启动流程。

•  为什么需要设计iROM和iRAM？答案是为了支持多种外部设备启动。

### 1.2.9.3 Second boot support

•  When 1 st boot mode fails, SD/MMC boot will be tried through SD/MMC channel 2 with 4-bit data

•  当第一启动模式失败时，SD/MMC卡启动模式下将会从SD/MMC2通道尝试再次启动。

这种二级启动是一种冗余设计。SoC中第一启动介质故障而导致不能启动时，可以从备用启动介质启动。我们做裸机实验时从SD2启动就是利用了这一设计特性.

### 1.2.9.4 使用iROM启动的好处

•  1、降低BOM成本。因为iROM可以使SOC从各种外设启动，因此可以省下一块boot rom（专门用来启动的rom，一般是norflash）

•  2、支持各种校验类型的nand

•  3、可以在不使用编程器的情况下使用一种外部存储器运行程序来给另一种外部存储器编程烧录。这样生产时就不用额外购买专用编程器了，降低了量产成本。

### 1.2.9.5 BL0做了什么？

•  关看门狗

•  初始化指令cache

•  初始化栈

•  初始化堆

•  初始化块设备复制函数device copy function

•  设置SoC时钟系统

•  复制BL1到内部IRAM（16KB）

•  检查BL1的校验和

•  跳转到BL1去执行

### 1.2.9.6 S5PV210的所有启动

•  先1st启动，通过OMpin选择启动介质

•  再2nd启动，从SD2

•  再Uart启动

•  再USB启动

## 1.2.10. S5PV210的启动过程详解2

## 1.2.11.如何在开发板上选择不同启动方式

​    查文档，s5PV210s，破坏inand的BootLoader，会从SD2通道启动。S5Pv210s有个开关代替了拨码开关，开关在最上方就是inand或者SD启动，而在最下方就是usb启动模式。

 

## 1.2.12.ARM的编程模式和7种模式

### 1.2.12.1 ARM的基本设定

•  ARM 采用的是32位架构.

•   ARM 约定:

​    Byte ： 8 bits

​    Halfword ：16 bits (2 byte)

Word :  32 bits (4 byte)

​    大部分ARM core 提供：

​    ARM 指令集（32-bit） 

​    Thumb 指令集（16-bit ）

​    Thumb2指令集（16 & 32bit）

•  Jazelle cores 支持 Java bytecode

### 1.2.12 .2ARM处理器工作模式

•  ARM 有7个基本工作模式:

**User** : 非特权模式，大部分任务执行在这种模式

**FIQ** :  当一个高优先级（fast) 中断产生时将会进入这种模式

**IRQ** :  当一个低优先级（normal) 中断产生时将会进入这种模式

**Supervisor** :当复位或软中断指令执行时将会进入这种模式

**Abort** : 当存取异常时将会进入这种模式

**Undef** : 当执行未定义指令时会进入这种模式

**System** : 使用和User模式相同寄存器集的特权模式

### 1.2.12.3 注意

•  除User（用户模式）是Normal（普通模式）外，其他6种都是Privilege（特权模式）。

•  Privilege中除Sys模式外，其余5种为异常模式。

•  各种模式的切换，可以是程序员通过代码主动切换（通过写CPSR寄存器）；也可以是CPU在某些情况下自动切换。

各种模式下权限和可以访问的寄存器不同。

### 1.2.12.4 CPU为什么设计这些模式？

•  CPU是硬件，OS是软件，软件的设计要依赖硬件的特性，硬件的设计要考虑软件需要，便于实现软件特性。

•  操作系统有安全级别要求，因此CPU设计多种模式是为了方便操作系统的多种角色安全等级需要。

## 1.2.13.ARM的37个寄存器详解

### 1.2.13.1 ARM 寄存器

 

 

 

 

### 1.2.13.2

•  ARM共有37个寄存器，都是32位长度

•  37个寄存器中30个为“通用”型，1个固定用作PC，一个固定用作CPSR，5个固定用作5种异常模式下的SPSR。

### 1.2.13.3 CPSR程序状态寄存器

 

•  注意：CPSR中各个bit位表明了CPU的某些状态信息，这些信息非常重要，和后面学到的汇编指令息息相关（譬如BLE指令中的E就和CPSR中的Z标志位有关）

•  CPSR中的I、F位和开中断、关中断有关

•  CPSR中的mode位（bit4～bit0共5位）决定了CPU的工作模式，在uboot代码中会使用汇编进行设置。

 

### 1.2.13.4 PC（r15）程序控制寄存器

•  PC（Program control register）为程序指针，PC指向哪里，CPU就会执行哪条指令（所以程序跳转时就是把目标地址代码放到PC中）

•  整个CPU中只有一个PC（CPSR也只有一个，但SPSR有5个）。

## 1.2.14.ARM的异常处理方式简单介绍

### 1.2.14.1 什么是异常

•  正常工作之外的流程都叫异常

•  异常会打断正在执行的工作，并且一般我们希望异常处理完成后继续回来执行原来的工作

•  中断是异常的一种

### 1.2.14.2 异常向量表

•  所有的CPU都有异常向量表，这是CPU设计时就设定好的，是硬件决定的。

•  当异常发生时，CPU会自动动作（PC跳转到异常向量处处理异常，有时伴有一些辅助动作）

•  异常向量表是硬件向软件提供的处理异常的支持。

### 1.2.14.3ARM的异常处理机制

•  当异常产生时, ARM core:

   拷贝 CPSR 到 SPSR_<mode>

设置适当的 CPSR 位： 

改变处理器状态进入 ARM 态

改变处理器模式进入相应的异常模式

设置中断禁止位禁止相应中断 (如果需要) 

保存返回地址到 LR_<mode>

设置 PC 为相应的异常向量

•  返回时, 异常处理需要:

从 SPSR_<mode>恢复CPSR

从LR_<mode>恢复PC 

Note:这些操作只能在 ARM 态执行.

1.2.14.4 总结

•  异常处理中有一些是硬件自动做的，有一些是程序员需要自己做的。需要搞清楚哪些是需要自己做的，才知道如何写代码。

•  以上说的是CPU设计时提供的异常向量表，一般成为一级向量表。有些CPU为了支持多个中断，还会提供二级中断向量表，处理思路类似于这里说的一级中断向量表。

## 1.2.15ARM汇编指令集1_2

### 1.2.15.1两个概念：指令与伪指令

•  （汇编）指令是CPU机器指令的助记符，经过编译后会得到一串10组成的机器码，可以由CPU读取执行。

•  （汇编）伪指令本质上不是指令（只是和指令一起写在代码中），它是编译器环境提供的，目的是用来指导编译过程，经过编译后伪指令最终不会生成机器码。

### 1.2.15.2 两种不同风格的ARM指令

•  ARM官方的ARM汇编风格：指令一般用大写、Windows中IDE开发环境（如ADS、MDK等）常用。如： LDR R0, [R1]

•  **GNU****风格的ARM汇编**：指令一般用小写字母、linux中常用。如：ldr r0, [r1] 

### 1.2.15.3 ARM汇编特点1：LDR/STR架构

•  ARM采用RISC架构，CPU本身不能直接读取内存，而需要先将内存中内容加载入CPU中通用寄存器中才能被CPU处理。

•  **ldr****（load register）**指令将内存内容加载入通用寄存器。

•  **str****（store register）**指令将寄存器内容存入内存空间中。

•  ldr/str组合用来实现 ARM CPU和内存数据交换

### 1.2.15.4 ARM汇编特点2：8种寻址方式

•  **寄存器寻址**          mov r1, r2  两个寄存器之间传递数据把 r2的值赋值给r1，          相当于c语言r1 = r2;

•  **立即寻址**            mov r0, #0xFF00 立即数，#号表示数字，这句指令意思是把0xFF00加载到r0中去；

•  **寄存器移位寻址**      mov r0, r1, lsl #3 将r1里的数据左移3位放入r0 

•  **寄存器间接寻址**      ldr r1, [r2]       [r2]相当于指针r2

是地址将[r2]指向的地址里的数据赋值给r1

•  **基址变址寻址**        ldr r1, [r2, #4]  

•  **多寄存器寻址**        ldmia r1!, {r2-r7, r12}

•  **堆栈寻址**            stmfd sp!, {r2-r7, lr}

•  **相对寻址**        beq flag

 

 

### 1.2.15.5 ARM汇编特点3：指令后缀

•  同一指令经常附带不同后缀，变成不同的指令。经常使用的后缀有：

•  **B****（byte）**功能不变，操作长度变为8位

•  **H****（half word）**功能不变，长度变为16位

•  **S****（signed）**功能不变，操作数变为有符号

•  如 ldr ldrb ldrh ldrsb ldrsh

•  **S****（S标志）**功能不变，影响CPSR标志位

•  如 mov和movs      movs r0, #0

### 1.2.15.6ARM汇编特点4：条件执行后缀

 

### 1.2.15.7 ARM汇编特点5：多级指令流水线

•  为增加处理器指令流的速度，ARM使用多级流水线.，下图为3级流水线工作原理示意图。（S5PV210使用13级流水线，ARM11为8级）

允许多个操作同时处理，而非顺序执行。

•  PC指向正被取指的指令，而非正在执行的指令mov(move)  

**mov r1, r0**      @两个寄存器之间数据传递

​           **mov r1, #0xff**       @ 将立即数赋值给寄存器

## 1.2.17.ARM汇编指令集3

### 1.2.17.1Mvn和mov

mvn和mov用法一样，区别是mov是原封不动的传递，而mvn是按位取反后传递

按位取反的含义：

譬如r1 = 0x000000ff，然后mov r0, r1 后，r0 = 0xff      

但是我mvn r0, r1后，r0=0xffffff00

### 1.2.17.2逻辑运算

 

and    逻辑与         

orr     逻辑或

eor     裸机异或

bic     位清除指令

 

bic  r0,r1,#0x1f       @ 将r1中的数的bit0到bit4清零后赋值给r0        

@0x1f = 0x0000001f=0x0000_11111

### 1.2.17.3、比较指令：

**cmp**            **cmp r0, r1**  等价于 sub r2, r0, r1 (r2 = r0 - r1)

**cmn           cmn r0, r1** 等价于 add r0, r1

**tst            tst r0, #0xf**  @测试r0的bit0～bit3是否全为0

teq

比较指令用来比较2个寄存器中的数

注意：比较指令不用后加s后缀就可以影响cpsr中的标志位。

 

### 1.2.17.4、cpsr和spsr的区别和联系：

cpsr是程序状态寄存器，整个SoC中只有1个；而spsr有5个，分别在5种异常模式下，作用是当从普通模式进入异常模式时，用来保存之前普通模式下的cpsr的，以在返回普通模式时恢复原来的cpsr。

 

### 1.2.17.5、合法立即数和非法立即数

合法立即数： 0x000000ff  0x00ff0000 0xf000000f 

非法立即数： 0x000001ff

## 1.2.18.ARM汇编指令集4

### 1.2.18.1协处理器cp15操作指令

•  mcr & mrc

•  mrc用于读取CP15中的寄存器

•  mcr用于写入CP15中的寄存器

### 1.2.18.2什么是协处理器

SoC内部另一处理核心，协助主CPU实现某些功能，被主CPU调用执行一定任务。

ARM设计上支持多达16个协处理器，但是一般SoC只实现其中的CP15.（cp：coprocessor）

协处理器和MMU、cache、TLB等处理有关，功能上和操作系统的虚拟地址映射、cache管理等有关。

### 1.2.18.3MRC & MCR的使用方法

•  mcr{<cond>}  p15, <opcode_1>, <Rd>, <Crn>, <Crm>, {<opcode_2>}

•  opcode_1：对于cp15永远为0

•  Rd：ARM的普通寄存器

•  Crn：cp15的寄存器，合法值是c0～c15

•  Crm：cp15的寄存器，一般均设为c0

•  opcode_2：一般省略或为0

举例（来自于uboot）

•  **mrc p15, 0, r0, c1, c0, 0**

•  **orr   r0, r0, #1**

•  **mcr p15, 0, r0, c1, c0, 0**

•  **其他见uboot源码start.S中相关代码**

### 1.2.18.4协处理器学习要点

•  不必深究，将uboot中和kernel中起始代码中的一般操作搞明白即可。

•  只看一般用法，不详细区分参数细节，否则会陷入很多复杂未知中。

关键在于理解，而不在于记住

## 1.2.19.ARM汇编指令集4

### 1.2.19.1为什么需要多寄存器访问指令

•  ldr/str每周期只能访问4字节内存，如果需要批量读取、写入内存时太慢，解决方案是stm/ldm

•  **ldm(load register mutiple)**

•  **stm（store register mutiple）**

### 1.2.19.2举例（uboot start.S 537行）

•  **stmia    sp, {r0 - r12}**

•  将r0存入sp指向的内存处（假设为0x30001000）；然后地址+4（即指向0x30001004），将r1存入该地址；然后地址再+4（指向0x30001008），将r2存入该地址······直到r12内容放入（0x3001030），指令完成。

•  一个访存周期同时完成13个寄存器的读写

### 1.2.19.3、 8种后缀

•  ia（increase after）先传输，再地址+4

•  ib（increase before）先地址+4，再传输

•  da（decrease after）先传输，再地址-4

•  db（decrease before）先地址-4，再传输

•  fd（full decrease）满递减堆栈

•  ed（empty decrease）空递减堆栈

•  fa（·······） 满递增堆栈

•  ea（·······）空递增堆栈

### 1.2.19.4、四种栈

•  空栈：栈指针指向空位，每次存入时可以直接存入然后栈指针移动一格；而取出时需要先移动一格才能取出

•  满栈：栈指针指向栈中最后一格数据，每次存入时需要先移动栈指针一格再存入；取出时可以直接取出，然后再移动栈指针

•  增栈：栈指针移动时向地址增加的方向移动的栈

•  减栈：栈指针移动时向地址减小的方向移动的栈

### 1.2.19.5、！的作用

​    •  stmfd sp!, {r0-r12,lr}

•    //再次调用真正的isr来处理中断

•    //处理完成开始恢复现在，其实就是做中断返回，关键是将r0-r12,pc,cpsr一起恢复

•    ldmfd sp!, {r0-r12,pc}^

 

•  感叹号的作用就是r0的值在ldm过程中发生的增加或者减少最后写回到r0去，也就是说ldm时会改变r0的值。

值得注意的是fd 是代表满减栈的意思 stmfd, !是地址减4，ldm !是地址加4

如果fa的话代表满增栈的意思，stmfd, !是地址加4，ldm !是地址减4

所以！是增加还是减少与 是什么栈和

### 1.2.19.5、^的作用

•  ldmfd sp!, {r0 - r6, pc}

•  ldmfd sp!, {r0 - r6, pc}^

•  ^的作用：在目标寄存器中有pc时，会同时将spsr写入到cpsr，一般用于从异常模式返回。

**总结**

批量读取或写入内存时要用ldm/stm指令

•  各种后缀以理解为主，不需记忆，最常见的是stmia和stmfd

•  谨记：操作栈时使用相同的后缀就不会出错，不管是满栈还是空栈、增栈还是减栈

## 1.2.20.ARM伪指令

### 1.2.20.1伪指令的意义

•  伪指令不是指令，伪指令和指令的根本区别是经过编译后会不会生成机器码。

•  伪指令的意义在于指导编译过程。

•  伪指令是和具体的编译器相关的，我们使用gnu工具链，因此学习gnu环境下的汇编伪指令。

### 1.2.20.2、gnu汇编中的一些符号

•  @ 用来做注释。可以在行首也可以在代码后面同一行直接跟，和C语言中//类似

•  # 做注释，一般放在行首，表示这一行都是注释而不是代码。

•  ：以冒号结尾的是标号

•  . 点号在gnu汇编中表示当前指令的地址

•  # 立即数前面要加#或$，表示这是个立即数

### 1.2.20.3、常用gnu伪指令

•  .global _start                 @ 给_start外部链接属性

•  .section .text                 @ 指定当前段为代码段

•  .ascii .byte .short .long .word 

•  .quad .float .string            @ 定义数据

•  .align 4                     @ 以16字节对齐

•  .balignl 16 0xabcdefgh         @ 16字节对齐填充

### 1.2.20.4、偶尔会用到的gnu伪指令

•  .end             @标识文件结束

•  .include          @ 头文件包含

•  .arm / .code32     @声明以下为arm指令

•  .thumb / .code16   @声明以下为thubm指令

### 1.2.20.5、最重要的几个伪指令

•  ldr      大范围的地址加载指令

•  adr  小范围的地址加载指令

•  adrl  中等范围的地址加载指令

•  nop  空操作

•  ARM中有一个ldr指令，还有一个ldr伪指令

•  一般都使用ldr伪指令而不用ldr指令

### 1.2.20.6、adr与ldr

•  adr编译时会被1条sub或add指令替代，而ldr编译时会被一条mov指令替代或者文字池方式处理；

•  adr总是以PC为基准来表示地址，因此指令本身和运行地址有关，可以用来检测程序当前的运行地址在哪里

•  ldr加载的地址和链接时给定的地址有关，由链接脚本决定。

### 1.2.20.7、 b与bl

b用于不返回的跳转，比如跳到某个标号处，b . 其中的‘.’代表当前地址，那么 b . 就是死循环。

bl用于子程序跳转，要返回地址，返回地址存于LR中。当发生bl跳转前，会在寄存器 R14 （即LR）中保存当前PC-4，即bl跳转指令的下一条指令的地址。所以在返回时只要 MOV pc,lr 。

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

# 第三章 开发板、原理图和数据手册

## 1.3.0 章节概要

**1.3.1.开发板和光盘资料简介**

​    介绍课程配套开发板X210大概情况，并且详细介绍开发板官方提供的光盘资料分布，哪些有用哪些暂时用不到。

**1.3.2.开发板硬件手册带读**

​    带着大家一起读开发板官方提供的硬件手册《X210V3硬件手册.pdf》，了解开发板的一般配置和硬件信息。

**1.3.3.开发板刷系统1**

​    安装USB转串口线驱动，使用SecureCRT做串口连接，进入系统控制台，并且破坏出厂预烧录的android系统以从SD启动

**1.3.4.开发板刷系统2**

​    制作启动SD卡，并且从SD卡启动使用fastboot烧录uboot、kernel、根文件系统等到板载iNand中（dnw工具烧录）

**1.3.5.开发板刷系统3**

​    android系统镜像烧录、linux+QT镜像的烧录

**1.3.6.X210核心板、底板原理图导读1**

​    带大家一起看开发板原理图，对原理图的一般看法、查法、作用做系统讲解，为以后学习外设编程时查原理图打好基础

**1.3.7.X210核心板、底板原理图导读2**

​    带大家一起看开发板原理图，对原理图的一般看法、查法、作用做系统讲解，为以后学习外设编程时查原理图打好基础

**1.3.8.S5PV210数据手册导读**

​    带大家一起读S5PV210的数据手册，以及其他板载硬件的数据手册的读法扩展。

**1.3.9.补充-x210的dnw刷机**

​    很多同学反映uboot擦掉后内部iNand启动失败，外部SD启动也失败，机器变砖头了···于是乎给大家增补一个dnw刷机的方式，经同学实践可以解决问题。

**1.3.10.补充-linux下使用dd命令刷写uboot**

​    有同学电脑运行不了九鼎开发板中提供的SD卡刷卡软件，于是乎希望在linux下完成刷机。这里我顺便补充下linux下使用dd命令刷写uboot到SD卡来制做SD启动卡的教程，以供大家使用。

**1.3.11.补充-X210V3S开发板刷机**

​    本节主要介绍新版开发板X210V3S开发板和X210V3的差别、刷机时使用镜像的不同

**1.3.12.补充-linux下dnw软件的使用**

​    很多同学因为数字签名问题windows下dnw不可用，因此补充讲linux下dnw工具的使用。

## 1.3.1.开发板和光盘资料简介

​    详见课程视频和光盘资料。

​    

## 1.3.2.开发板硬件手册带读

​    详见开发板光盘中《X210V3硬件手册.pdf》

​    

## 1.3.3.开发板刷系统1

### 1.3.3.1、什么是刷系统

​    刷系统就是利用刷机工具，向开发板中烧录预先编译好的系统镜像，使之在开发板上运行起来。

### 1.3.3.2、串口输出的意义（做系统控制台）

​    串口是一种硬件通信口，很多年前的时候串口是CPU之间进行通信的主要接口。但是现在因为串口通信的速度很低，所以现在串口主要是用来做程序输出监控、调试。

​    桌面电脑可以打开一个虚拟控制台，嵌入式系统一般是用串口来做控制台的。一般是用一根串口线连接开发板的串口和我们笔记本电脑的串口，然后在电脑上打开一个串口监视，这样开发板上的串口输出内容就可以在电脑上看到。还可以通过监视终端向开发板输入一些控制命令由开发板执行。常用的串口监视软件有：超级终端、SecureCRT、minicom

### 1.3.3.3、安装USB转串口线的驱动

​    本来电脑都是有串口的（DM9接口），但是现在大家都用笔记本没有串口了，所以这种串口连接线用不了。办法是使用USB转串口线，这种线传入电脑后需要安装驱动，安装驱动后在电脑上会形成一个串口（叫usb转串口），这样就相当于你电脑有了一个串口，可以通过这个串口来监视开发板的串口输出。

​    注意1：windows对USB设备的管理是和USB口有关的，你每次把usb转串口线插到1个口中，这样得到的COM口号码是不变的，方便我们后期使用。如果每次胡乱更换插口，可能得到的COM口会变。

​    注意2：COM口号码是可以改的，还可以强制占用显示“已使用”的COM号，一般改成COM4以内的就可以了。

### 1.3.3.4、使用SecureCRT

​    从网盘下载SecureCRT.rar，解压后直接使用。注册时参考解压包中的《说明.txt》。

​    打开SecureCRT.exe后，建立一个Serial连接，开始监视串口。设置参考视频中，注意流控一定要去掉。

​    开发板这边串口一定要接串口2（官方出厂默认的烧录镜像都是使用串口2的），然后开机，就可以看到串口信息了。

### 1.3.3.5、破坏iNand中的bootloader以从SD2启动

​    留待第四部分，做LED实验时再说。

​    

## 1.3.4.开发板刷系统2

### 1.3.4.0、破坏iNand中的bootloader以从SD2启动

​    busybox dd if=/dev/zero of=/dev/block/mmcblk0 bs=512 seek=1 count=1 conv=sync

​    sync



​    **解释：**这句话的意思就是说把板载的iNand的第一个扇区用全0来填充，其实就是擦除它，这样我们板载的iNand的bootloader的开始第1个扇区就被破坏了。将来启动时iROM还是会先从iNand中读取前16KB，然后计算校验和。这时候因为有1个扇区被擦掉了，所以校验和不通过，所以启动失败（会从SD2去执行2nd启动）。

​    注意：破坏板载iNand的bootloader后，不插外部SD卡，启动时串口得到：SD checksum Error

### 1.3.4.1、制作启动SD卡（其实就是烧录uboot到SD卡中）

​    有2种烧写方法：一种是在windows中用刷卡工具去制作启动SD卡；另一种是在linux中用dd命令。

​    本节介绍第一种（比较简单），刷卡工具在光盘：A盘\tools\x210_Fusing_Tool.rar

​    制作完SD后将SD卡插入开发板SD2通道（注意不是SD3），然后开机就可以进入uboot界面了。在uboot开机自动启动倒数3秒之内迅速按下电脑回车键，打断自动启动。（否则会自动启动iNand中的android）

​    

### 1.3.4.2、fastboot介绍

​    fastboot是uboot中用来快速下载镜像的一个命令，fastboot同时还是一个windows上的软件。

​    fastboot下载时要注意1：fastboot是使用USB线进行数据传输的，所以fastboot执行之前要先连接开发板和主机之间的usb线。

​    fastboot下载时要注意2：需要安装驱动。

### 1.3.4.3、fastboot驱动（X210 Android驱动）的安装

​    驱动位置：A盘\tools\USB驱动\x210_android_driver   

 

### 1.3.4.4、fastboot常用命令：

​    fastboot devices      命令用来查看当前连接的设备。（我们开发板看到的是：SMDKC110-01）

​    fastboot flash xxx     命令用来烧录的

​    fastboot reboot          命令用来重启系统

### 1.3.4.5、使用fastboot烧录android4.0.4镜像

在cmd下使用以下三个命令来完成烧录

fastboot flash bootloader android4.0/uboot.bin       烧uboot

fastboot flash kernel android4.0/zImage-android      烧linux kernel

fastboot flash system android4.0/x210.img           烧android rom

 

uboot的参数设置：set bootcmd 'movi read kernel 30008000; bootm 30008000'（默认就是这个，不用设置也行）

 

 

## 1.3.5.开发板刷系统3

### 1.3.5.1、烧录linux+QT

​    fastboot flash bootloader linuxQT/uboot_inand.bin    烧uboot

​    fastboot flash kernel linuxQT/zImage-qt                烧linux kernel

​    fastboot flash system linuxQT/rootfs_qt4.ext3         烧rootfs

uboot的参数不用特意设置（因为我们刷了专为linux+QT定制的uboot，这个uboot中估计已经预制好了所有的启动参数）

 

烧录时出现错误：

内核启动报错：Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(1,0)

在uboot中：fastboot命令下增加这一句环境变量

set bootargs console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3

 

### 1.3.5.2、烧录android2.3

​    fastboot flash bootloader android2.3/uboot.bin       烧uboot

​    fastboot flash kernel android2.3/zImage             烧linux kernel

​    fastboot flash system android2.3/x210.img           烧android rom

注意：android2.3中使用了串口0，所以启动后要把串口插到串口0中，不然串口没有任何启动信息出来。android2.3中屏幕上的logo是在左上角（也是个刷机成功的标志）

### 1.3.5.3、烧录android4.0.4

​    fastboot flash bootloader android4.0/uboot.bin       烧uboot

​    fastboot flash kernel android4.0/zImage-android      烧linux kernel

​    fastboot flash system android4.0/x210.img           烧android rom

 

## 1.3.6.X210核心板、底板原理图导读1

​    核心板、底板原理图浏览

​    写代码时需要查阅和参考的资料有：核心板原理图、底板原理图、相应硬件的数据手册、S5PV210数据手册

 

## 1.3.7.X210核心板、底板原理图导读2

### 1.3.7.1、原理图、PCB图、丝印图各自是什么

​    原理图是电路原理设计图，各个电路中的部件的逻辑连接图。原理图可能会影响软件编写

​    PCB图是我们用来制作电路板，并且用电路板进行原件焊接，做成最终产品的生产性图纸。先有原理图设计，然后根据原理图来设计PCB图。PCB4图是对原理图的一种实现。原理图和PCB图一般都由硬件工程师来负责，但是原理图设计时软件工程师会一定程度参与。PCB图的设计就完全是硬件工程师的事情了，与软件工程师无任何关系。

​    丝印图是PCB图设计中，所有原件的外框的框图。丝印图其实就是整个电路板的实体的位置图纸，与软件和功能无关，与生产制造有关。对软件工程师来说，丝印图可以不理会。

​    

### 1.3.7.2、原理图对嵌入式软件工程师的意义

​    原理图是电路的逻辑连接。对于可编程器件来说，不同的电路连接可能意味着不同的编程参数，因此底层软件工程师会需要查阅原理图的接法，从而决定自己的软件怎么写才能正确和硬件通信。

 

### 1.3.7.3、嵌入式软件开发人员对硬件掌握程度的要求

​    对软件工程师来说，硬件究竟有没有必要会？会到什么程度？影响有多大？

​    软件工程师分应用开发和底层开发两大块。对于应用开发工程师（直接基于操作系统来开发程序，调用操作系统的APi和库函数等写代码）来说，硬件完全被操作系统屏蔽了，可以完全不关心硬件；但是对于底层软件工程师（驱动开发的、单片机的、移植操作系统的）来说，看懂原理图和数据手册是非常有必要的，PCB图就没必要会了。

​    注意：一般来说，总工程师都是软硬都会的，这个人一般软件硬件都做过。所以对大家来说，如果时间很充裕，或者完全有条件，不妨都学习一点（学习是有轻重的）；如果时间比较紧，着急工作，或者完全不感兴趣，那就不要看了。

​    

## 1.3.8.S5PV210数据手册导读  

### 1.3.8.1、datasheet（数据手册）的作用

​    数据手册就是产品（一般是芯片）厂家编写的，对这个产品的所有功能和用法的描述统一说明的文档。

### 1.3.8.2、数据手册的正确读法：先通读概览，然后根据需要去查阅。

### 1.3.8.3、学会利用文档目录。

### 1.3.8.4、利用好pdf阅读器的搜索功能。

 

## 1.3.9.补充-x210的dnw刷机

### 1.3.9.1、背景

​    1 之前讲第三部分的时候只讲了SD卡刷机，并没有讲usb启动刷机（dnw刷机）。因为sd卡刷机较简单，dnw刷机较麻烦。

​    2 有同学刷错了uboot，错刷成了nand版本的uboot（还有些确实没刷错uboot），这时候在uboot中执行了movi write u-boot 0x30000000后，再次开机碰到诡异现象：串口输出乱码、SD卡不启动。以为开发板变砖头了。这时候的解决思路就是dnw刷机。

​    3 第四部分（1.4.ARM裸机第四部分-GPIO和LED）的第一节课已经讲过了dnw下载裸机程序（dnw的介绍，dnw驱动的安装，配置下载地址的方法），大家可以先看这节课，然后再来看本节。

### 1.3.9.2、刷机准备

​    1 看x210 dnw刷机.txt，按照其中进行操作

​    2 事先把开发板启动方式拨到usb启动。OM5打到VCC就能从usb启动

​    3 两个刷机文件x210_usb.bin 和 uboot.bin 准备好。

### 1.3.9.3、刷机

​    刷机分2步：第一步刷x210_usb.bin，地址是0xd0020010;第二步刷uboot.bin，刷机地址是0x23e00000

​    uboot启动起来后，先fdisk -c 0去重新分区，然后再fastboot·······

 

## 1.3.10.补充-linux下使用dd命令刷写uboot

### 1.3.10.1、SD卡连接入linux中

​    首先得搞清楚：一个USB设备插到电脑后，要么可以在Windows中识别，此时不能在虚拟机linux中识别；要么能在linux中识别，但是在windows中又不见了。默认的一般都是连在Windows中的，所以linux是找不到的。

​    如果你需要将该设备连接到linux中，需要在VMware软件的菜单“虚拟机 -> 可移动设备”中点选该设备，选择连接

​    

​    连接进linux中，在命令行中：ls /dev/sd*查看，和之前对比，就知道我们的SD卡在linux中的设备编号了。一般是/dev/sdb

​    也有可能是sdc或者其他。我们后面的实验是基于这个设备号是/dev/sdb的，如果不是，后面的实验要相应做修改。

### 1.3.10.2、制作SD启动卡

​    执行 ./nand_fusing.sh /dev/sdb

### 1.3.10.3、使用SD卡启动

​    先确定开发板是从SD卡启动的

​    然后确定板子内的iNand中的uboot是被破坏的，不能启动的。

​    SD卡插入SD2通道，启动即可。启动后（看有没必要fdisk -c 0来分区）使用fastboot继续刷机。

 

 

## 1.3.11.补充-X210V3S开发板刷机

### 1.3.11.1、背景介绍

(1)很多人刷机失败，苦恼甚至放弃学习

(2)刷机的目的和意义搞清楚

(3)开发板的各个版本，以及版本差异。

### 1.3.11.2、刷机常见问题及分析处理

(1)屏幕显示异常，原因是刷成了旧版本开发板的镜像。解决方案就是用新版本镜像。

(2)dnw驱动装不上，多试几次，禁用数字签名

(3)fastboot驱动装不上，多试几次，windows联网自动安装，用360手机助手之类的工具安装

(4)找不到拨码开关，不知道如何设置USB启动

(5)dnw下载uboot.bin时进度条不动，卡住，禁用数字签名+右键管理员权限运行dnw软件，换电脑，使用linux下dnw软件。

(6)dnw下载uboot.bin后串口没有任何信息输出。可能性1：串口插错了；可能性2：uboot.bin用错了。解决方案：换串口插试试（正确的是用串口2），用正确的uboot.bin。

(7)执行了movi write u-boot 0x30000000后变砖了，解决方案就是dnw刷机。

(8)Windows不提示安装驱动。如果开发板中就在运行uboot或者linux+QT，这时候插上USB线主机Windows也不会发现开发板；当我们uboot下执行了fastboot命令后主机就会提示装fastboot驱动。当开发板运行了android系统后主机就会提示装fastboot驱动；当开发板设置了USB启动并且重启时就会提示装dnw驱动。

(9)android系统刷机成功启动不成功。最大可能性还是镜像用的不对。

 

### 1.3.11.3、正确的镜像位置

(1)网盘\朱老师物联网大讲堂-全部视频\朱有鹏老师嵌入式linux核心课程\不同版本开发板刷机看这里

(2)老开发板X210V3

(3)新开发板X210V3S

(4)更新一批

 

 

## 1.3.12.补充-linux下dnw软件的使用

### 1.3.12.1、linux下dnw获取

(1)源码包获取

(2)编译和安装

### 1.3.12.2、开发板连接到linux下

(1)开发板设置USB启动，开机，windows设备管理器中提示发现新硬件

(2)VMware菜单：虚拟机->可移动设备->Samsung S5PC110 SEC Test B/D，点击连接

(3)成功连接后现象：1、Windows下设备管理器没了；2、ls /dev/secbulk0 设备节点自动出现

### 1.3.12.3、使用dnw进行下载uboot.bin

(1)dnw -a 0xd0020010 x210_usb.bin 

(2)dnw -a 0x23e00000 uboot.bin

成功标志：SecureCRT中成功看到了uboot的启动信息，并且进入了uboot命令行。

### 1.3.12.4、uboot启动后的刷机注意事项

(1)正确的uboot启动后一定要先fdisk -c 0进行分区，然后再fastboot

(2)uboot的参数中bootcmd和bootargs一定要正确。

set bootcmd 'movi read kernel 30008000; bootm 30008000'

set bootargs console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3



 



# 第四章 GPIO和LED

## 1.4.0章节概要

**1.4.1.裸机实验体验之usb启动配合dnw工具下载**

​    本节的主要目的是学会从usb启动，然后使用dnw工具下载裸机程序bin文件到开发板内部SRAM执行。学完本节要求大家能够使用usb启动方式进行裸机程序调试，以方便后面测试自己写的代码（本节会提供我编译好的led.bin）。

**1.4.2.裸机实验体验之SD卡下载**

​    本节的主要目的是学会设置开发板从SD2启动（需要事先将板载SD0通道的iNand上的bootloader破坏掉），并且学会在Windows中使用烧录软件、linux中使用dd命令2种方式来制作启动SD卡。学完本节要求大家能够使用SD卡启动方式进行裸机程序的调试，以方便后面测试自己写的代码（本节会提供我编译好的led.bin）。

**1.4.3.自己动手安装交叉编译工具链1**

​    本节首先介绍linux中装软件和windows中的不同，然后手把手教大家从零开始自己动手安装交叉编译工具链并作测试。

**1.4.4.自己动手安装交叉编译工具链2**

​    本节接上节讲解如何将安装的交叉编译工具链导出到环境变量，并且为工具链制作arm-linux-符号链接。

**1.4.5.Makefile大侠隆重登场**   

​    本节给大家引入Makefile，并且ubuntu环境下简单介绍Makefile的书写，目标、依赖等基本概念，最后分析了我们在裸机程序中使用到的Makefile。本节学完要求大家理解Makefile的基本用法，会自己根据需要修改Makefile。

**1.4.6.mkv210_image.c文件详解1**

​    本节回顾第三部分中讲到的S5PV210启动知识，并且分析SD卡启动时头信息的技术要求，然后引入mkv210_image.c文件并作简单分析。

**1.4.7.mkv210_image.c文件详解2**      

​    本节接上节继续详细分析mkv210_image.c文件的技术细节，目的是使大家深入理解本文件中C程序的工作原理和实现技巧。

**1.4.8.一步步点亮LED1_硬件工作原理及原理图查阅**

​    本节从LED工作原理讲起，通过查阅原理图分析点亮LED的原理和方法。

**1.4.9.一步步点亮LED2_数据手册查阅及相关寄存器浏览**

​    本节接上节内容，查阅SoC数据手册中GPIO寄存器部分，找到板子上LED对应的GPIO并分析操作方法。

**1.4.10.一步步点亮LED3_从零开始手写汇编点亮LED**

​    本节开始写我们第一个汇编程序，从零开始用最少的代码点亮LED，并且使用之前讲过的Makefile编译，然后使用之前实践过的下载方法下载运行测试。至此，本章点亮LED的目标已经实现。

**1.4.11.一步步点亮LED4_使用位运算实现复杂点亮要求**

​    本节以上节的汇编代码为基础，进行必要修改，使用位运算的技巧来实现一些复杂的电灯要求（譬如隔一个亮一个）。学完本节要求大家对位运算有一定掌握，并基本掌握使用位运算来操作SoC寄存器

**1.4.12.一步步点亮LED5_汇编编写延时函数并实现LED闪烁效果**

​    本节接上节并继续复杂化。引入汇编编写的延时函数，并通过延时达到LED闪烁显示的效果。本节学习的目的是加深大家对汇编编程的理解，学会用汇编来写函数并调用之，为以后编写复杂汇编程序打基础。

**1.4.13.一步步点亮LED6_再难一点的流水灯效果**

​    本节是点亮LED的最后一节了，实现的效果是流水灯（跑马灯）。有了以上章节的学习，本节任务应该不难实现。

**1.4.14.反汇编工具objdump的使用简介**

​    本节介绍交叉编译工具链中的反汇编工具objdump。该工具是我们后面理解和分析链接地址、链接脚本的利器，在这里给大家先认识下，方便以后引入使用。

## 1.4.1.裸机实验体验之usb启动配合dnw工具下载

### 1.4.1.1、背景知识介绍

​    回顾S5PV210的启动方式，必须将OM5打到VCC，才能从USB启动。

​    S5PV210的启动过程：开机时先执行内部的iROM中的BL0，然后BL0做了一系列的初始化后，再读取外部OMpin的设置来确定用户选择了从哪里启动。当检测到我们设置的是USB启动时，S5PV210就会从USB OTG接口试图连接主机进行下载启动。

### 1.4.1.2、dnw工具介绍

​    dnw是一个软件，是三星公司编写的，这个软件的功能是通过USB线连接开发板和电脑主机，然后从主机下载文件镜像到开发板中去烧录系统。

​    dnw软件使用注意1：dnw是需要装usb驱动的，驱动在“X210光盘资料\A盘\tools\USB驱动”目录中

​    dnw软件使用注意2：dnw使用时通过usb线下载，所以一定要插USB线。

​    dnw软件使用注意3：dnw下载时需要设置dnw下载内存地址。在dnw软件的菜单“Configuration”中设置

​                     Download Address为0xd0020010，确认即可。

### 1.4.1.3、dnw驱动安装

​    X210开发板使用了软开关，但是我们这里还没到操作系统没去处理开关，所以在整个裸机实验中必须手工按下POWER键才能保持开机，只要手一抬起来就关机了····

​    dnw驱动装好的标志是：开发板开机从usb启动后，设备管理器中显示已经安装的设备，并且关键是dnw工具中USB:OK

### 1.4.1.4、裸机程序下载地址设置

​    从usb启动做裸机实验时，因为不需要16字节的校验头，所以直接下载到0xd0020010

### 1.4.1.5、usb启动裸机实验总结

​    usb启动方式主要是用来调试程序的，其实分析S5PV210即可知道，我们这里是把裸机程序当作BL1来使用了。

 

扩充知识：Win7 X64版本驱动安装非常麻烦，因为微软启用了USB设备驱动签名政策。

 

 

## 1.4.2.裸机实验体验之SD卡下载

### 1.4.2.1、背景知识

​    一般情况下，用USB下载来调试裸机程序比较方便；但是有时候电脑使用dnw会频繁蓝屏，这时候用SD卡下载调试是不错选择。

​    把OM5打开GND，以从SD通道启动。

​    从SD启动时会先从iNand（SD0）启动执行，当iNand启动做校验和时失败才会转为启动SD2。而我们做裸机实验时是通过SD2来提供裸机程序镜像的，因此需要先破坏内部iNand的uboot才可以强迫开发板从SD2启动去执行我们的裸机程序。

### 1.4.2.2、擦除开发板iNand中的uboot的方法

​    在linux和android系统下，擦除uboot的方法：

​    busybox dd if=/dev/zero of=/dev/block/mmcblk0 bs=512 seek=1 count=1 conv=sync

​    sync

​    在uboot底下如何擦除uboot：movi write u-boot 0x30000000

### 1.4.2.2、Windows下制作启动SD卡

​    方法等同于我们第三部分讲过的SD卡刷机时的操作

### 1.4.2.3、linux下制作启动SD卡

​    后面章节再演示。

​    

总结：SD卡启动和usb启动优劣势对比：如果你的电脑本身支持usb启动下载而且不蓝屏，建议以后做实验用usb下载调试；

 

 

## 1.4.3.自己动手安装交叉编译工具链1

### 1.4.3.1、Windows中装软件的特点

​    Windows中装软件使用安装包，安装包解压后有2种情况：一种是一个安装文件（.exe .msi），双击进行安装，下一步直到安装完毕。安装完毕后会在桌面上生成快捷方式，我们平时使用快捷方式来启动这些程序；另一种是所谓的绿色软件、免安装软件。这种不用安装，直接解压开里面就有exe可以直接双击执行。

### 1.4.3.2、linux中装软件的特点

​    linux中安装软件比windows中复杂。linux中安装软件一般有以下几种方法：

​    第一种：在线安装。譬如ubuntu中使用apt-get install vim来安装vim软件。

​    第二种：自己下载安装包来安装。这种方式的缺陷就是你不知道你下载的安装包和你的系统是否匹配。

​    第三种：最装逼的一种方式，就是源代码安装。

​    总结：我们安装交叉编译工具链（arm-linux-gcc）实际采用第二种安装方式。

### 1.4.3.3、交叉编译工具链的选择

​    我们选择交叉编译工具链的原则：和我们所使用的目标平台（给哪款SoC编程）尽量去匹配。譬如我们开发S5PV210的程序就是用arm-2009q3这个版本，因为三星官方在开发S5pv210时就使用这个版本的交叉编译工具链，这样可以最大限度的避免稀奇古怪的问题出现。

### 1.4.3.4、交叉编译工具链的安装

​    步骤1：打开虚拟机，在/usr/local/下创建/usr/local/arm文件夹

​    步骤2：先将安装包从Windows中弄到linux中去。可以用共享文件夹，也可以用Samba，也可以cuteftp。

 

​    步骤3：解压。**tar -jxvf arm-2009q3.tar.bz2**

​    到此相当于程序已经安装完毕，真正的应用程序安装在/usr/local/arm/arm-2009q3/bin目

​    

注：linux中的目录管理方法。技术角度来讲，linux中所有目录性质都是一样的，所以技术角度来讲我们把软件安装到哪里都行。但是因为如果胡乱放置，将来程序可能不好找。所以久而久之大家就总结了一个文件放置的一般定义，譬如说/bin目录放置一些系统自带的用户使用的应用程序，/sbin目录下存放的是系统自带的系统管理方面的应用程序。

那我们装软件放在哪里？一般都在/usr目录下。我们安装arm-linux-gcc，就在/usr/local/底下创建一个arm文件夹，然后装到里面。

### 1.4.3.5、安装后的测试

​    到真正的应用程序的安装目录下（也就是/usr/local/arm/arm-2009q3/bin），去执行arm-linux-gcc -v

​    执行方法是：./arm-none-linux-gnueabi-gcc -v

​    执行后可以得到一长串输出，其中有“gcc version 4.4.1 ”字样，即表示安装成功。

 

## 1.4.4.自己动手安装交叉编译工具链2

### 1.4.3.1、环境变量的意义

​    环境变量就是操作系统的全局变量。每一个环境变量对操作系统来说都是唯一的，名字和所代表的意义都是唯一的。linux系统可以有很多个环境变量。其中有一部分是linux系统自带的，还有一些是我们自己来扩充的。我们这里涉及到的一个环境变量是

​    PATH。PATH这个环境变量是系统自带的，它的含义就是系统在查找可执行程序时会搜索的路径范围。

### 1.4.3.2、将工具链导出到环境变量

​    **export PATH=/usr/local/arm/arm-2009q3/bin:$PATH**

​    在一个终端中执行以上命令后，该终端中就可以直接使用arm-linux-gcc了，但是只要关掉这个终端再另外打开一个立马就不行了。原因是我们本次终端中执行时的操作只是针对本终端，以后再打开的终端并未被执行过这个命令所以没导出。

​    解决方案是在**~/.bashrc**中，添加export PATH=/usr/local/arm/arm-2009q3/bin:$PATH 即可。

注意：我们导出这个环境变量是在当前用户，如果你登录时在其他用户下是没用的。

 

### 1.4.3.3、为工具链创建arm-linux-xxx符号链接

​    ln arm-none-linux-gnueabi-addr2line -s arm-linux-addr2line

 

## 1.4.5.Makefile大侠隆重登场

### 1.4.5.1、为什么需要Makefile

​    Makefile是用来管理工程的。

​    在一个正式的软件项目中，由很多个.c和.h文件构成，此时如果直接在命令行编译，就会像这样：gcc a.c b.c c.c d.c e.c f.c g.c -o exe      每次编译都要输入一堆东西很麻烦，这个问题严重影响工作效率，怎么办？Makefile来解决

### 1.4.5.2、一个简单的Makefile示例

​    见光盘下载文件夹下面的 随堂代码/1.4.5/Makefile1和Makefile2

### 1.4.5.3、Makefile中的一些基本概念

​    目标：目标定格写，后面是冒号（冒号后面是依赖）

​    依赖：依赖是用来产生目标的原材料。

​    命令：命令前面一定是Tab，不能是定格，也不能说多个空格。命令就是要生成那个目标需要做的动作。

### 1.4.5.4、Makefile的基本工作原理

​    其一，当我们执行 make xx 的时候，Makefile会自动执行xx这个目标下面的命令语句。

​    其二，当我们make xx的时候，是否执行命令是取决于依赖的。依赖如果成立就会执行命令，否则不执行。

​    其三，我们直接执行make 和make 第一个目标 效果是一样的。（第一个目标其实就是默认目标）

### 1.4.5.5、ARM裸机中用到的Makefile介绍

 

### 1.4.5.6、进一步学习Makefile的资料

​    我们学习Makefile的思路就是：先学会基本的概念和应用，先理解Makefile的概念和使用方法、工作原理。先自己会写简单的Makefile来管理工程。一般先学到这里就可以了，更深入的内容可以随同稍后的课程一起来学习，我们讲到课程的时候会再次提及并且逐步深入。

​    对于我们有一定基础的同学，同时还有时间，可以深入学习Makefile，看《跟我一起学Makefile》（作者：陈皓）

​    

## 1.4.6.mkv210_image.c文件详解1

### 2.4.6.1、mkv210_image.c的使用演示

​    裸机程序中的Makefile（实际上真正的项目的Makefile都是这样的）是把程序的编译和链接过程分开的。（平时我们用gcc a.c -o exe这种方式来编译时，实际上把编译和链接过程一步完成了。在内部实际上编译和链接永远是分开独立进行的，编译要使用编译器gcc，链接要使用链接器ld）

​    链接器得到led.elf其实就是我们的可执行程序，（如果是在操作系统下，这个led.elf就可以执行了）但是在嵌入式裸机中我们需要的是可以烧写的文件（可烧写的文件就叫镜像image），因此我们需要用这个led.elf为原材料来制作镜像，制作工具是交叉编译工具链中的arm-linux-objcopy

​    我们使用arm-linux-objdump工具进行反编译（反汇编），反汇编其实就是把编译后的elf格式的可执行程序给反过来的到对应的汇编程序，的到它的汇编源代码。我们使用反汇编主要是用来学习，见本部分最后一节。

​    mkv210_image.c这个程序其实最终不是在开发板上执行的，而是在主机linux（就是用来执行make对整个项目进行编译的那个机器）中执行的，因此编译这个程序用gcc而不是用arm-linux-gcc。这个.c文件编译后得到一个可执行程序mkmini210，目的是通过执行这个mkmini210程序而由led.bin得到210.bin。（210.bin是通过SD卡启动时的裸机镜像，这个镜像需要由led.bin来加工的到，加工的具体方法和原理要看mkv210_image.c）

​    

### 1.4.6.2、背景知识：S5PV210的启动过程回顾

​    分析启动过程可知；210启动后先执行内部iROM中的BL0，BL0执行完后会根据OMpin的配置选择一个外部设备来启动（有很多，我们实际使用的有2个：usb启动和SD卡启动）。在usb启动时内部BL0读取到BL1后不做校验，直接从BL1的实质内部0xd0020010开始执行，因此usb启动的景象led.bin不需要头信息，因此我们从usb启动时直接将镜像下载到0xd0020010去执行即可，不管头信息了；从SD启动时，BL0会首先读取sd卡得到完整的镜像（完整指的是led.bin和16字节的头），然后BL0会自己根据你的实际镜像（指led.bin）来计算一个校验和checksum，然后和你完整镜像的头部中的checksum来比对。如果对应则执行BL1，如果不对应则启动失败（会转入执行2st启动，即SD2启动。如果这里已经是2st启动了，这里校验通不过就死定了）。

### 1.4.6.3、mkv210_image.c的作用：为BL1添加校验头

​    我们编译链接时只得到了led.bin，这个210.bin的得到和交叉编译工具链是完全无关的。由led.bin得到210.bin的过程是三星的S5PV210所特有的，因此需要我们自己去完成，为此我们写了mkv210_image.c来完成。

1.4.6.4、整个程序工作流分析

​    整个程序中首先申请一个16KB大小的buffer，然后把所有内容按照各自的位置填充进去，最终把填充好的buffer写入到一个文件（名叫210.bin）就形成了我们想要的镜像。

 

## 1.4.7.mkv210_image.c文件详解2

### 1.4.7.1、代码详解

​    第1步：检验用户传参是不是3个。

​    第2步：分配16K Bbuffer并且填充为0.

​    第3步：·········

​    

### 1.4.7.2、main函数两个形参的作用

​    main函数接收2个形参：argc和argv。

​    argc是用户（通过命令行来）执行这个程序时，实际传递的参数个数。注意这个个数是包含程序执行本身的

​    argv是一个字符串数组，这个数组中存储的字符串就是一个个的传参。

​    譬如我们执行程序时使用./mkx210 led.bin 210.bin

​    则argc = 3

​    则argv[0] = "./mkx210" argv[1] = led.bin argv[2] = 210.bin

### 1.4.7.3、glibc读写文件接口

​    linux中要读取一个文件，可以使用fopen打开文件，fread读取文件，读完之后fclose关闭文件。

​    要写文件用fwrite来写。这些函数是glibc的库函数，在linux中用man 3 可以查找。

​    如果你本身就知道这些函数的用法，只是记不起来可以man查找；如果你本身根本就不会用这些接口，建议先去baidu。

### 1.4.7.4、校验和的计算方法

​    算法：校验和其实就是需要校验的内存区域中，所有内存中的内容按照字节为单位来进行相加，最终相加的和极为校验和。

​    实现时大家要注意指针的类型为char *

 

## 1.4.8.一步步点亮LED1_硬件工作原理及原理图查阅

### 1.4.8.1、LED物理特性介绍

​    LED本身有2个接线点，一个是LED的正极，一个是LED的负极。LED这个硬件的功能就是点亮或者不亮，物理上想要点亮一颗LED只需要给他的正负极上加正电压即可，要熄灭一颗LED只需要去掉电压即可。

### 1.4.8.2、查阅原理图了解板载LED硬件接法

​    查阅原理图，发现开发板上一共有5颗LED。其中一颗D26的接法是：正极接5V，负极接地。因此这颗LED只要上电就会常亮。因此我们分析这颗LED是电源指示灯。

​    剩下4颗LED的接法是：正极接3.3V，负极接了SoC上的一个引脚（GPIO），具体详细接法是：

​    D22：GPJ0_3

​    D23：GPJ0_4

​    D24：GPJ0_5

​    D25：PWMTOUT1(GPD0_1)    

### 1.4.8.3、分析如何点亮及熄灭LED（GPIO）

​    分析：LED点亮的要求是：正极和负极之间有正向电压差。

​    思考：在开发板上如何为LED制造这个电压差让它点亮呢？

​    解答：因为正极已经定了（3.3V），而负极接在了SoC的引脚上，可以通过SoC中编程来控制负极的电压值，因此我们可以通过程序控制负极输出低电平（0V），这样在正负极上就有了压差，LED即可点亮。

 

## 1.4.9.一步步点亮LED2_数据手册查阅及相关寄存器浏览

### 1.4.9.1、GPIO概念的引入

​    GPIO:general purpose input output 通用输入输出

​    GPIO就是芯片的引脚（芯片上的引脚有些不是GPIO，只有一部分是），作为GPIO的这类引脚，他的功能和特点是可以被编程控制它的工作模式，也可以编程控制他的电压高低等。

​    通过之前的分析我们知道，我们设计电路时就把LED接在了一个GPIO上，这样我们就可以通过编程控制GPIO的模式和输入输出值来操控LED亮还是灭；如果你当时设计电路时把LED接在非GPIO上那就不可能了。

### 1.4.9.2、阅读数据手册中有关部分

​    当我们想要通过编程操控GPIO来操作LED时，我们首先需要通读一下S5PV210的数据手册中有关于GPIO的部分，这部分在数据手册的Section2.2中。

​    

### 1.4.9.3、GPIO相关的寄存器介绍

​    回忆下之前说过的，软件操作硬件的接口是：寄存器。

​    我们当前要操作的硬件是LED，但是LED实际是通过GPIO来间接控制的，所以当前我们实际要操作的设备其实是SoC的GPIO。要操作这些GPIO，必须通过设置他们的寄存器。

​    

​    查阅数据手册可知，GPJ0相关的寄存器有以下：

​    GPJ0CON, （GPJ0 control）GPJ0控制寄存器，用来配置各引脚的工作模式   

​    GPJ0DAT, （GPJ0 data）当引脚配置为input/output模式时，寄存器的相应位和引脚的电平高低相对应。

​    GPJ0PUD, （pull up down）控制引脚内部弱上拉、下拉

​    GPJ0DRV, （driver）配置GPIO引脚的驱动能力

​    GPJ0CONPDN，（记得是低功耗模式下的控制寄存器）

​    GPJ0PUDPDN （记得是低功耗模式下的上下拉寄存器）

​    注：在驱动LED点亮时，应该将GPIO配置为output模式。

​    

​    实际上真正操控LED的硬件，主要的有：GPJ0CON, GPJ0DAT 这么2个。

​    如何点亮LED，编程的步骤是：

​    1、操控GPJ0CON寄存器中，选中output模式

​    2、操控GPJ0DAT寄存器，相应的位设置为0

​    

​    

## 1.4.10.一步步点亮LED3_从零开始手写汇编点亮LED

### 1.4.10.1、GPxCON、GPxDAT寄存器分析

​    GPJ0端口一共有8个引脚，分别记住：GPJ0_0 ～ GPJ0_7，相关重要寄存器就是GPJ0CON和GPJ0DAT

​    GPJ0CON寄存器中设置8个引脚的工作模式（32/8=4，每个引脚可以分到4位，譬如GPJ0_0对应的bit位为bit0~bit3，GPJ0_3对应的位为bit12~bit15。工作方法是：给相应的寄存器位写入相应的值，该引脚硬件就会按照相应的模式去工作。譬如给bit12～bit15写入0b0001，GPJ0_3引脚就成为输出模式了）

### 1.4.10.2、从零开始写代码操作寄存器

​    需要哪些先决条件才能写呢？

​    \1. 硬件接法和引脚：GPJ0_3 GPJ0_4 GPJ0_5  低电平亮/高电平灭

​    \2. GPJ0CON（0xE0200240）寄存器和GPJ0DAT（0xE0200244）寄存器

​    \3. 工程管理：Makefile等

​    根据以上分析，我们就知道代码的写法了，代码所要完成的动作就是：

​    把相应的配置数据写入相应的寄存器即可。

### 1.4.10.3、编译、下载、运行看结果

​    编译时用我们的工程管理，直接make编译得到led.bin和210.bin

​    下载运行可以用usb启动dnw下载；也可以用sd卡烧录下载，根据自己的情况用

​    一般都用usb下载，因为方便。如果电脑主板插上dnw会死机没法解决，那只有sd卡下载启动了。

​    注意：开发板上按下电源键之后4颗LED默认都是半亮的，当我们下载程序后其中3颗变的很亮，这说明我们的程序已经运行了。

### 1.4.10.4、总结和回顾（软件控制硬件思想、寄存器意义、原理图数据手册的作用）

​    软件到底是怎么控制硬件的？为什么程序一运行硬件就能跟着动？

​    软件编程控制硬件的接口就是：寄存器

​    

## 1.4.11.一步步点亮LED4_使用位运算实现复杂点亮要求

​    上节回顾：代码写的更漂亮一些

​    \1. 用宏定义来定义寄存器名字，再来操作。

​    \2. 用 b . 来实现死循环

​    \3. 用.global把_start链接属性改为外部，消除链接时的警告

### 1.4.11.1、问题提出：如何只点亮中间1颗（两边是熄灭的）LED

​    分析：程序其实就是写了GPJ0CON和GPJ0DAT这2个寄存器而已，功能更改也要从这里下手。

​    GPJ0CON寄存器不需要修改，GPJ0DAT中设置相应的输出值即可。

### 1.4.11.2、直接解法（不使用位运算）和它的弊端

​    GPJ0DAT = 0x28

​    代码见<3.led_s>

​    总结：1. 这样写可以完成任务。

​        \2. 这样写有缺陷。缺陷就是需要人为的去计算这个特定的设置值，而且看代码的也不容易看懂。

​    解决方案：在写代码时用位运算去让编译器帮我们计算这个特定值。

### 1.4.11.3、常用位运算：与、或、非、移位

​    位与(&) 位或(|) 位非（取反 ~） 移位（左移<< 右移>>）

### 1.4.11.4、使用位运算实现功能

​    1<<3 等于 0b1000

​    1<<5 等于 0b100000

​    (1<<3)|(1<<5) 等于 0b101000

### 1.4.11.5、扩展一下：如何只熄灭中间1颗而点亮旁边2颗

​    ldr r0, =((0<<3) | (1<<4) | (0<<5))

 

## 1.4.12.一步步点亮LED5_汇编编写延时函数并实现LED闪烁效果

### 1.4.12.1、闪烁效果原理分析

​    闪烁 = 亮 + 延时 + 灭 + 延时 + 亮 + 延时 ······

### 1.4.12.2、延时函数原理

​    在汇编中实现延时的方法：用一些没有目的的代码来执行消耗时间，达到延时的效果。

### 1.4.12.3、汇编编写延时函数

​    汇编编写延时函数的原理，用一个寄存器存放一个数字，然后在循环中每个循环里给数字减1，然后再判断这个数字的值是否为0.如果为0则停止循环，如果不为0则继续循环。

### 1.4.12.4、汇编编写及调用函数的方式

​    汇编中整个汇编的主程序是一个死循环，这个死循环是我们汇编程序的主体，类似于C中的main函数。其他函数必须写在这个主死循环程序的后面（死循环外），不然会出错。

​    汇编编写delay延时函数时，要注意函数的初始化和函数体的位置，不能把初始化写在了循环体内。

​    汇编中调用函数用bl指令，子函数中最后用mov pc, lr来返回。

 

## 1.4.13.一步步点亮LED6_再难一点的流水灯效果

### 1.4.13.1、流水灯原理分析

​    流水灯又叫跑马灯，实现的效果就是：挨着的LED一次点亮熄灭（同时只有1颗LED亮的）

### 1.4.13.2、流水灯编写（使用循环）

​    LED1亮延时 + LED2亮延时 + LED3亮延时 + 循环

### 1.4.13.3、复杂点的实现

​    用位取反操作符来轻松愉快的实现单颗LED点亮流水效果

### 1.4.13.4、总结：一步步写，根本不难

​    从一步一步点亮LED1开始到6，写了8个示例代码，一步步的实现了更复杂的效果，其间夹杂使用了位运算来给LED赋值，以实现想要的点亮效果。如果按部就班实际上非常简单。

​    编程操控一个硬件的步骤：1 分析硬件工作原理 2 分析原理图 3 分析数据手册 4 找到相关的SFR 5 写代码设置寄存器得到想要的效果

### 1.4.13.5

​    作业：1、板子上有4颗LED的（还有个在GPD0_1），大家编程把LED4也点亮、熄灭

​        2、用4颗LED实现流水灯

 

## 1.4.14.反汇编工具objdump的使用简介 

### 1.4.14.1、反汇编的原理&为什么要反汇编

​    arm-linux-objdump -D led.elf > led_elf.dis

​    objdump是gcc工具链中的反汇编工具，作用是由编译链接好的elf格式的可执行程序反过来得到汇编源代码

​    -D表示反汇编   > 左边的是elf的可执行程序（反汇编时的原材料），>右边的是反汇编生成的反汇编程序

​    

​    反汇编的原因有以下：

​       1.逆向破解。

​       2.调试程序时，反汇编代码可以帮助我们理解程序（我们学习时使用objdump主要目的是这个），尤其是在理解链接脚本、链接地址等概念时。

​       \3. 把C语言源代码编译链接生成的可执行程序反汇编后得到对应的汇编代码，可以帮助我们理解C语言和汇编语言之间的对应关系。非常有助于深入理解C语言。

### 1.4.14.2、反汇编文件的格式和看法

​    （汇编 assembly  反汇编 dissembly）

​    标号地址、标号名字、指令地址、指令机器码、指令机器码反汇编到的指令

​    扩展：ARM汇编中用地址池方式来实现非法立即数

​    

### 1.4.14.3、初识指令地址

​    下载烧录执行的bin文件，内部其实是一条一条的指令机器码。这些指令每一条都有一个指令地址，这个地址是连接的时候ld给指定的（ld根据我们写的链接脚本来指定）

###  1.4.14.4、展望：反汇编工具帮助我们分析链接脚本

​    反汇编的时候得到的指令地址是链接器考虑了链接脚本之后得到的地址，而我们写代码时通过指定连接脚本来让链接器给我们链接合适的地址。

​    但是有时候我们写的链接脚本有误（或者我们不知道这个链接脚本会怎么样），这时候可以通过看反汇编文件来分析这个链接脚本的效果，看是不是我们想要的，如果不是可以改了再看。

外链内容：C语言位操作

 



 

# 第五章 SDRAM和重定位relocate

## 1.5.0 章节概要

**1.5.1.汇编写启动代码之关看门狗**

​    使用汇编在启动代码中关闭看门狗，以防止启动过程中不喂狗导致复位。目的是让大家认识看门狗这个外设，同时进一步熟悉ARM汇编程序编写

**1.5.2.汇编写启动代码之设置栈和调用C语言1**

​    本节主要讲解C语言运行时环境和栈的重要性，然后分析了S5PV210的栈寄存器SP，进一步查阅文档确定启动代码中规划的栈内存区间，最终使用汇编编程设置栈以便调用C语言程序

**1.5.3.汇编写启动代码之设置栈和调用C语言2**

​    本节接上节将之前第三部分中的led程序由汇编更改为C程序，然后被汇编调用。通过实验告诉大家汇编程序是如何调用C程序进行交互的。

**1.5.4.汇编写启动代码之开iCache**

​    本节主要讲解cache的概念和作用，为什么需要cache，以及在210中如何通过汇编操作cp15开打开/关闭cache。

**1.5.5.重定位引入和链接脚本1**

​    本节讲解了几个重要概念，包括：位置无关码PIC、链接地址和运行地址，然后再次结合S5PV210的启动过程分析，最终目的是让大家明白为什么需要重定位

**1.5.6.重定位引入和链接脚本2**

​    本节首先讲了链接地址和运行地址各自由什么决定，然后简单讲述代码编译链接的步骤，最后重点讲了各种段，如代码段、数据段、bss段等的含义。

**1.5.7.重定位引入和链接脚本3**

​    本节接上节讲述各种段的含义，最后以一个简单的链接脚本为例讲述了链接脚本的构成和解读方法。

**1.5.8.代码重定位实战1**

​    本节开始重定位实战，首先明确任务（在sram内进行重定位），然后重点讲解了实现思路及步骤，为下节课写代码打好基础。

**1.5.9.代码重定位实战2**

​    本节讲解SRAM内部重定位的代码，着重讲了adr与ldr伪指令的区别、重定位的copy汇编代码、清除bss段的代码等模块，目的是让大家彻底掌握重定位。

**1.5.10.SDRAM引入**

​    本节首先讲解SDRAM和DDR的联系和区别，然后粗略讲了SDRAM的特性，最后带大家简单读了SDRAM芯片的手册，为后面写代码时查阅手册打好了基础。

**1.5.11.SDRAM初始化**

​    本节首先从原理图出发，带领大家详细分析X210核心板原理图中DDR SDRAM芯片的相关部分，得出一些参数；然后再结合数据手册内容得到另一些参数，这些参数在之后的代码中都会用得到。

​    

**1.5.12.汇编初始化SDRAM详解1**

​    本节开始讲解SDRAM初始化代码，首先引导大家找到数据手册上27步初始化DRAM的部分，然后逐项分析代码。本节主要分析了设置引脚驱动能力，和DLL锁存部分。

**1.5.13.汇编初始化SDRAM详解2**

​    本节接上节继续讲解SDRAM初始化代码，主要讲了几个关键性寄存器的参数值设置。最后在DRAM初始化后将代码重定位到DRAM上运行，完成本章内容。

## 1.5.1.汇编写启动代码之关看门狗

### 1.5.1.1、什么是看门狗？

看门狗（watch dog timer 看门狗定时器）。想象这样一个场景：家门口有一只狗，这个狗定时会饿（譬如说2小时一饿），够饿了会胡乱咬死人。人进进出出要想保证安全必须提前喂狗（必须在上次喂过后的2小时内喂狗才行）。如果超时没喂狗就会被咬死，如果提前喂狗没关系，但是本次喂狗时间就会从这里开始计算。

​    现实中因为一些外部因素，电子设备经常会跑飞或者死机（譬如极端炎热、极端寒冷、工业复杂场合）。在这种情况下我们希望设备自动复位而不需要人工干预（无人值守）。看门狗用来完成这个工作。看门狗其实是我们SoC内部的一个定时器（类似于闹钟，类似于门口的狗），定好时间之后看门狗定时器会去计时，时间到之前（狗饿了之前）必须去重新置位看门狗定时器（喂狗），如果没有喂狗则系统会被强制复位。

​    系统在正常工作时，系统软件会自己去喂狗，所以看门狗定时器不会复位。但是系统一旦故障跑飞啥的，看门狗就没人喂了，然后下一个周期就会自动复位，达到我们期望的效果。

​    

### 1.5.1.2、分析硬件物理特性、原理图、数据手册

​    物理特性上看门狗其实是个定时器（跟现实中的闹钟类似），硬件上就是SoC内部的一个内部外设。

​    原理图：看门狗不用分析原理图，因为看门狗属于内部外设，且没有外部相关的原件与他有关，所以不需要原理图分析，原理图上根本找不到和看门狗有关的地方。

​    数据手册：在数据手册的Section7.3，大家可以详细来看。如果直接看不懂数据手册，可以百度看门狗，然后看别人的博客来学习。

​    

### 1.5.1.3、找到关键性操作SFR（特殊功能寄存器）

​    WTCON（0xE2700000），其中bit5是看门狗的开关：0代表关，1代表开

### 1.5.1.4、编写汇编代码

 

### 1.5.1.5、总结210中看门狗特性（iROM中已经关看门狗）

​    为什么要关看门狗？

​    一般CPU设计，在CPU启动后看门狗默认是工作的（为什么默认不关闭而要工作？我猜测是因为怕你的程序在启动代码前端就死机了或者跑飞了没人管），好处就是没有空当和漏洞，坏处就是在启动代码段我们不方便去喂狗（或者说懒得去喂狗）时看门狗会复位，所以为了偷懒我们就在启动代码前端先去关闭看门狗，然后在后面系统启动起来之后再根据需要决定是否要打开看门狗（一旦打开就必须同时提供喂狗）。

​    在S5PV210内部的iROM代码（BL0）中，其实已经关过看门狗了。所以我们的启动代码实际上是不用去关也没事的，也就是说今天写的关闭看门狗的代码运行后没有任何现象（没有现象就是正常现象）.

​    很多CPU内部是没有BL0的，因此也没人给你关看门狗，都要在启动代码前段自己写代码关看门狗，所以今天学习的内容也是有价值的。

 

## 1.5.2.汇编写启动代码之设置栈和调用C语言1

### 1.5.2.1、C语言运行时需要和栈的意义

​    “C语言运行时（runtime）”需要一定的条件，这些条件由汇编来提供。C语言运行时主要是需要栈

​    C语言与栈的关系：C语言中的局部变量都是用栈来实现的。如果我们汇编部分没有给C部分预先设置合理合法的栈地址，那么C代码中定义的局部变量就会落空，整个程序就死掉了。

​    我们平时在编写单片机程序（譬如51单片机）或者编写应用程序时并没有去设置栈，但是C程序还是可以运行的。原因是：在单片机中由硬件初始化时提供了一个默认可用的栈，在应用程序中我们编写的C程序其实并不是全部，编译器（gcc）在链接的时候会帮我们自动添加一个头，这个头就是一段引导我们的C程序能够执行的一段汇编实现的代码，这个代码中就帮我们的C程序设置了栈及其他的运行时需要。

### 1.5.2.2、CPU模式和各种模式下的栈

​    在ARM中37个寄存器中，每种模式下都有自己的独立的SP寄存器（r13），为什么这么设计？

​    如果各种模式都使用同一个SP，那么就意味着整个程序（操作系统内核程序、用户自己编写的应用程序）都是用一个栈的。你的应用程序如果一旦出错（譬如栈溢出），就会连累操作系统的栈也损坏，整个操作系统的程序就会崩溃。这样的操作系统设计是非常脆弱的，不合理的。

​    解决方案：就是各种模式下用不同的栈。我的操作系统内核使用自己的栈，每个应用程序也使用自己独立的栈，这样各是各的，一个损坏不会连累其他人。

​    我们现在要设置栈，不可能也懒的而且也没有必要去设置所有的栈，我们先要找到自己的模式，然后设置自己的模式下的栈到合理合法的位置，即可。

​    注意：系统在复位后默认是进入SVC模式的

​    我们如何访问SVC模式下的SP呢？很简单，先把模式设置为SVC，再直接操作SP。但是因为我们复位后就已经是SVC模式了，所以直接设置SP即可。

 

### 1.5.2.3、查阅文档并设置栈指针至合法位置

​    栈必须是当前一段可用的内存（可用的意思是这个地方必须有被初始化过可以访问的内存，而且这个内存只会被我们用作栈，不会被其他程序征用）

​    当前CPU刚复位（刚启动），外部的DRRAM尚未初始化，目前可用的内存只有内部的SRAM（因为它不需初始化即可使用）。因此我们只能在SRAM中找一段内存来作为SVC的栈。

​    栈有四种：满减栈 满增栈 空减栈 空增栈

​    满栈：进栈：先移动指针再存； 出栈：先出数据再移动指针

​    空栈：xxx

​    减栈：进栈：指针向下移动；   出栈：指针向上移动

​    增栈：xxx

​    在ARM中，ATPCS（ARM关于程序应该怎么实现的一个规范）要求使用满减栈，所以不出意外都是用满减栈

​    结合iROM_application_note中的memory map，可知SVC栈应该设置为0xd0037D80

### 1.5.2.4、汇编程序和C程序互相调用

​    bl cfuncion

 

## 1.5.3.汇编写启动代码之设置栈和调用C语言2

### 1.5.3.1、C函数的编写和被汇编调用

​    在工程中新建并且添加一个C语言源文件（led.c），注意添加时要修改Makefile

​    在汇编启动代码中设置好栈后，使用bl xxx的方式来调用C中的函数xxx

### 1.5.3.2、使用C语言来访问寄存器的语法

​    寄存器的地址类似于内存地址（IO与内存统一编址的），所以这里的问题是用C语言读写寄存器，就是用C语言来读写内存地址。用C语言来访问内存，就要用到指针

​    unsigned int *p = (unsigned int *)0x0xE0200240;

​    *p = 0x11111111;

​    上面这两句其实可以简化为1句：*((unsigned int *)0x0xE0200240) = 0x11111111;

​    

### 1.5.3.3、神奇的volatile

​    volatile的作用是让程序在编译时，编译器不对程序做优化。优化有时候是ok的，但是有时候是自作聪明会造成程序不对。如果你的一个变量是易变的，不希望编译器帮我们做优化，就在这个变量定义时加volatile。

​    加不加有没有差别，取决于编译器。如果编译器做了优化则有差异；如果编译器本身没做优化，那就没有差别。

​    在我们这里（编译器是arm-2009q3），实际测试加不加效果是一样的。

### 1.5.3.4、总结：

​    C和汇编函数的互相调用（函数名和汇编标号的真实意义）

​    C语法对内存访问的封装方式（使用指针来访问内存的技巧）

​    汇编的意义（起始代码&效率关键部位）

​    

### 1.5.3.5、编译报错（实际上是连接阶段报错）：undefined reference to `__aeabi_unwind_cpp_pr1'  

​    解决方法：把错误信息直接贴到baidu搜索（baidu搜索不到找google），根据搜索到的内容一个一个看，一个一个尝试，直到解决。

​    解决：在编译时添加-nostdlib这个编译选项即可解决。nostdlib就是不使用标准函数库。标准函数库就是编译器中自带的函数库，用-nostdlib可以让编译器链接器优先选择我程序内自己写的函数库。

## 1.5.4.汇编写启动代码之开iCache

### 1.5.4.1、什么是cache，有什么用

​    cache是一种内存，叫高速缓存。

从容量来说：CPU <　寄存器 < cache < DDR

从速度来说：CPU > 寄存器 > cache > DDR

​    cache的存在，是因为寄存器和ddr之间速度差异太大，ddr的速度远不能满足寄存器的需要（不能满足cpu的需要，所以没有cache会拉低整个系统的整体速度）

整个系统中CPU的供应链由：寄存器+cache+DDR+硬盘/flash四阶组成，这是综合考虑了性能、成本后得到的妥协的结果。

210内部有32KB icache和32kb dcache。icache是用来缓存指令的；dcache是用来缓存数据的。

 

cache的意义：指令平时是放在硬盘/flash中的，运行时读取到DDR中，再从DDR中读给寄存器，再由寄存器送给cpu。但是DDR的速度和寄存器（代表的就是CPU）相差太大，如果CPU运行完一句再去DDR读取下一句，那么CPU的速度完全就被DDR给拖慢了。解决方案就是icache。

icache工作时，会把我们CPU正在运行的指令的旁边几句指令事先给读取到icache中（CPU设计有一个基本原理：代码执行时，下一句执行当前一句代码旁边代码的可能性要大很多）。当下一句CPU要指令时，cache首先检查自己事先准备的缓存指令中有没这句，如果有就直接拿给CPU，如果没有则需要从DDR中重新去读取拿给CPU，并同时做一系列的动作：清缓存、重新缓存。

 

### 1.5.4.2、iROM中BL0对cache的操作

首先，icache的一切动作都是自动的，不需人为干预。我们所需要做的就是打开/关闭icache。

其次，在210的iROM中BL0已经打开了icache。所以之前看到的现象都是icache打开时的现象。

### 1.5.4.3、汇编代码读写cp15以开关icache

​    mrc p15,0,r0,c1,c0,0;          // 读出cp15的c1到r0中

​    bic r0, r0, #(1<<12)          // bit12 置0 关icache

​    orr r0, r0, #(1<<12)           // bit12 置1 开icache

​    mcr p15,0,r0,c1,c0,0;

### 1.5.4.4、实验验证

我们来看三种情况下的实验现象：

​    1 直接使用BL0中对icache的操作

​    2 关icache

​    3 开icache

实验结果分析：

​    结论1：irom中确实是打开了icache的。

​    结论2：icache关闭确实比icache打开时led闪烁变慢，说明指令执行速度变慢。

 

 

## 1.5.5.重定位引入和链接脚本1

### 1.5.5.1、一个事实：大部分指令是位置有关编码

位置无关编码(PIC，position independent code)：汇编源文件被编码成二进制可执行程序时编码方式与位置（内存地址）无关。

位置有关编码：汇编源码编码成二进制可执行程序后和内存地址是有关的。

 

我们在设计一个程序时，会给这个程序指定一个运行地址（链接地址）。就是说我们在编译程序时其实心里是知道我们程序将来被运行时的地址（运行地址）的，而且必须给编译器链接器指定这个地址（链接地址）才行。最后得到的二进制程序理论上是和你指定的运行地址有关的，将来这个程序被执行时必须放在当时编译链接时给定的那个地址（链接地址）下才行，否则不能运行（就叫位置有关代码）。但是有个别特别的指令他可以跟指定的地址（链接地址）没有关系，也就是说这些代码实际运行时不管放在哪里都能正常运行。

 

对比：位置无关代码要好一些，适应性强，放在哪里都能正常运行；位置有关代码就必须运行在链接时指定的地址上，适应性差。位置无关码有一些限制，不能完成所有功能，有时候不得不使用位置有关代码。

 

### 1.5.5.2、链接地址和运行地址：可能相同也可能不同

对于位置有关代码来说：最终执行时的运行地址和编译链接时给定的链接地址必须相同，否则一定出错。

我们之前的裸机程序中，Makefile中用 -Ttext 0x0 来指定链接地址是0x0。这意味着我们认为这个程序将来会放在0x0这个内存地址去运行。

但是实际上我们运行时的地址是0xd0020010(我们用dnw下载时指定的下载地址)。这两个地址看似不同，但是实际相同。这是因为S5PV210内部做了映射，把SRAM映射到了0x0地址去。

 

分清楚这两个概念：

链接地址：链接时指定的地址（指定方式为：Makefile中用-Ttext，或者链接脚本）

运行地址：程序实际运行时地址（指定方式：由实际运行时被加载到内存的哪个位置说了算）

 

### 1.5.5.3、再解S5PV210的启动过程：三星推荐和uboot的实现是不同的

三星推荐的启动方式中：bootloader必须小于96KB并大于16KB，假定bootloader为80KB，启动过程是这样子：先开机上电后BL0运行，BL0会加载外部启动设备中的bootloader的前16KB（BL1）到SRAM中去运行，BL1运行时会加载BL2（bootloader中80-16=64KB）到SRAM中（从SRAM的16KB处开始用）去运行；BL2运行时会初始化DDR并且将OS搬运到DDR去执行OS，启动完成。

uboot实际使用的方式：uboot大小随意，假定为200KB。启动过程是这样子：先开机上电后BL0运行，BL0会加载外部启动设备中的uboot的前16KB（BL1）到SRAM中去运行，BL1运行时会初始化DDR，然后将整个uboot搬运到DDR中，然后用一句长跳转（从SRAM跳转到DDR）指令从SRAM中直接跳转到DDR中继续执行uboot直到uboot完全启动。uboot启动后在uboot命令行中去启动OS。

 

### 1.5.5.4、现在明白为什么要重定位了吧？

原因：

​    链接地址和运行地址有时候必须不相同，而且还不能全部用位置无关码，这时候只能重定位。

扩展：

​    分散加载：把uboot分成2部分（BL1和整个uboot），两部分分别指定不同的链接地址。启动时将两部分加载到不同的地址（BL1加载到SRAM，整个uboot加载到DDR），这时候不用重定位也能启动。

评价：分散加载其实相当于手工重定位。重定位是用代码来进行重定位，分散加载是手工操作重定位的。

 

## 1.5.6.重定位引入和链接脚本2

### 1.5.6.1、运行时地址由什么决定？

​    运行时的地址是由运行时决定的（编译链接时是无法绝对确定运行时地址的）

### 1.5.6.2、链接地址由什么决定？

​    链接地址：是由程序员在编译链接的过程中，通过Makefile中-Ttext xxx或者在链接脚本中指定的。程序员事先会预知自己的程序的执行要求，并且有一个期望的执行地址，并且会用这个地址来做链接地址。

举例：

1、linux中的应用程序。gcc hello.c -o hello，这时使用默认的链接地址就是0x0，所以应用程序都是链接在0地址的。因为应用程序运行在操作系统的一个进程中，在这个进程中这个应用程序独享4G的虚拟地址空间。所以应用程序都可以链接到0地址，因为每个进程都是从0地址开始的。（编译时可以不给定链接地址而都使用0）

​     2、SP5V210中的裸机程序。运行地址由我们下载时确定，下载时下载到0xd0020010，所以就从这里开始运行。（这个下载地址也不是我们随意定的，是iROM中的BL0加载BL1时事先指定好的地址，这是由CPU的设计决定的）。所以理论上我们编译链接时应该将地址指定到0xd0020010，但是实际上我们在之前裸机程序中都是使用位置无关码PIC，所以链接地址可以是0。

### 1.5.6.3、从源码到可执行程序的步骤：预编译、编译、链接、strip

​    预编译：预编译器执行。譬如C中的宏定义就是由预编译器处理，注释等也是由预编译器处理的。

编译： 编译器来执行。把源码.c .S编程机器码.o文件。（其实已经是二进制码了，但是是一块一块函数零散的）

​    链接：  链接器来执行。把.o文件中的各函数（段）按照一定规则（链接脚本来指定）累积在一起，形成可执行文件。这个过程就像炒菜，不可能把食材同时一起倒进锅里，要有一定的顺序放入锅里。连接器也是，要按一定的规则来连接各个函数，而不是胡乱连接，这就是连接器的规则。

​    strip： strip是把可执行程序中的符号信息给拿掉，以节省空间。（Debug（调试版本有符号信息）版本和Release（没有符号信息）版本，反编译就得不到啥可读信息，都是一些数字）。符号表是用来调试用的比如说函数名。

​    objcopy：由可执行程序生成可烧录的镜像bin文件。

Strip 和objcopy是可选的，可以有可以没有。

​    

### 1.5.6.4、程序段的概念：代码段、数据段、bss段（ZI段）、自定义段

段就是程序的一部分，我们把整个程序的所有东西分成了一个一个的段，给每个段起个名字，然后在链接时就可以用这个名字来指示这些段。也就是说给段命名就是为了在链接脚本中用段名来让段站在核实的位置。

 

段名分为2种：

先天性：一种是编译器链接器内部定好的，先天性的名字；

后天性：一种是程序员自己指定的、自定义的段名。

先天性段名：

​    代码段：（.text），又叫文本段，代码段其实就是函数编译后生成的东西。

​    数据段：（.data），数据段就是C语言中有显式初始化为非0的全局变量

​    bss段：（.bss），又叫ZI（zero initial）段，就是零初始化段，对应C语言中初始化为0的全局变量。

后天性段名：

​    段名由程序员自己定义，段的属性和特征也由程序员自己定义。

​    

分析一些问题，跟这里结合，然后试图明白一些本质：

1、C语言中全局变量如果未显式初始化，值是0。本质就是C语言把这类全局变量放在了bss段，从而保证了为0

2、C运行时环境如何保证显式初始化为非0的全局变量的值在main之前就被赋值了？就是因为它把这类变量放在了.data段中，而.data段会在main执行之前被处理（初始化）。

​     

### 1.5.6.5、链接脚本究竟要做什么？

链接脚本其实是个规则文件，他是程序员用来指挥链接器工作的。链接器会参考链接脚本，并且使用其中规定的规则来处理.o文件中那些段，将其链接成一个可执行程序。

​    链接脚本的关键内容有2部分：段名 + 地址（作为链接地址的内存地址）

​    链接脚本的理解：

​    SECTIONS {}  这个是整个链接脚本

​    . 点号在链接脚本中代表当前位置。

​    = 等号代表赋值

 

## 1.5.8.代码重定位实战1

### 1.5.8.1、任务：在SRAM中将代码从0xd0020010重定位到0xd0024000

​    任务解释：本来代码是运行在0xd0020010的，但是因为一些原因我们又希望代码实际是在0xd0024000位置运行的。这时候就需要重定位了。

注解：本练习对代码本身运行无实际意义，我们做这个重定位纯粹是为了练习重定位技能。但是某些情况重定位就是必须的，譬如在uboot中。

​    

### 1.5.8.2、思路：

​       第一点：通过链接脚本将代码链接到0xd0024000

​       第二点：dnw下载时将bin文件下载到0xd0020010

第一点加上第二点，就保证了：代码实际下载运行在0xd0020010，但是却被链接在0xd0024000。从而为重定位奠定了基础。

当我们把代码链接地址设置为0xd0024000时，实际隐含意思就是我这个代码将来必须放在0xd0024000位置才能正确执行。如果实际运行地址不是这个地址就要出事（除非代码是PIC位置无关码），当以上都明白了后，就知道重定位代码的作用就是：在PIC执行完之前（在代码中第一句位置有关码执行之前）必须将整个代码搬移到0xd0024000位置去执行，这就是重定位。

​       第三点：代码执行时通过代码前段的少量位置无关码将整个代码搬移到0xd0024000

​       第四点：使用一个长跳转跳转到0xd0024000处的代码继续执行，重定位完成

长跳转：首先这句代码是一句跳转指令（ARM中的跳转指令就是类似于分支指令B、BL等作用的指令），跳转指令通过给PC（r15）赋一个新值来完成代码段的跳转执行。长跳转指的是跳转到的地址和当前地址差异比较大，跳转的范围比较宽广。

当我们执行完代码重定位后，实际上在SRAM中有2份代码的镜像（一份是我们下载到0xd0020010处开头的，另一份是重定位代码复制到0xd0024000处开头的），这两份内容完全相同，仅仅地址不同。重定位之后使用ldr pc, =led_blink这句长跳转直接从0xd0020010处代码跳转到0xd0024000开头的那一份代码的led_blink函数处去执行。（实际上此时在SRAM中有2个led_blink函数镜像，两个都能执行，如果短跳转bl led_blink则执行的就是0xd0020010开头的这一份，如果长跳转ldr pc, =led_blink则执行的是0xd0024000开头处的这一份）。这就是短跳转和长跳转的区别。

 

当链接地址和运行地址相同时，短跳转和长跳转实际效果是一样的；但是当链接地址不等于运行地址时，短跳转和长跳转就有差异了。这时候短跳转实际执行的是运行地址处的那一份，而长跳转执行的是链接地址处那一份。

 

总结：重定位实际就是在运行地址处执行一段位置无关码PIC，让这段PIC（也就是重定位代码）从运行地址处把整个程序镜像拷贝一份到链接地址处，完了之后使用一句长跳转指令从运行地址处直接跳转到链接地址处去执行同一个函数（led_blink），这样就实现了重定位之后的无缝连接。

### 1.5.8.3、链接脚本分析讲解

SECTIONS

{

​    . = 0xd0020010;

​    

​    .text : {

​       start.o

​       \* (.text)

​    }

​         

​    .data : {

​       \* (.data)

​    }

​    

​    bss_start = .; 

​    .bss : {

​       \* (.bss)

​    }

​    

​    bss_end = .; 

}

## 1.5.9.代码重定位实战2

### 1.5.9.1、adr与ldr伪指令的区别

​    ldr和adr都是伪指令，区别是ldr是长加载、adr是短加载。

重点：adr指令加载符号地址，加载的是运行时地址；ldr指令在加载符号地址时，加载的是链接地址。

 

深入分析：只要知道adr和ldr分别用于加载运行地址和链接地址，从而可以判断是否需要重定位即可；根本不需知道为什么adr和ldr是这样子，但是我们还是给大家扩展讲下为什么adr和ldr可以加载不同的地址。

 

### 1.5.9.2、重定位（代码拷贝）

​    重定位就是汇编代码中的copy_loop函数，代码的作用是使用循环结构来逐句复制代码到链接地址。

​    复制的源地址是SRAM的0xd0020010，复制目标地址是SRAM的0xd0024000，复制长度是bss_start减去_start

​    所以复制的长度就是整个重定位需要重定位的长度，也就是整个程序中代码段+数据段的长度。

​    bss段（bss段中就是0初始化的全局变量）不需要重定位。bss段在程序中并不占用任何空间，只是一个占位符，（bss段是不会出现在程序下载文件（*.bin *.hex）中的，因为全都是0，如果把它们出现在程序下载文件中，会增加程序下载文件的大小。）不占用执行文件的空间。

在稍后进入执行的第二阶段，即C语言完成的阶段时，因为C语言要求的运行条件是要将栈设置好，并且bss段要初始化为0；故而在将所有u-boot代码（除了bss）都搬移到sdram中后，clear_bss标号开始的代码就将_bss_start指定的地址开始的bss段清零了，为下一阶段C的运行创造了条件。所以不用移动bss段总的原因就是它就是占位符，稍后把它全部清零就行了，用不着移动。

 

另外，要注意，这个_bss_start指定的地址是链接文件中确定的地址（u-boot.lds），是链接时u-boot的bss段的起始地址，这个地址是基于u-boot在链接时确定的u-boot在内存中的加载地址或者运行地址的。

### 1.5.9.3、清bss段

​    清除bss段是为了满足C语言的运行时要求（C语言要求显式初始化为0的全局变量，或者未显式初始化的全局变量的值为0，实际上C语言编译器就是通过清bss段来实现C语言的这个特性的）。一般情况下我们的程序是不需要负责清零bss段的，C语言编译器和链接器会帮我们的程序自动添加一段头程序，这段程序会在我们的main函数之前运行，这段代码就负责清除bss。但是在我们代码重定位了之后，因为编译器帮我们附加的代码只是帮我们清除了运行地址那一份代码中的bss，而未清除重定位地址处开头的那一份代码的bss，所以重定位之后需要自己去清除bss。

### 1.5.9.4、长跳转

​    清理完bss段后重定位就结束了。然后当前的状况是：

​    1、当前运行地址还在0xd0020010开头的（重定位前的）那一份代码中运行着。

​    2、此时SRAM中已经有了2份代码，1份在d0020010开头，另一份在d0024000开头的位置。

​    然后就要长跳转了。

 

 

/*

 \* 文件名： led.s  

 \* 作者： 朱老师

 \* 描述： 演示重定位（在SRAM内部重定位）

 */

\#define WTCON    0xE2700000

 

\#define SVC_STACK  0xd0037d80

 

.global _start         // 把_start链接属性改为外部，这样其他文件就可以看见_start了

_start:

  // 第1步：关看门狗（向WTCON的bit5写入0即可）

  ldr r0, =WTCON

  ldr r1, =0x0

  str r1, [r0]

  

  // 第2步：设置SVC栈

  ldr sp, =SVC_STACK

  

  // 第3步：开/关icache

  mrc p15,0,r0,c1,c0,0      // 读出cp15的c1到r0中

  //bic r0, r0, #(1<<12)     // bit12 置0 关icache

  orr r0, r0, #(1<<12)      // bit12 置1 开icache

  mcr p15,0,r0,c1,c0,0

 

  // 第4步：初始化ddr

  bl sdram_asm_init

  

  // 第5步：重定位

  // adr指令用于加载_start当前运行地址

  adr r0, _start     // adr加载时就叫短加载   

  // ldr指令用于加载_start的链接地址:0xd0024000

  ldr r1, =_start // ldr加载时如果目标寄存器是pc就叫长跳转，如果目标寄存器是r1等就叫长加载  

  // bss段的起始地址

  ldr r2, =bss_start // 就是我们重定位代码的结束地址，重定位只需重定位代码段和数据段即可

  cmp r0, r1     // 比较_start的运行时地址和链接地址是否相等

  beq clean_bss    // 如果相等说明不需要重定位，所以跳过copy_loop，直接到clean_bss

​            // 如果不相等说明需要重定位，那么直接执行下面的copy_loop进行重定位

​            // 重定位完成后继续执行clean_bss。

 

// 用汇编来实现的一个while循环

copy_loop:

  ldr r3, [r0], #4  // 源

  str r3, [r1], #4  // 目的  这两句代码就完成了4个字节内容的拷贝

  cmp r1, r2     // r1和r2都是用ldr加载的，都是链接地址，所以r1不断+4总能等于r2

  bne copy_loop

 

  // 清bss段，其实就是在链接地址处把bss段全部清零

clean_bss:

  ldr r0, =bss_start         

  ldr r1, =bss_end

  cmp r0, r1       // 如果r0等于r1，说明bss段为空，直接下去

  beq run_on_dram     // 清除bss完之后的地址

  mov r2, #0

clear_loop:

  str r2, [r0], #4    // 先将r2中的值放入r0所指向的内存地址（r0中的值作为内存地址）

  cmp r0, r1       // 然后r0 = r0 + 4

  bne clear_loop

 

run_on_dram:  

  // 长跳转到led_blink开始第二阶段

  ldr pc, =led_blink       // ldr指令实现长跳转

  

// 汇编最后的这个死循环不能丢

  b .

 

## 1.5.10.SDRAM引入

### 1.5.10.1、SDRAM：Syncronized Dynamic Ramdam Access Memory，同步动态随机存储器

​       DDR：DDR就是DDR SDRAM，是SDRAM的升级版。（DDR：double data rate，双倍速度的SDRAM）

​        DDR有好多代：DDR1 DDR2 DDR3 DDR4 LPDDR

 

### 1.5.10.2、SDRAM的特性

容量大、价格低、掉电易失性、随机读写、总线式访问

​    SDRAM/DDR都属于动态内存（相对于静态内存SRAM），都需要先运行一段初始化代码来初始化才能使用

​    不像SRAM开机上电后就可以直接运行。

类似于SDRAM和SRAM的区别的，还有NorFlash（上电直接用）和NandFlash/硬盘（上电不能直接用）这两个。

正是因为硬件本身特性有限制，所以才导致启动代码比较怪异、比较复杂。而我们研究裸机是为了研究uboot，在uboot中就充分利用了硬件的各种特性，处理了硬件复杂性。

 

### 1.5.10.3、SDRAM数据手册带读

​	SDRAM在系统中属于SoC外接设备（外部外设。以前说过随着半导体技术发展，很多东西都逐渐集成到SoC内部去了。现在还长期在外部的一般有：Flash、SDRAM/DDR、网卡芯片如DM9000、音频Codec。现在有一些高集成度的芯片也试图把这几个集成进去，做成真正的单芯片解决方案。）

SDRAM通过地址总线和数据总线接口（总线接口）与SoC通信。

​	开发板原理图上使用的是K4T1G164QQ，但是实际开发板上贴的不是这个，是另一款。但是这两款是完全兼容的，进行软件编程分析的时候完全可以参考K4T1G164QQ的文档。

 	全球做SDRAM的厂商不多，二线厂家做的产品参数都是向一线厂家（三星、KingSton）看齐，目的是兼容一线厂家的设计，然后让在意成本的厂商选择它的内存芯片替代一线厂家的内存芯片。SDRAM的这个市场特征就导致这个东西比较标准化，大部分时候细节参数官方（芯片原厂家）都会给你一个参考值。

 

K4T1G164QE：

·   K表示三星产品，4表示是DRAM，T表示产品号码，1G表示容量（1Gb，等于128MB，我们开发板X210上一共用了4片相同的内存，所以总容量是128×4=512MB）16表示单芯片是16位宽的，4表示是4bank，

 

三星官方的数据手册上其实没有芯片相关的参数设置信息，都是芯片选型与外观封装方面的信息，选型是给产品经理来看的，封装和电压等信息是给硬件工程师看的。软件工程师最关注的是工作参数信息，但是数据手册没有。

 

## 1.5.11.SDRAM初始化

### 1.5.11.1、原理图中SDRAM相关部分

S5PV210共有2个内存端口（就好象有2个内存插槽）。再结合查阅数据手册中内存映射部分，可知：两个内存端口分别叫DRAM0和DRAM1：

​    DRAM0：内存地址范围：0x20000000～0x3FFFFFFF（512MB），对应引脚是Xm1xxxx

​    DRAM1: 内存地址范围：0x40000000～0x7FFFFFFF（1024MB），对应引脚是Xm2xxxx

​    注：内存寻址是byte，而不是bit，所以不用除以8

结论：

(1)整个210最多支持内存为1.5GB，如果给210更多的内存CPU就无法识别。

(2)210最多支持1.5GB内存，但是实际开发板不一定要这么多，譬如我们X210开发板就只有512MB内存，连接方法是在DRAM0端口分布256MB，在DRAM1端口分布了256MB。

(3)由2可知，X210开发板上内存合法地址是：0x20000000～0x2FFFFFFF（256MB） + 0x40000000～0x4FFFFFFF（256MB）。当板子上DDR初始化完成之后，这些地址都是可以使用的；如果使用了其他地址譬如0x30004000就是死路一条。

 

原理图中每个DDR端口都由3类总线构成：地址总线（Xmn_ADDR0~XMnADDR13共14根地址总线） + 控制总线（中间部分，自己看原理图） + 数据总线（Xmn_DATA0~XMnDATA31共32根数据线）

分析：从数据总线的位数可以看出，我们用的是32位的（物理）内存。

 

原理图中画出4片内存芯片的一页，可以看出：X210开发板共使用了4片内存（每片1Gb=128MB，共512MB），每片内存的数据总线都是16位的（单芯片是16位内存）。如何由16位内存得到32位内存呢？可以使用并联方法。在原理图上横向的2颗内存芯片就是并联连接的。并联时地址总线接法一样，但是数据总线要加起来。这样连接相当于在逻辑上可以把这2颗内存芯片看成是一个（这一个芯片是32位的，接在Xm1端口上）。

​    

### 1.5.11.2、数据手册中SDRAM相关部分

看数据手册《NT5TU64M16GG-DDR2-1G-G-R18-Consumer》第10页的block diagram。这个框图是128Bb×8结构的，这里的8指的是8bank，每bank128Mbit。

210的DDR端口信号中有BA0～BA2，接在内存芯片的BA0～BA2上，这些引脚就是用来选择bank的。

每个bank内部有128Mb，通过row address（14位） + column address（10位）的方式来综合寻址。

一共能寻址的范围是：2的14次方+2的10次方 = 2的24次方。对应16MB（128Mbit）内存。、

注：地址总线有14根，寻址能力为2^14byte =16MB，地址总线寻址是按照byte，而不是bit来寻址的。

 

## 1.5.12.汇编初始化SDRAM详解1

### 1.5.12.1、初始化代码框架介绍（函数调用和返回、步骤等）

​    SDRAM初始化使用一个函数sdram_asm_init，函数在sdram_init.S文件中实现，是一个汇编函数。

​    强调：汇编实现的函数在返回时需要明确使用返回指令（mov pc, lr）

### 1.5.12.2、27步初始化DDR2。

(1)首先，DDR初始化和SoC（准确说是和SoC中的DDR控制器）有关，也和开发板使用的DDR芯片有关，和开发板设计时DDR的连接方式也有关。

(2)S5PV210的DDR初始化步骤在SoC数据手册：1.2.1.3 DDR2这个章节。可知初始化DDR共需27个步骤。

(3)之前分析过X210的内存连接方式是：在DRAM0上连接256MB，在DRAM1上连接了256MB。所以初始化DRAM时分为2部分，第一部分初始化DRAM0，第二部分初始化DRAM1.

(4)我们的代码不是自己写的，这个代码来自于：第一，九鼎官方的uboot中；第二，参考了九鼎的裸机教程中对DDR的初始化；第三，有些参数是我根据自己理解修改过的。

### 1.5.12.3、设置IO端口驱动强度

因为DDR芯片和S5PV210之间是通过很多总线连接的，总线的物理表现就是很多个引脚，也就是说DDR芯片和S5PV210芯片是通过一些引脚连接的。DDR芯片工作时需要一定的驱动信号，这个驱动信号需要一定的电平水平才能抗干扰，所以需要设置这些引脚的驱动能力，使DDR正常工作。

DRAM控制器对应的引脚设置为驱动强度2X（我也不知道为什么是2X，什么时候设置成3X 4X?，这东西只能问DDR芯片厂商或者SoC厂商，我们一般是参考原厂给的代码）

### 1.5.12.4、DRAM port 时钟设置

从代码第128行到154行。主要是开启DLL（dram pll）然后等待锁存。

这段代码对应27步中的第2到第4步。

 

## 1.5.13.汇编初始化SDRAM详解2

### 1.5.13.1、DMC0_MEMCONTROL

​    burst length=4，1chip，······ 对应值是0x00202400

### 1.5.13.2、DMC0_MEMCONFIG_0

​    DRAM0通道中memory chip0的参数设置寄存器

### 1.5.13.3、DMC0_MEMCONFIG_1

​    DRAM0通道中memory chip1的参数设置寄存器

总结：我猜测（推论）：三星设置DRAM0通道，允许我们接2片256MB的内存，分别叫memory chip0和memory chip1，分别用这两个寄存器来设置它的参数。按照三星的设计，chip0的地址应该是0x20000000到0x2FFFFFFF，然后chip1的地址应该是0x30000000~0x3FFFFFFF.各自256MB。

但是我们X210开发板实际在DRAM0端口只接了256MB的内存，所以只用了chip0，没有使用chip1.（我们虽然是2片芯片，然后这两片是并联形成32位内存的，逻辑上只能算1片）。按照这个推论，DMC0_MEMCONFIG_0有用，而DMC0_MEMCONFIG_1无用，所以我直接给他了默认值。

### 1.5.13.4、DMC_DIRECTCMD

这个寄存器是个命令寄存器，我们210通过向这个寄存器写值来向DDR芯片发送命令（通过命令总线），这些命令应该都是用来配置DDR芯片工作参数。

 

总结：DDR配置过程比较复杂，基本上是按照DDR控制器的时序要求来做的，其中很多参数要结合DDR芯片本身的参数来定，还有些参数是时序参数，要去详细计算。所以DDR配置非常繁琐、细致、专业。所以我们对DDR初始化的态度就是：学会这种思路和方法，结合文档和代码能看懂，会算一些常见的参数即可。

### 1.5.13.5、重定位代码到SDRAM中

DRAM初始化之后，实际上重定位代码过程和之前重定位到SRAM中完全相同。



 

 

# 第六章 时钟系统

## 1.6.0 章节概要

**1.6.1.SoC时钟系统简介**

​    本节讲解时钟系统的基本概念，时钟的作用、来源，SoC的时钟体系等，学习这些基础概念能够让大家从整体上把握现代SoC的时钟系统设计方式，从而有利于后面课程的学习。

**1.6.2.S5PV210的时钟系统简介**

​    本节概要讲述S5PV210的时钟体系，主要内容是时钟域概念的引入，并且讲了210内部的4个PLL及其用途。

**1.6.3.S5PV210时钟域详解**

​    详解S5PV210的时钟域，并且将210内部复杂的时钟分解成很多部分，各部分的时钟已经名称列出，最后给出了三星推荐的各时钟典型值。

**1.6.4.S5PV210时钟体系框图详解**

​    本节主要讲解如何解析S5PV210数据手册中的时钟框图，这个框图是210内部复杂的时钟模块的逻辑结构图，学会看这张图很关键，是理解时钟体系的核心。

**1.6.5.时钟设置的关键性寄存器**

​    本节讲述S5PV210时钟模块的主要寄存器，这些寄存器与后面编程控制时钟模块有极大关联，需要对照各个位定义详细解析。

**1.6.6.汇编实现时钟设置代码详解1**

​    本节开始实战使用汇编代码来设置时钟。主要讲了CLK_SRC（Mux开关）、CLK_LOCK、CLK_DIV等几个关键性寄存器的详细设置。

**1.6.7.汇编实现时钟设置代码详解2**

​    本节接上节继续分析S5PV210的时钟设置代码，首先分析了APLL和MPLL的设置参数，然后结合寄存器、时钟框图、代码三者综合分析S5PV210的时钟系统

**1.6.8.C语言实现时钟设置代码详解**

​    本节以C语言来设置时钟，其实就是将上节的汇编代码用C语言的方式进行改造。通过本节希望大家明白汇编和C语言的相同和不同，能够学会在汇编和C之间进行切换。

## 1.6.1.SoC时钟系统简介

### 1.6.1.1、什么是时钟？SoC为什么需要时钟？

(1)时钟是同步工作系统的同步节拍。

(2)SoC内部有很多器件，譬如CPU、串口、DRAM控制器、GPIO等内部外设，这些东西要彼此协同工作，需要一个同步的时钟系统来指挥。这个就是我们SoC的时钟系统。

### 1.6.1.2、时钟一般如何获得

(1)SoC的时钟获得一般有：            

​        \* 外部直接输入时钟信号，SoC有个引脚用来输入外部时钟信号，用的很少。

​        \* 外部晶振+内部时钟发生器产生时钟，大部分低频单片机都是这么工作的。

​        \* 外部晶振+内部时钟发生器+内部PLL产生高频时钟+内部分频器分频得到各种频率的时钟，210属于这种。

(2)S5PV210属于第三种。为什么这么设计？

第一问：外什么不用外部高频晶振产生高频信号直接给CPU？

主要是因为芯片外部电路不适宜使用高频率，因为传导辐射比较难控制；高频率的晶振太贵了。

第二问：为什么要内部先高频然后再分频？

主要因为SoC内部有很多部件都需要时钟，而且各自需要的时钟频率不同，没法统一供应。因此设计思路是PLL后先得到一个最高的频率（1GHz、1.2GHz），然后各外设都有自己的分频器再来分频得到自己想要的频率。

​    

### 1.6.1.3、时钟和系统性能的关系、超频、稳定性

(1)一般SoC时钟频率都是可以人为编程控制的，频率的高低对系统性能有很大影响。

(2)S5PV210建议工作频率800MHz～1.2GHz，一般我们都设置到1GHz主频。如果你设置到1.2GHz就叫超频。超频的时候系统性能会提升，但是发热也会增大，因此会影响系统稳定性。

 

### 1.6.1.4、时钟和外设编程的关联

(1)每个外设工作都需要一定频率的时钟，这些时钟都是由时钟系统提供的。时钟系统可以编程控制工作模式，因此我们程序员可以为每个外设指定时钟来源、时钟分频系统、从而制定这个外设的工作时钟。

 

### 1.6.1.5、时钟和功耗控制的关系

(1)SoC中各种设备工作时，时钟频率越高其功耗越大，发热越大，越容易不稳定，需要外部的散热条件越苛刻。

(2)SoC内部有很多外设，这些外设不用的时候最好关掉（不关掉会一定程度浪费电），开关外设不是通过开关，而是通过时钟。也就是说我们给某个外设断掉时钟，这个外设就不工作了。

 

## 1.6.2.S5PV210的时钟系统简介

### 1.6.2.1、时钟域：MSYS、DSYS、PSYS

(1)因为S5PV210的时钟体系比较复杂，内部外设模块太多，因此把整个内部的时钟划分为3大块，叫做3个域。

(2)MSYS: CPU（Cortex-A8内核）、DRAM控制器（DMC0和DMC1）、IRAM&IROM······

(3)DSYS: 都是和视频显示、编解码等有关的模块

(4)PSYS: 和内部的各种外设时钟有关，譬如串口、SD接口、I2C、AC97、USB等。

(5)为什么内部要分为3个域，怎么划分的？因为210内部的这些模块彼此工作时钟速率差异太大了，所以有必要把高速的放一起，相对低速的放一起。

在·

### 1.6.2.2、时钟来源：晶振+时钟发生器+PLL+分频电路

(1)S5PV210外部有4个晶振接口，设计板子硬件时可以根据需要来决定在哪里接晶振。接了晶振之后上电相应的模块就能产生振荡，产生原始时钟。原始时钟再经过一系列的筛选开关进入相应的PLL电路生成倍频后的高频时钟。高频时钟再经过分频到达芯片内部各模块上。（有些模块，譬如串口内部还有进一步的分频器进行再次分频使用）

 

### 1.6.2.3、PLL：APLL、MPLL、EPLL、VPLL

APLL：Cortex-A8内核 MSYS域

MPLL： DSYS 

EPLL：  PSYS

VPLL：Video视频相关模块

 

## 1.6.3.S5PV210时钟域详解

### 1.6.3.1、MSYS域：

​    ARMCLK：  给cpu内核工作的时钟，也就是所谓的主频。

​    HCLK_MSYS：   MSYS域的高频时钟，给DMC0和DMC1使用

​    PCLK_MSYS：    MSYS域的低频时钟

​    HCLK_IMEM：给iROM和iRAM（合称iMEM）使用

 

1.6.3.2、DSYS域：

​    HCLK_DSYS：DSYS域的高频时钟

​    PCLK_DSYS：DSYS域的低频时钟

 

### 1.6.3.3、PSYS域：

​    HCLK_PSYS：PSYS域的高频时钟

​    PCLK_PSYS：PSYS域的低频时钟

​    SCLK_ONENAND：

​    

总结：210内部的各个外设都是接在（内部AMBA总线）总线上面的，AMBA总线有1条高频分支叫AHB，有一条低频分支叫APB。上面的各个域都有各自对应的HCLK_XXX和PCLK_XXX，其中HCLK_XXX就是XXX这个域中AHB总线的工作频率；PCLK_XXX就是XXX这个域中APB总线的工作频率。

SoC内部的各个外设其实是挂在总线上工作的，也就是说这个外设的时钟来自于他挂在的总线，譬如串口UART挂在PSYS域下的APB总线上，因此串口的时钟来源是PCLK_PSYS。

我们可以通过记住和分析上面的这些时钟域和总线数值，来确定我们各个外设的具体时钟频率。

 

### 1.6.3.4、各时钟典型值（默认值，iROM中设置的值）

(1)当210刚上电时，默认是外部晶振+内部时钟发生器产生的24MHz频率的时钟直接给ARMCLK的，这时系统的主频就是24MHz，运行非常慢。

(2)iROM代码执行时第6步中初始化了时钟系统，这时给了系统一个默认推荐运行频率。这个时钟频率是三星推荐的210工作性能和稳定性最佳的频率。

(3)各时钟的典型值：

​     freq(ARMCLK)          = 1000 MHz

 freq(HCLK_MSYS)       = 200 MHz  （DMC0，DMC1）

​     freq(HCLK_IMEM)       = 100 MHz

​     freq(PCLK_MSYS)        = 100 MHz

​     freq(HCLK_DSYS)        = 166 MHz

​     freq(PCLK_DSYS)        = 83 MHz

​     freq(HCLK_PSYS)        = 133 MHz

​     freq(PCLK_PSYS)        = 66 MHz

​     freq(SCLK_ONENAND)    = 133 MHz, 166 MHz

 

 

## 1.6.4.S5PV210时钟体系框图详解

(1)时钟体系框图的位置：数据手册P361&P362，Figure3-3

(2)两张图之间是渐进的关系。

第一张图从左到右依次完成了原始时钟生成->PLL倍频得到高频时钟->初次分频得到各总线时钟；

第二张图是从各中间时钟（第一张图中某个步骤生成的时钟）到各外设自己使用的时钟（实际就是个别外设自己再额外分频的设置）。

可见，第一张图是理解整个时钟体系的关键，第二种图是进一步分析各外设时钟来源的关键。

(3)要看懂时钟体系框图，2个符号很重要：一个是MUX开关，另一个是DIV分频器。

(3.1)MUX开关就是个或门，实际对应某个寄存器的某几个bit位的设置，设置值决定了哪条通道通的，分析这个可以知道右边的时钟是从左边哪条路过来的，从而知道右边时钟是多少。

(3.2)DIV分频器，是一个硬件设备，可以对左边的频率进行n分频，分频后的低频时钟输出到右边。分频器在编程时实际对应某个寄存器中的某几个bit位，我们可以通过设置这个寄存器的这些对应bit位来设置分频器的分频系数（譬如左边进来的时钟是80MHz，分频系统设置为8，则分频器右边输出的时钟频率为10MHz）。

(3.3)寄存器中的clock source x就是在设置MUX开关；clock divider control寄存器就是在设置分频器分频系数。

 

## 1.6.5.时钟设置的关键性寄存器

### 1.6.5.1、xPLL_LOCK

​    xPLL_LOCK寄存器主要控制PLL锁定周期的。24MHZ到1GHZ它不是瞬间完成的，他需要时间来稳定。通过相位锁定，锁相环（相当于反馈环节），从出入频率到输出稳定的频率需要时间，PLL锁定周期就是控制从输入到输出稳定频率的所需时间。

### 1.6.5.2、xPLL_CON/xPLL_CON0/xPLL_CON1

​    PLL_CON寄存器主要用来打开/关闭PLL电路，设置PLL的倍频参数，查看PLL锁定状态等

### 1.6.5.3、CLK_SRCn(n：0～6)

​    CLK_SRC寄存器是用来设置时钟来源的，对应时钟框图中的MUX开关。

### 1.6.5.4、CLK_SRC_MASKn

​    CLK_SRC_MASK决定MUX开关n选1后是否能继续通过。默认的时钟都是打开的，好处是不会因为某个模块的时钟关闭而导致莫名其妙的问题，坏处是功耗控制不精细、功耗高。

### 1.6.5.5、CLK_DIVn

​    各模块的分频器参数配置

### 1.6.5.6、CLK_GATE_x

​    类似于CLK_SRC_MASK，对时钟进行开关控制。是在最终处的一个开关，而CLK_SRC_MASK是在时钟源处的开关。

### 1.6.5.7、CLK_DIV_STATn、CLK_MUX_STATn

​    这两类状态位寄存器，用来查看DIV和MUX的状态是否已经完成还是在进行中

总结：其中最重要的寄存器有3类：CON、SRC、DIV。其中CON决定PLL倍频到多少，SRC决定走哪一路，DIV决定分频多少。

 

## 1.6.6.汇编实现时钟设置代码详解1

### 1.6.6.1、时钟设置的步骤分析：

​    第1步：先选择不使用PLL。让外部24MHz原始时钟直接过去，绕过APLL那条路

​    第2步：设置锁定时间。默认值为0x0FFF，保险起见我们设置为0xFFFF

​    第3步：设置分频系统，决定由PLL出来的最高时钟如何分频得到各个分时钟

​    第4步：设置PLL，主要是设置PLL的倍频系数，决定由输入端24MHz的原始频率可以得到多大的输出频率。我们按照默认设置值设0置输出为ARMCLK为1GHz。

​    第5步：打开PLL。前面4步已经设置好了所有的开关和分频系数，本步骤打开PLL后PLL开始工作，锁定频率后输出，然后经过分频得到各个频率。

总结：以上5步，其实真正涉及到的寄存器只有5个而已。我们只是初略的设置好，真正的非常精细的设置好每个时钟还是远远不够的，我们先只学到这。

 

### 1.6.6.2、CLK_SRC寄存器的设置分析

​    CLK_SRC寄存器其实是用来设置MUX开关的。在这里先将该寄存器设置为全0，主要是bit0和bit4设置为0，表示APLL和MPLL暂时都不启用。

### 1.6.6.3、CLK_LOCK寄存器的设置分析

​    设置PLL锁定延时的。官方推荐值为0xFFF，我们设置为0xFFFF。

### 1.6.6.4、CLK_DIV寄存器的设置分析

0x14131440这个值的含义分析：

​    PCLK_PSYS = HCLK_PSYS / 2

​    HCLK_PSYS = MOUT_PSYS / 5

​    PCLK_DSYS = HCLK_DSYS / 2

​    HCLK_DSYS = MOUT_DSYS / 4

​    ·······

​    HCLK_MSYS = ARMCLK / 5

​    ARMCLK = MOUT_MSYS / 1

 

## 1.6.7.汇编实现时钟设置代码详解2

### 1.6.7.1、PLL倍频的相关计算

(1)、我们设置了APLL和MPLL两个，其他两个没有管。

(2)、APLL和MPLL设置的关键都是M、P、S三个值，这三个值都来自于官方数据手册的推荐值

(3)、M、P、S的设置依赖《4.2.C语言位运算》中讲过的位运算技术。

 

### 1.6.7.2、结合寄存器、时钟框图、代码三者综合分析S5PV210的时钟系统

​    分析时记得在图上做标记（把MUX开关选哪个和DIV分频多少都标出来）然后清楚了。

### 1.6.7.3、代码编译、烧写实验

 

### 1.6.8.C语言实现时钟设置代码详解

### 1.6.8.1、C和汇编操作寄存器的不同

​    语法写法不同，核心是一样的

### 1.6.8.2、C的优势：位运算更加简单

​    C语言还是要简单一些

### 1.6.8.3、用C语言重写时钟初始化代码

​    见视频过程

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

 

 

# 第七章 串口通信详解

## 1.7.0.章节概要

**1.7.1.通信涉及的几个基础概念**

​    本节讲述通信的发展历史，通信的基本原理，重点是通信所涉及到的3对主要概念：同步和异步、电平信号和差分信号、并行和串行接口。

**1.7.2.串口通信的基本概念**

​    本节讲述传输通信涉及到的基本概念，如：波特率、起始位、数据位、奇偶校验位、停止位、RS232电平、TTL电平等。主要学习目的是让大家对串口通信涉及到的主要概念做个了解，方便后续课程中使用。

**1.7.3.串口通信的基本原理**

​    本节讲解串口通信的基本原理，让大家明白串口通信时信息时如何在通信线上传播的，以及各种常见接口的通信线定义。

**1.7.4.S5PV210串行通信接口详解1**

​    本节主要讲述串口控制器的工作原理框图，试图让大家明白串口控制器内部发送器、接收器、波特率发生器、移位器等模块的工作原理。最后简单介绍了流控。

**1.7.5.S5PV210串行通信接口详解2**

​    本节详细介绍了S5PV210这类高级SoC中串口的三种扩展模式：FIFO模式、DMA模式、IrDA模式，以及各种模式的工作原理、使用方法。

**1.7.6.S5PV210串行通信接口详解3**

​    本节首先讲述串口和中断的关系，希望向大家引入串口发送/接收时的中断模式、轮询模式这两个概念；然后详细分析了串口控制器内部的时钟来源、波特率计算等。

**1.7.7.S5PV210串行通信编程实战1**

​    本节开始编写串口通信的程序，首先分析了程序框架，然后重点分析了串口控制器的几个主要寄存器的配置值，最后在C源程序中定义了访问串口控制器寄存器的主要宏定义。

**1.7.8.S5PV210串行通信编程实战2**

​    本节接上节继续来编写串口通信的程序，主要包括Tx、Rx对应的GPIO的初始化，波特率的计算和设置，串口发送和接收程序的编写等。最终实现210通过串口向外部发送信息。

**1.7.9.uart stdio的移植1**

​    本节开始讲基于S5PV210的串口输入/输出函数来移植stdio。首先讲了什么是标准输入输出，然后讲了移植stdio的3种途径，最后指出我们所使用的移植方法。

**1.7.10.uart stdio的移植2**

​    本节正式开始动手移植。分析了网络下载的别人移植好的printf函数源码，重点讲解了如何修改Makefile来使用printf函数源代码。

**1.7.11.uart stdio的移植3**

​    本节补充讲了上节课没讲到的链接脚本的问题。然后从C语言角度分析了printf函数实现原理、C语言可变参数、vsprintf函数中的实现细节等。

**1.7.12.串口实验烧录问题总结**

​    本节为补充章节，主要针对前面章节中代码usb下载无法正常运行，补充讲下SD卡运行上烧录运行代码的实验，并且希望大家看见实验现象以明确代码无误。

## 1.7.1.通信涉及的几个基础概念

### 1.7.1.1、通信的发展历史

(1)、最早通信：烽火台、狼烟；信件；电子通信（电报、电话、网络信号）

(2)、通信中最重要的两个方面：信息表示、解析方法 + 信息的传输方法

(3)、信息表示、解析方法：通信双方事先需要约定好信息的表示方法和解析方法，做到一致，否则信息不能有效传递

(4)、信号的传输方法是指经过编码后的通信信息如何在传输介质上传输的过程。

总结：通信过程其实分为3个步骤：

首先发送方先按照信息编码方式对有效信息进行编码（编程成可以在通信线路上传输的信号形态），

然后编码后的信息在传输介质上进行传输，输送给接收方；

最后接收方接收到编码信息后进行解码，解码后得到可以理解的有效信息。

 

### 1.7.1.2、电子通信概念1：同步通信和异步通信

(1)、同步和异步的区别：首先很多地方都有同步和异步的概念，简单来说就是发送方和接收方按照同一个时钟节拍工作就叫同步，发送方和接收方没有统一的时钟节拍、而各自按照自己的节拍工作就叫异步。

(2)、同步通信中，通信双方按照统一节拍工作，所以配合很好；一般需要发送方给接收方发送信息同时发送时钟信号，接收方根据发送方给它的时钟信号来安排自己的节奏。同步通信用在通信双方信息交换频率固定，或者经常通信时。优势：配合很好；缺点：需要加一根时钟信号线；

(3)、异步通信又叫异步通知。在双方通信的频率不固定时（有时3ms收发一次，有时3天才收发一次）不适合使用同步通信，而适合异步通信。异步通信时接收方不必一直在意发送方，发送方需要发送信息时会首先给接收方一个信息开始的起始信号，接收方接收到起始信号后就认为后面紧跟着的就是有效信息，才会开始注意接收信息，直到收到发送方发过来的结束标志。

 

### 1.7.1.3、电子通信概念2：电平信号和差分信号

(1)、电平信号和差分信号是用来描述通信线路传输方式的。也就是说如何在通信线路上表达1和0.（研究怎么表达1和0）

(2)、电平信号的传输线中有一个参考电平线（一般是GND），然后信号线上的信号值是由信号线电平和参考电平线的电压差决定。

(3)、差分信号的传输线中没有参考电平，所有都是信号线。然后1和0的表达靠信号线之间的电压差。

总结：电平信号的2根通信线之间的电平差异容易受到干扰，传输容易失败；差分信号不容易受到干扰因此传输质量比较稳定，现代通信一般都使用差分信号，电平信号几乎没有了。

总结2：看起来似乎相同根数的通信线下，电平信号要比差分信号要快；但是实际还是差分信号快，因为差分信号抗干扰能力强，因此1个发送周期更短。

 

### 1.7.1.4、电子通信概念3：并行接口和串行接口

(1)、串行、并行主要是考虑通信线的根数，就是发送方和接收方同时可以传递的信息量的多少

(2)、譬如在电平信号下，1根参考电平线+1根信号线可以传递1位二进制；如果我们有3根线（2根信号线+1根参考线）就可以同时发送2位二进制；如果想同时发送8位二进制就需要9根线。

(3)、在差分信号下，2根线（彼此差分）可以同时发送1位二进制；如果需要同时发送8位二进制，需要16根线。

总结：听起来似乎并行接口比串行接口要快（串行接口一次只能发送1位二进制，而并行接口一次可以发送多位二进制）要更优秀；但是实际上串行接口才是王道，用的比较广。因为更省信号线，而且对传输线的要求更低、成本更低；而且串行时可以通过提高通信速度来提高总体通信性能，不一定非得要并行。

 

总结：其实这么多年发展，最终胜出的是：异步、串行、差分，譬如USB和网络通信。

 

## 1.7.2.串口通信的基本概念

### 1.7.2.1、串口通信的特点：异步、电平信号、串行

(1)、异步：串口通信的发送方和接收方之间是没有统一的时钟信号的。

(2)、电平信号：串口通信出现的时间较早，速率较低，传输的距离较近，所以干扰还不太明显，因此当时使用了电平信号传输。后期出现的传输协议都改成差分信号传输了。

(3)、串行通信：串口通信每次同时只能传输1个二进制位。

 

### 1.7.2.2、RS232电平和TTL电平

(1)电平信号是用信号线电平减去参考线电平得到电压差，这个电压差决定了传输值是1还是0.

(2)在电平信号时多少V代表1，多少V代表0不是固定的，取决于电平标准。譬如RS232电平中-3V～-15V表示1；+3～+15V表示0；TTL电平则是+5V表示1，0V表示0.

(3)不管哪种电平都是为了在传输线上表示1和0.区别在于适用的环境和条件不同。

RS232：的电平定义比较大，适合干扰大、距离远的情况；我们台式电脑后面的串口插座就是RS232接口的，在工业上用串口时都用这个，传输距离小于15米；

TTL：电平电压范围小，适合距离近且干扰小的情况。TTL电平一般用在电路板内部两个芯片之间。

(5)对编程来说，RS232电平传输还是TTL电平是没有差异的。所以电平标准对硬件工程师更有意义，而软件工程师只要略懂即可。（把TTL电平和RS232电平混接是不可以的）

 

### 1.7.2.3、波特率

(1)波特率（bandrate），指的是串口通信的速率，也就是串口通信时每秒钟可以传输多少个二进制位。譬如每秒种可以传输9600个二进制位（传输一个二进制位需要的时间是1/9600秒，也就是104us），波特率就是9600.

(2)串口通信的波特率不能随意设定，而应该在一些值中去选择。一般最常见的波特率是9600或者115200（低端单片机如51常用9600，高端单片机和嵌入式SoC一般用115200）.为什么波特率不可以随便指定？主要是因为：第一，通信双方必须事先设定相同的波特率这样才能成功通信，如果发送方和接收方按照不同的波特率通信则根本收不到，因此波特率最好是大家熟知的而不是随意指定的。第二，常用的波特率经过长久发展，就形成了共识，大家常用就是9600或者115200.

 

### 1.7.2.4、起始位、数据位、奇偶校验位、停止位

(1)通信周期：，收发是一个周期一个周期进行的，没周期传输n个二进制位。这一个周期就叫做一个通信单元，一个通信单元是由：起始位+数据位+奇偶校验位+停止位组成的。

(2)起始位表示发送方要开始发送一个通信单元；数据位是一个通信单元中发送的有效信息位；奇偶校验位是用来校验数据位，以防止数据位出错的；停止位是发送方用来表示本通信单元结束标志的。起始位的定义是串口通信标准事先指定的，是由通信线上的电平变化来反映的。

(4)数据位是本次通信真正要发送的有效数据，串口通信一次发送多少位有效数据是可以设定的（一般可选的有6、7、8、9，99%情况下我们都是选择8位数据位。因为我们一般通过串口发送的文字信息都是ASCII码编码的，而ASCII码中一个字符刚好编码为8位。）

(5)奇偶校验位是用来给数据位进行奇偶校验（把待校验的有效数据逐个位的加起来，总和为奇数奇偶校验位就为1，总和为偶数奇偶校验位就为0）的，可以在一定程度上防止位反转。

(6)停止位的定义是串口通信标准事先指定的，是由通信线上的电平变化来反映的。常见的有1位停止位，1.5位停止位，2位停止位等。99%情况下都是用1位停止位。

总结：串口通信时因为是异步通信，所以通信双方必须事先约定好通信参数，这些通信参数包括：波特率、数据位、奇偶校验位、停止位（串口通信中起始位定义是唯一的，所以一般不用选择）

 

## 1.7.3.串口通信的基本原理

### 1.7.3.0、补充通信概念：单工通信和双工通信

(1)单工就是单方向，双工就是双方同时收发，同时只能但方向但是方向可以改变叫半双工

(2)如果只能A发B收则单工，A发B收或者B发A收（两个方向不能同时）叫半双工，A发B收同时B发A收叫全双工。

### 1.7.3.1、三根通信线：Rx Tx GND

(1)任何通信都要有信息传输载体，或者是有线的或者是无线的。

(2)串口通信是有线通信，是通过串口线来通信的。

(3)串口通信线最少需要2根（GND和信号线），可以实现单工通信，也可以使用3根通信线（Tx、Rx、GND）来实现全双工。

(4)一般开发板都会引出SoC上串口引脚直接输出的TTL电平的串口（X210开发板没有），插座用插针式插座，每个串口引出的都有3个线（Tx、Rx、GND），可以用这些插座直接连接外部的TTL电平的串口设备。

 

### 1.7.3.2、收发双方事先规定好通信参数（波特率、数据位、奇偶校验位、停止位等）

(1)串口通信属于基层基本性的通信规约，它自己本身不会去协商通信参数，需要通信前通信双方事先约定好通信参数（一般4个最重要的）

(2)串口通信的任何一个关键参数设置错误，都会导致通信失败。譬如波特率调错了，发送方发送没问题，接收方也能接收，但是接收到全是乱码···

 

### 1.7.3.3、信息以二进制流的方式在信道上传输

(1)、串口通信的发送方每隔一定时间（时间固定为1/波特率，单位是秒）将有效信息（1或者0）放到通信线上去，逐个二进制位的进行发送。

(2)接收方通过定时（起始时间由读到起始位标志开始，间隔时间由波特率决定）读取通信线上的电平高低来区分发送给我的是1还是0。依次读取数据位、奇偶校验位、停止位，停止位就表示这一个通信单元（帧）结束，然后中间是不定长短的非通信时间（发送方有可能紧接着就发送第二帧，也可能半天都不发第二帧，这就叫异步通信），下来就是第二帧·····

总结：

第一，波特率非常重要，波特率错了整个通信就乱套了；

第二，数据位、奇偶校验位、停止位也很重要，否则可能认不清数据。

第三，通过串口不管发数字、还是文本还是命令还是什么，都要先对发送内容进行编码，编码成二进制再进行逐个位的发送。

(3)串口发送的一般都是字符，一般都是ASCII码编码后的字符，所以一般设置数据位都是8，方便刚好一帧发送1个字符。

 

### 1.7.3.4、回顾：RS232电平和TTL电平的区别？串行通信为什么是异步的？为什么是串行而不是并行？

 

### 1.7.3.5、DB9接口介绍

(1)DB9接口是串口通信早期比较常用的一种规范化接口。

(2)串行通信在早期是计算机与外界通信的主要手段，那时候的计算机都有标准配置的串口以实现和外部通信。那时候就定义了一套标准的串口规约，DB9接口就是标准接口。

(3)DB9接口中有9根通信线，其中3根很重要，为GND、Tx、Rx，必不可少；剩余6根都是和流控有关的，现代我们使用串口都是用来做调试一般都禁用流控，所以这6根没用。

(4)现在一般使用串口时要记得把流控禁止掉，不然可能发生意想不到的问题。

 

## 1.7.4.S5PV210串行通信接口详解1

### 1.7.4.0、串口的名称

(1)S5PV210的数据手册中串口控制器在section8.1

(2)串口的官方名称叫：universal asynchronous reciver and transmitter，通用异步收发器

英文缩写是uart，中文简称串口。

### 1.7.4.1、S5PV210的串口控制器工作原理框图

(1)整个串口控制器包含transmitter和receiver两部分，两部分功能彼此独立，transmitter负责210向外部发送信息，receiver负责从外部接收信息到210内部。

(2)总线角度来讲，串口控制器是接在APB总线上的。对我们编程有影响的是：将来计算串口控制器的源时钟时是以APB总线来计算的。

(3)transmitter由发送缓冲区和发送移位器构成。我们要发送信息时，首先将信息进行编码（一般用ASCII码）成二进制流，然后将一帧数据（一般是8位）写入发送缓冲区（从这里以后程序就不用管了，剩下的发送部分是硬件自动的），发送移位器会自动从发送缓冲区中读取一帧数据，然后自动移位（移位的目的是将一帧数据的各个位分别拿出来）将其发送到Tx通信线上。（你只需要将数据发送到发送缓冲区就可以了，其他的由硬件自动完成，不用你管。）

(4)receiver由接收缓冲区和接收移位器构成。当有人通过串口线向我发送信息时，信息通过Rx通信线进入我的接收移位器，然后接收移位器自动移位将该二进制位保存入我的接收缓冲区，接收完一帧数据后receiver会产生一个中断给CPU，CPU收到中断后即可知道receiver接收满了一帧数据，就会来读取这帧数据。

总结：发送缓冲区和接收缓冲区是关键。发送移位器和接收移位器的工作都是自动的，不用编程控制的，所以我们写串口的代码就是：

首先初始化（初始化的实质是读写寄存器）好串口控制器（包括发送控制器和接收控制器）。

然后要发送信息时直接写入发送缓冲区，要接收信息时直接去接收缓冲区读取即可。可见，串口底层的工作（譬如怎么移位的、譬如起始位怎么定义的、譬如TTL电平还是RS232电平等）对程序员是隐藏的，程序员不用去管。软件工程师对串口操作的接口就是发送/接收缓冲区（实质就是寄存器，操作方式就是读写内存）

(5)串口控制器中有一个波特率发生器，作用是产生串口发送/接收的节拍时钟。波特率发生器其实就是个时钟分频器，它的工作需要源时钟（APB总线来），然后内部将源时钟进行分频（软件设置寄存器来配置）得到目标时钟，然后再用这个目标时钟产生波特率（硬件自动的）。

 

### 1.7.4.2、自动流控（AFC：Auto flow control）

(1)为什么需要流控？流控的目的是让串口通信非常可靠，在发送方速率比接收方快的时候流控可以保证发送和接收不会漏掉东西。

(2)现在为什么不用流控？现在计算机之间有更好更高级（usb、internet）的通讯方式，串口已经基本被废弃了。现在串口的用途更多是SoC用来输出调试信息的。由于调试信息不是关键性信息、而且由于硬件发展串口本身速度已经相对慢的要死了，所以硬件都能协调发送和接收速率，因此流控已经失去意义了，所以现在基本都废弃了。还有就是串口的另一端一般是USB ，USB的接收频率比串口的发送频率快多了，也就是发送方比接收方的频率慢，也就不会产生接收漏掉东西。

 

## 1.7.5.S5PV210串行通信接口详解2

### 1.7.5.0、串口的高级功能

本来串口的功能就是上节讲过的部分，但是后来的技术发展给串口叠加了一些高级功能，在像210这类的高级SoC的串口控制器中，都有这类高级功能。

### 1.7.5.1、FIFO模式及其作用

(1)典型的串口设计，发送/接收缓冲区只有1字节，每次发送/接收只能处理1帧数据。这样在单片机中没什么问题，但是到复杂SoC中（一般有操作系统的）就会有问题，会导致效率低下，因为CPU需要不断切换上下文。

(2)解决方案就是想办法扩展串口控制器的发送/接收缓冲区，譬如将发送/接收缓冲器设置为64字节，CPU一次过来直接给发送缓冲区64字节的待发送数据，然后transmitter慢慢发，发完再找CPU再要64字节。但是串口控制器本来的发送/接收缓冲区是固定的1字节长度的，所以做了个变相的扩展，就是FIFO。   

(3)FIFO就是first in first out，先进先出。fifo其实是一种数据结构，这里这个大的缓冲区叫FIFO是因为这个缓冲区的工作方式类似于FIFO这种数据结构。

 

### 1.7.5.2、DMA模式及其作用

(1)DMA direct memory access，直接内存访问。DMA本来是DSP中的一种技术，DMA技术的核心就是在交换数据时不需要CPU参与，模块可以自己完成。

(2)DMA模式要解决的问题和上面FIFO模式是同一个问题，就是串口发送/接收要频繁的折腾CPU造成CPU反复切换上下文导致系统效率低下。

(3)传统串口和FIFO 、DMA的使用环境：

传统的串口工作方式（无FIFO无DMA）效率是最低的，适合低端单片机；

高端单片机上CPU事物繁忙所以都需要串口能够自己完成大量数据发送/接收，这时候就需要FIFO或者DMA模式。

FIFO模式是一种轻量级的解决方案，DMA模式适合大量数据迸发式的发送/接收时。

 

### 1.7.5.3、IrDA模式及其用法

(1)IrDA其实就是红外，红外就是红外线通信（电视机、空调遥控器就是红外通信的）。

(2)红外通信的原理：是发送方固定间隔时间向接收方发送红外信号（表示1或0）或者不发送红外信号（表示0或者1），接收方每隔固定时间去判断有无红外线信号来接收1和0.

(3)分析可知，红外通信和串口通信非常像，都是每隔固定时间发送1或者0（判断1或0的物理方式不同）给接收方来通信。因此210就利用串口通信来实现了红外发送和接收。

(4)210的某个串口支持IrDA模式，开启红外模式后，我们只需要向串口写数据，这些数据就会以红外光的方式向外发射出去（当然是需要一些外部硬件支持的），然后接收方接收这些红外数据即可解码得到我们的发送信息。

 

## 1.7.6.S5PV210串行通信接口详解3

### 1.7.6.1、串行通信与中断的关系

(1)串口通信分为发送/接收2部分。发送方一般不需要（也可以使用）中断即可完成发送，接收方必须（一般来说必须，也可以轮询方式接收）使用中断来接收。

(2)发送方可以选择使用中断，也可以选择不使用中断。使用中断的工作情景是：发送方先设置好中断并绑定一个中断处理程序，然后发送方丢一帧数据给transmitter，transmitter发送耗费一段时间来发送这一帧数据，这段时间内发送方CPU可以去做别的事情，等transmitter发送完成后会产生一个TXD中断，该中断会导致事先绑定的中断处理程序执行，在中断处理程序中CPU会切换回来继续给transmitter放一帧数据，然后CPU切换离开；

不使用中断的工作情景是：发送方事先禁止TXD中断（当然也不需要给相应的中断处理程序了），发送方CPU给一帧数据到transmitter，然后transmitter耗费一段时间来发送这帧数据，这段时间CPU在这等着（CPU没有切换去做别的事情），待发送方发送完成后CPU再给它一帧数据继续发送直到所有数据发完。CPU是怎么知道transmitter已经发送完了？原来是有个状态寄存器，状态寄存器中有一个位叫发送缓冲区空标志，transmitter发送完成（发送缓冲区空了）就会给这个标志位置位，CPU就是通过不断查询这个标志位为1还是0来指导发送是否已经完成的。使用中断的工作情景CPU在不停的等在那发送数据，期间不能去干别的事情。

(3)因为串口通信是异步的，异步的意思就是说发送方占主导权。也就是说发送方随时想发就能发，但是接收方只有时刻等待才不会丢失数据。所以这个差异就导致发送方可以不用中断，而接收方不得不使用中断模式。（接收方不知道发送方什么时候发送，不能一直在那等着耗费时间，这就不能不得使用中断）

 

### 1.7.6.2、210串行通信接口的时钟设计

(1)串口通信为什么需要时钟？因为串口通信需要一个固定的波特率，所以transmitter和receiver都需要一个时钟信号。

(2)时钟信号从哪里来？源时钟信号是外部APB总线（PCLK_PSYS，66MHz）提供给串口模块的（这就是为什么我们说串口是挂在APB总线上的），然后进到串口控制器内部后给波特率发生器（实质上是一个分频器），在波特率发生器中进行分频，分频后得到一个低频时钟，这个时钟就是给transmitter和receiver使用的。

(3)串口通信中时钟的设置主要看寄存器设置。重点的有：寄存器源设置（为串口控制器选择源时钟，一般选择为PCLK_PSYS，也可以是SCLK_UART），还有波特率发生器的2个寄存器。

(4)波特率发生器有2个重要寄存器：UBRDIVn和UDIVSLOTn，其中UBRDIVn是主要的设置波特率的寄存器，UDIVSLOTn是用来辅助设置的，目的是为了校准波特率的。

 

## 1.7.7.S5PV210串行通信编程实战1

### 1.7.7.1、整个程序流程分析

(1)整个串口通信相关程序包含2部分：uart_init负责初始化串口，uart_putc负责发送一个字节

### 1.7.7.2、串口控制器初始化关键步骤

(1)初始化串口的Tx和Rx引脚所对应的GPIO（查原理图可知Tx和Rx分别对应GPA0_1和GPA0_0）

(2)GPA0CON（0xE0200000），bit[3:0] = 0b0010   bit[7:4] = 0b0010  

(3)初始化这几个关键寄存器UCON0 ULCON0 UMCON0 UFCON0 UBRDIV0 UDIVSLOT0

### 1.7.7.3、主要的几个寄存器

(1)ULCON0 = 0x3     // 0校验位、8数据位、1停止位

(2)UCON = 0x5      // 发送和接收都是polling mode

(3)UMCON0 = 0x0    // 禁止modem、afc（自动流控）

(4)UFCON0 = 0x0     // 禁止FIFO模式

(5)UBRDIV0和UDIVSLOT0和波特率有关，要根据公式去算的

 

### 1.7.7.4、在C源文件中定义访问寄存器的宏

定义好了访问寄存器的宏之后，将来写代码时直接使用即可。

 

## 1.7.8.S5PV210串行通信编程实战2

### 1.7.8.1、串口Tx、Rx对应的GPIO的初始化

​    给GPA0CON的相应bit位赋值为相应值，用C语言位操作来完成。

### 1.7.8.2、UCON、ULCON、UMCON、UFCON等主要控制寄存器

​    依据上节中分析的值进行依次设置即可。

### 1.7.8.3、波特率的计算和设置

(1)第一步，用PCLK_PSYS和目标波特率去计算DIV_VAL: DIV_VAL = (PCLK / (bps x 16)) ?1

(2)第二步，UBRDIV0寄存器中写入DIV_VAL的整数部分

(3)第三步，用小数部分*16得到1个个数，查表得uBDIVSLOT0寄存器的设置值

### 1.7.8.4、串口发送和接收函数的编写

(1)写发送函数，主要发送前要用while循环等待发送缓冲区为空才能发送。

### 1.7.8.5、综合调试

注意Makefile的修改。

### 1.7.8.6、扩展练习-更改波特率后再调试

自己练习。注意程序中改了波特率后，SecureCRT也要相应修改，不然收不到东西。

 

## 1.7.9.uart stdio的移植1

### 1.7.9.1、什么是stdio

(1)#include <stdio.h>

(2)stdio：standard input output，标准输入输出

(3)标准输入输出就是操作系统定义的默认的输入和输出通道。一般在PC机的情况下，标准输入指的是键盘，标准输出指的是屏幕。

(4)printf函数和scanf函数可以和底层输入/输出函数绑定，然后这两个函数就可以和stdio绑定起来。也就是说我们直接调用printf函数输出，内容就会被从标准输出输出出去。

(5)在我们这里，标准输出当然不是屏幕了，而是串口。标准输出也不是键盘，而是串口。

 

### 1.7.9.2、printf函数的工作原理

(1)printf函数工作时内部实际调用了2个关键函数：一个是vsprintf函数（主要功能是格式化打印信息，最终得到纯字符串格式的打印信息等待输出），另一个就是真正的输出函数putc（操控标准输出的硬件，将信息发送出去）

 

### 1.7.9.3、移植printf函数的三种思路

(1)我们希望在我们的开发板上使用printf函数进行（串口）输出，使用scanf函数进行（串口）输入，就像在PC机上用键盘和屏幕进行输入输出一样。因此需要移植printf函数/scanf函数

(2)我们说的移植而不是编写，我们不希望自己完全从新编写而是想尽量借用也有的代码（叫移植）

(3)一般移植printf函数可以有3个途径获取printf的实现源码：

最原始最原本的来源就是linux内核中的printk。难度较大、关键是麻烦；

稍微简单些的方法是从uboot中移植printf；

更简单的方法就是直接使用别人移植好的。

(4)我们课程中使用第三种方法，别人移植好的printf函数来自于友善之臂的Tiny210的裸机教程中提供的。

 

### 1.7.9.4、移植好的printf介绍

参考视频中讲解。

 

## 1.7.10.uart stdio的移植2

### 1.7.10.1、修改Makefile进行printf移植

​    .a文件是库文件

objs := div64.o lib1funcs.o ctype.o muldi3.o printf.o string.o vsprintf.o

 

libc.a: $(objs) //这里objs 相当一个变量包含了这么多.o文件。用$()去调用变量。

​    ${AR} -r -o $@ $^

​    

%.o:%.c

​    ${CC} $(CPPFLAGS) $(CFLAGS) -c -o $@ $<

 

%.o:%.S

​    ${CC} $(CPPFLAGS) $(CFLAGS) -c -o $@ $<

 

clean:

​    rm -f libc.a *.o       

​    

### 1.7.10.2、Makefile及gcc的库文件介绍

CC = arm-linux-gcc

LD = arm-linux-ld

OBJCOPY = arm-linux-objcopy

OBJDUMP = arm-linux-objdump

AR = arm-linux-ar

 

\#shell pwd ，pwd前为什么要加shell呢，这个shell相当于函数，将执行pwd的值返回来

INCDIR := $(shell pwd)

 

 

\# C预处理的flag，flag就是编译器可选的选项

\# nostdlib (不用标准库) nostdinc (不用标准头文件)

\# -Wall 所有的警告信息圈警告， -O2 优化级别 -fno-builtin 

\#编译链接的时候，全部用自己的，不用标准库里的东西。

\# 编译的时候如果要被编译的文件不再同文件夹下（路径），需要用—I指定被编译文件的所在路径

CPPFLAGS := -nostdlib -nostdinc -I$(INCDIR)/include  #include 是文件件  $(INCDIR)是当前路径

\# c编译器的flag

CFLAGS  := -Wall -O2 -fno-builtin

 

\#导出这些变量到全局，其实就是给子文件夹下面的Makeflie使用的

export CC LD OBJCOPY OBJDUMP AR CPPFLAGS CFLAGS INCDIR

 

objs := start.o led.o clock.o uart.o main.o

objs += lib/libc.a                       #告诉编译器去子文件夹寻找子目录的文件

 

uart.bin: $(objs)

​    $(LD) -Tlink.lds -o uart.elf $^

​    $(OBJCOPY) -O binary uart.elf uart.bin

​    $(OBJDUMP) -D uart.elf > uart_elf.dis

​    gcc mkv210_image.c -o mkx210

​    ./mkx210 uart.bin 210.bin

 

 

\#进入子文件夹去执行命令在退回来

lib/libc.a : 

​       cd lib; make; cd ..               

​       

%.o : %.S

​    $(CC) $(CPPFLAGS) $(CFLAGS) -o $@ $< -c 

 

%.o : %.c

​    $(CC) $(CPPFLAGS) $(CFLAGS) -o $@ $< -c 

 

clean:

​    rm *.o *.elf *.bin *.dis mkx210 -f

​    \#删除子文件夹的各个生成的文件

​    cd lib; make clean; cd ..       

​    

1.7.10.3、多文件夹裸机工程的结构解析

1.7.10.4、编译运行及测试

 

## 1.7.11.uart stdio的移植3

### 1.7.11.1、在移植后的uart stdio项目中添加link.lds链接脚本，指定连接地址到0xd0020010

### 1.7.11.2、gcc可变参数及va_arg介绍

(1)printf函数中首先使用了C语言的**可变参数**va_start/va_arg/va_end；

(2)建议大家先去baidu“C语言可变参数”，然后按照别人的教程、博客实际写几个简单的变参的使用示例，先明白可变参数怎么工作，然后再来分析这里。

\#include <stdarg.h>

\#include <stdio.h>

 

void variable_argument(int fix_argument1, int fix_argument2, ...)

{

  va_list ptr;

 

  va_start(ptr, fix_argument2);

  int first = va_arg(ptr, int);

  int second = va_arg(ptr, int);

  int third = va_arg(ptr, int);

  char* four = va_arg(ptr, char*);

  float five = va_arg(ptr, double);

​    int six  = va_arg(ptr,int);

​    int *seven = va_arg(ptr,int*);

  va_end(ptr);

 

  printf("first is %d, second is %d, third is %d, four is %s, five is %f,six is %d,seven is %d\n", first, second, third, four, five,six,*seven);

//first is 5, second is 2, third is -5, four is Hello, five is 3.141590,six is 0,seven is 0

  return;

}

 

int main(int argc, char** argv[])

{

​    int a =0;

​    int *p =&a;

  variable_argument(1, 2, 5, 2, -5, "Hello", 3.14159,*p,&a);

  return 0;

}

/** 

 ———————————————— 

版权声明：本文为CSDN博主「ericbars」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/ericbar/article/details/79558827

*/

### 1.7.11.3、vsprintf函数详解

printf

​    vsprintf

​       vsnprintf

​           number

vsprintf函数的作用是按照我们的printf传进去的格式化标本，对变参进行处理，然后将之格式化后缓存在一个事先分配好的缓冲区中。

printf后半段调用putc函数将缓冲区中格式化好的字符串直接输出到标准输出。

 

## 1.7.12.串口实验烧录问题总结

### 1.7.12.1、usb下载的问题

(1)USB下载时在Win7 X64系统下，下载前面章节的小代码时没问题，下载串口通信的小代码时也没问题，下载uart stdio的移植就有问题了。有时候下载不动、有时候能下载但是不运行、有时候又正常下载运行。我已经试过下载其他的dnw或dnw驱动更新，都无法解决。

### 1.7.12.2、SD卡镜像烧录

(1)SD卡烧录镜像做裸机实验，在第四部分1.4.2节中有讲过。

(2)本次我们在Windows下烧录（linux下的烧录参考以前的）

(3)Windows下烧录镜像是使用九鼎提供的工具（X210光盘资料\A盘\tools\x210_Fusing_Tool.exe），注意运行时右键“以管理员身份运行”。

### 1.7.12.3、启动方式设置

(1)X210开发板的启动方式的选择，请参考1.2.11节。其实就是OM5的问题，OM5设置为VCC则从USB启动，OM5设置成GND，则从iNand/SD卡启动。

(2)开发板选择从iNand启动后，还要确保iNand中uboot是被擦除的。

(3)关于如何破坏uboot的问题，大家可以参考之前课程中讲的在linux/android系统中破坏uboot的方法。我之前讲过在uboot中破坏uboot的方法：movi write u-boot 0x30000000。很多同学反映擦除后错乱，进不了系统也从SD卡启动不了，只能通过USB刷机来解决。后来又分析，改为：mw 0x30000000 0x0 0x100000，然后再movi write u-boot 0x30000000

。但是反馈结果有人说可以了，有人说还是不行·······

(4)不管怎么擦除uboot，总之首先确保你的板子SD卡启动是成功的。怎么确保？先用SD卡烧录启动之前的LED闪烁的项目，确保看到现象就证明烧录SD卡方法和启动SD卡都成功了，再做本节课的实验。

### 1.7.12.4、链接脚本的影响

### 1.7.12.5、bin文件大于16KB怎么办？

通过USB下载最多也只能下载96KB大小的bin，如果bin大于96KB肯定SRAM放不下会出错。如果用SD卡启动，那么mkv210_image.c决定了bin文件最大不能超过16KB。

超过了怎么办？2种解法：

第一，在USB下载时，可以先下载一个x210_usb.bin，然后再将裸机程序连接到0x23E00000，然后再修改dnw中下载地址，将裸机代码下载到0x23E00000运行。（这时不需要重定位了）

第二，在SD卡启动时，将整个裸机工程分为2部分；第一部分大小16KB以内，第二部分放剩下的（放在SD卡的后面的某个扇区开始的位置，譬如放在第50个扇区开始的位置），然后在裸机代码中进行重定位（SD卡中重定位）。这个暂时没讲，以后如果有用到就讲。

 

 

 

 

 

 

 

 

 

 



 

 

 

 

 

 

# 第八章 按键和CPU的中断系统

## 1.8.0 章节概要

**1.8.1.什么是按键**

​    本节介绍按键的原理、结构和工作原理，着重介绍了按键的电路接法和按下、弹起时对电路的影响；最后介绍了SoC处理按键时的2种思路。

**1.8.2.轮询方式处理按键**

​    本节以轮询方式处理按键，从零开始分析电路接法、原理图，然后查阅数据手册，手写代码，最终实现对开发板上6个按键的捕获，以LED点亮的方式来检验按键输出结果。

**1.8.3.串口输出和按键消抖**

​    本节包含2部分内容。首先基于我们第七部分移植的串口stdio输出项目来实现按键轮询方式的调试，让大家学会用串口输出的方式调试程序；其次讲了按键的硬件、软件消抖，并在我们的轮询方式检测按键中添加消抖处理。

**1.8.4.S5PV210的中断体系介绍**

​    本节首先引入中断的概念，然后讲了SoC中中断的实现原理（异常向量表）。随后讲了S5PV210的异常向量表分布，最后讲了下异常和中断这两个概念的基本区别。

**1.8.5.异常向量表的编程处理**   

​    本节接上节讲述的理论，来编程处理S5PV210的异常向量表，其中最主要的是中断和快速中断这两个异常向量的处理，重点讲了S5PV210的中断处理第一阶段（汇编保存和恢复上下文阶段）

**1.8.6.S5PV210的向量中断控制器**

​    本节详细介绍S5PV210的向量中断控制器，而且首先讲了2440中中断处理的思路和方法，和210进行了比对。目的是让大家知道哪些特性是所有CPU共有的，哪些是CPU特有的，以将我们学到的知识运用在以后遇到的各种SoC中。

**1.8.7.S5PV210中断处理的主要寄存器**

​    本节详细介绍S5PV210的中断控制器中的主要寄存器，分析这些寄存器的作用有助于理解210的中断控制器的工作原理，进而分析其编程方法。

**1.8.8.S5PV210中断处理的编程实践1**

​    本节对S5PV210的中断控制器进行第二阶段的编程实战。因为代码量大所以提前写好了代码，主要是向大家讲解各部分代码的作用和工作原理。

**1.8.9.S5PV210中断处理的编程实践2**

​    本节对S5PV210的中断控制器进行第二阶段的编程实战。因为代码量大所以提前写好了代码，主要是向大家讲解各部分代码的作用和工作原理。

**1.8.10.外部中断**

​    本节向大家引入外部中断的概念。外部中断是210各种中断源的其中一类，按键就属于外部中断的范畴。本节同时介绍了外部中断相关的概念如电平触发和边沿触发。

**1.8.11.中断方式处理按键编程实践1**

​    本节完成中断方式处理按键的全部编程工作，系统梳理整个中断发生及处理的流程。最后总结对比了轮询方式处理按键和中断方式处理按键的差异。

**1.8.12.中断方式处理按键编程实践2**

​    本节完成中断方式处理按键的全部编程工作，系统梳理整个中断发生及处理的流程。最后总结对比了轮询方式处理按键和中断方式处理按键的差异。

## 1.8.1.什么是按键

### 1.8.1.1、按键的物理特性

(1)、平时没人按的时候，弹簧把按键按钮弹开。此时内部断开的。

(2)、有人按下的时候，手的力量克服弹簧的弹力，将按钮按下，此时内部保持接通（闭合）状态；如果手拿开，则弹簧作用下按钮又弹开，同时内部又断开。

(3)、一般的按键都有4个引脚，这4个引脚成2对：其中一对是常开触点（像上面描述的不按则断开，按下则闭合）；一对是常闭触点（平时不按时是闭合的，按下后是断开的）

### 1.8.1.2、按键的电学原理（结合原理图分析）

(1)硬件接法：    SW5:GPH0_2 SW6:GPH0_3 SW78910:GPH2_0123

(2)按键的电路连接分析：平时按钮没有按下时，按钮内部断开，GPIO引脚处电压为高电平；当有人按下按钮时，按钮内部导通，外部VDD经过电阻和按钮连接到地，形成回路，此时GPIO引脚处电压就变成了低电平。此时VDD电压全部分压在了电阻上（这个电阻就叫分压电阻，这个电阻不能太小，因为电阻的功率是U*U/R）

(3)总结：按键的工作方法：其实就是按键的按下与弹开，分别对应GPIO的两种电平状态（按下则GPIO为低电平，弹开则GPIO为高电平）。此时SoC内部可以通过检测这个GPIO的电平高低来判断按键有没有被按下，这个判断结果即可作为SoC的输入信号。

 

### 1.8.1.3、按键属于输入类设备

(1)按键一般用来做输入设备（由人向SoC发送信息的设备，叫输入设备），由人向SoC发送按键信号（按键信号有2种：按下信号和弹开信号）。

(2)有些设备就是单纯的输入设备，譬如按键、触摸屏等；有些设备就是单纯的输出设备，譬如LCD；还有一些设备是既能输入又能输出的，叫输入输出设备（IO），譬如串口。

 

### 1.8.1.4、按键的2种响应方法

(1)SoC处理按键有2种思路：轮询方式和中断方式。

(2)轮询方式，就是SoC主动的每隔一段时间去读取（按键所对应的）GPIO的电平高低，以此获得按键信息；缺点在于CPU要一直注意按键事件，会影响CPU做其他事情。

(3)中断方式，就是SoC事先设定好GPIO触发的中断所对应的中断处理程序ISR，当外部按键按下或弹开时会自动触发GPIO对应的外部中断，导致ISR执行，从而自动处理按键信息。

 

## 1.8.2.轮询方式处理按键

### 1.8.2.1、X210开发板的按键接法

(1)查原理图，找到按键对应的GPIO：SW5:GPH0_2    SW6:GPH0_3 SW78910:GPH2_0123

(2)原理图上可以看出：按下时是低电平，弹起时是高电平

### 1.8.2.2、按键对应的GPIO模式设置

(1)按键接到GPIO上，按键按下还是弹起，决定外部电路的接通与否，从而决定这个GPIO引脚的电压是高还是低；这个电压可以作为这个GPIO引脚的输入信号，此时GPIO配置为输入模式，即可从SoC内部读取该引脚的电平为1还是0（1对应高电平，0对应低电平）。

(2)GPH0CON(0xE0200C00) GPH2DAT(0xE0200C04) GPH2CON(0xE0200C40) GPH2DAT(0xE0200C44)

(3)应该在CON寄存器中将GPIO设置为input模式，然后去读取DAT寄存器（读取到的相应位的值为1表示外部是高电平（对应按键弹起），读取到的位的值为0表明外部是低电平（按键按下））

 

### 1.8.2.3、轮询方式处理按键的程序流程

(1)第一步，先初始化GPIO模式为input；

(2)第二步，循环读取GPIO的电平值，然后判断有无按键按下

### 1.8.2.4、代码编写和调试

 

## 1.8.3.串口输出和按键消抖

### 1.8.3.1、基于串口标准输出的按键调试

(1)以之前的串口stdio的工程为基础来移植添加轮询方式按键处理。

(2)注意USB下载方式可能有错误（有可能不下载，也有可能下载了执行不对），解决方案是用SD卡启动来替代。

### 1.8.3.2、什么是按键消抖

(1)按键这种物理器件本身会有抖动信号，抖动信号指的是在电平由高到低（也就是按键按下时）或者电平由低到高（也就是按键弹起时）过程中，电平的变化不是立刻变化，而是经过了一段时间的不稳定期才完成变化，在这个不稳定期间电平可能会时高时低反复变化，这个不稳定期就叫抖动（抖动期内获取按键信息是不可靠的，要想办法消抖）。

(2)什么叫消抖？消抖就是用硬件或者软件方法来尽量减小抖动期对按键获取的影响。消抖常用2种思路：第一是硬件消抖，消抖思路就是尽量减小抖动时间，方法是通过硬件添加电容等元件来减小抖动；第二是软件消抖，消抖思路是发现一次按键按下/弹起事件后，不立即处理按键，而是延时一段时间（一般10～20ms，这就是消抖时间）后再次获取按键键值，如果此次获取和上次一样是按下/弹起，那就认为真的按下/弹起了。

(3)一般比较精密需要的时候，需要硬件消抖和软件消抖一起配合。

### 1.8.3.3、编程实践

 

## 1.8.4.S5PV210的中断体系介绍

### 1.8.4.1、什么是中断

(1)中断的发明是用来解决宏观上的并行需要的。宏观就是从整体上来看，并行就是多件事情都完成了。

(2)微观上的并行，就是指的真正的并行，就是精确到每一秒甚至每一刻，多个事情都是在同时进行的。宏观上面的并行并不等于围观的并行，有时候宏观上是并行的，微观上是串行的。

(3)例子中一个人在看电影，快递来了暂停电影跑去收快递，收完快递继续回来看电影，这个例子就是宏观上的并行和微观上的串行。例子中一个人等同于SoC中1个CPU（也就是单核CPU），这个CPU看电影就不能收快递，收快递就不能看电影（也就是说不能真正的并行）。单核心CPU在微观角度是串行的，但是因为CPU很快，所以在宏观看来可以并行。

(4)上例中大部分时间在看电影，中间少量时间去收快递，那么类比于CPU来说，看电影就应该是CPU的常规任务，而收快递则应该是中断例程。也就是说CPU平时一直在进行看电影任务，等快递来了（中断发生了）快递员（类似于中断源）会打电话叫人去收快递（中断源会触发中断通知CPU去处理中断），人收到电话（CPU收到中断信号）后会暂定电影（CPU保存常规任务的现场）跑去收快递（CPU去执行中断处理程序ISR处理中断），收完快递（执行完ISR）回来继续看电影（CPU恢复常规任务的现场，继续执行常规任务）

(5)为什么需要中断？因为单核CPU实际无法并行的，但是通过中断机制，可以实现假并行（宏观上的并行，微观上实际还是串行的）。

 

### 1.8.4.2、SoC对中断的实现机制：异常向量表

(1)异常向量表是CPU中某些特定地址的特定定义。当中断发生的时候，中断要想办法通知CPU去处理中断，怎么做到？这就要靠异常向量表。

(2)在CPU设计时，就事先定义了CPU中一些特定地址作为特定异常的入口地址（譬如定义0x00000000地址为复位异常向量地址，则发生复位异常时CPU会**自动**跳转到0x00000000地址去执行指令。又譬如外部中断对应的异常向量地址为0x30000008，则发生外部中断后，CPU会**硬件自动跳转到**0x30000008地址去执行指令。）如

(3)以上讲的是CPU硬件设计时对异常向量表的支持，下来就需要软件支持了。硬件已经决定了发生什么异常CPU自动跳转PC到哪个地址去执行，软件需要做的就是把处理这个异常的代码的首地址填入这个异常向量地址。

 

### 1.8.4.3、S5PV210的异常向量表

(1)异常向量表在1.2.14节讲过，可以返回去听一下

(2)异常向量表中各个向量的相对位置是固定的，但是他们的起始地址是不固定的，各种SoC可以不一样，而且复杂ARM中还可以让用户来软件设置这个异常向量表的基地址。

(3)扩展到所有架构的CPU中：所有架构（譬如51单片机、PIC单片机）的CPU实现中断都是通过异常向量表实现的，这个机制是不变的；但是不同CPU异常向量表的构造和位置是不同的。

 

### 1.8.4.4、异常和中断的区别和联系

(1)针对SoC来说，发生**复位（reset）**、**软中断（software interrupt）**、**中断(IRQ)**、**快速中断(FIQ)**、**取指令异常（prefetch Abort）**、**数据异常等（Data interrupt）**，我们都统一叫异常。所以说：中断其实是异常的一种。

(2)异常的定义就是突发事件，打断了CPU的正常常规业务，CPU不得不跳转到异常向量表中去执行异常处理程序；中断是异常的一种，一般特指SoC内的内部外设产生的打断SoC常规业务，或者外部中断（SoC的GPIO引脚传回来的中断）。

 

## 1.8.5.异常向量表的编程处理

### 1.8.5.1、像内存一样去访问异常向量表

(1)S5PV210的异常向量表可以改变（在CP15协处理器中），以适应操作系统的需求。但是目前系统刚启动时，此时DRAM尚未初始化，程序都在SRAM中运行。210在iRAM中设置了异常向量表，供暂时性使用。

(2)查210的iROM application note文档中iRAM的地址分配，可知，iRAM中的异常向量表起始地址为0xD0037400。知道了异常向量表的起始地址后，各个异常对应的入口就很好知道了。

### 1.8.5.2、函数名的实质就是函数的首地址

(1)函数名在C语言中的理解方法和变量名其实没区别。编译器会把这个函数的函数体对应的代码段和这个函数的函数名（实质是符号）对应起来，等我们在使用这个函数名符号时，编译器会将函数的函数体实际上做替换。因为函数体都不止4字节，而函数名这个符号只能对应1个地址，所以实际对应的是函数体那一个代码段的首地址。

(2)拿C语言中的语法来讲，函数名就是这个函数的函数指针。

 

**总结：**当我们将异常处理程序的首地址和异常向量表绑定起来后，异常处理初步阶段就完成了。到目前可以保证相应异常发生后，**硬件自动跳转**到对应异常向量表入口去执行时，可以执行到我们事先绑定的函数。

 

### 1.8.5.3、为什么中断处理要先在汇编中进行

(1)中断处理要注意保护现场（中断从SVC模式来，则保存SVC模式下的必要寄存器的值）和恢复现场（中断处理完成后，准备返回SVC模式前，要将保存的SVC模式下的必要寄存器的值恢复回去，不然到了SVC模式后寄存器的值乱了，SVC模式下原来正在进行的常规任务就被你搞坏了）。

(2)保存现场包括：

第一：设置IRQ栈；

第二，保存LR；

第三，保存R0～R12

(3)为什么要保存LR寄存器？要考虑中断返回的问题。中断ISR执行完后如何返回SVC模式下去接着执行原来的代码。中断返回其实取决于我们进入中断时如何保存现场。中断返回时关键的2个寄存器就是PC和CPSR。所以我们在进入IRQ模式时，应该将SVC模式下的下一句指令的地址（中断返回地址）和CPSR保存起来，将来恢复时才可以将中断返回地址给PC，将保存的CPSR(存在当前模式下的SPSR)给CPSR。

(4)中断返回地址就保存在LR中，而CPSR（自动）保存在（IRQ模式下的）SPSR中

 

### 1.8.5.4、汇编保存现场和恢复现场

(1)保护现场关键是保存：中断处理程序的返回地址，r0-r12（cpsr是自动保存的）

(2)恢复现场主要是恢复：r0-r12，pc，cpsr

​    IRQ_handle:

​    //设置IRQ模式下的栈

​    ldr sp, =IRQ_STACK

​    //保存LR

​    //因为ARM有流水线，所以pc的值会比正真执行的代码+8 ，取地址，解码，执行，刚好要加8，所以lr 的地址要减去4

​    sub lr,lr,#4

​    //保存r0-r12和lr到irq模式下面的栈上面

​    ldmfd sp!, {r0-r12,lr}

​    //再次调用真正的isr来处理中断

​    bl irq_handler

​    //处理完成开始恢复现在，其实就是做中断返回，关键是将r0-r12,pc,cpsr一起恢复

​    stmfd sp!, {r0-r12,pc}^

 

​    ！号表示sp会自动叠加，因为有多个寄存器的数据个，将寄存器的数据压入栈后sp会自己增加地址。

​    PC 是将当前的lr中的地址赋值给PC

​    ^这个符号就是将SPSR 中的状态赋值给当前模式的CPSR。

​    

 

## 1.8.6.S5PV210的向量中断控制器

### 1.8.6.1、异常处理的2个阶段

(1)可以将异常处理分为2个阶段来理解：

第一个阶段是异常向量表跳转；

第二个阶段就是进入了真正的异常处理程序irq_handler之后的部分。

### 1.8.6.2、回顾：中断处理的第一阶段（异常向量表阶段）处理。

(1)**第一个阶段**之所以能够进行，主要依赖于CPU设计时提供的异常向量表机制。第一个阶段的主要任务是从异常发生到响应异常并且保存/恢复现场、跳转到真正的异常处理程序处。

(2)**第二个阶段**的目的是识别多个中断源中究竟哪一个发生了中断，然后调用相应的中断处理程序来处理这个中断。    

(3)  // SoC支持很多个（在低端CPU例如2440中有30多个，在210中有100多个）中断这么多中断irq在第一个阶段走的是一条路，都会进入到irq_handler来我们在irq_handler中要去区分究竟是哪个中断发生了，然后再去调用该中断对应的**isr**。

### 1.8.6.3、S3C2440的第二阶段处理过程

(1)**第一个问题**，怎么找到具体是哪个中断：S3C2440的中断控制器中有一个寄存器（32位的），寄存器的每一个位对应一个中断源（为了解决支持更多中断源，2440又设计了一个子中断机制。在一级中断寄存器中有一些中断是共用的一个bit位，譬如AC97和WDT。对于共用中断，用子中断来区分究竟是哪一个发生了中断）。

(2)**第二个问题**，怎么找到对应的isr的问题：首先给每个中断做了个编号，进入isr_handler之后先通过查阅中断源寄存器和子中断寄存器（中哪一位为1）确定**中断的编号**，然后用这个编号去isr数组（isr数组是中断初始化时事先设定好的，就是把各个中断的isr的函数名组成一个数组，用中断对应的编号作为索引来查询这个数组）中查阅得到isr地址。

评价：2440的中断处理设计不是特别优秀：第一个过程中使用子中断搞成2级的很麻烦；第二个过程中计算中断编号是个麻烦事，很耗费时间。而中断处理的时间是很宝贵的（系统有一个性能指标，叫实时性。实时性就是中断发生到响应的时间，这个时间越短越好。）

 

### 1.8.6.4、S5PV210的第二阶段处理过程

(1)**第一个问题**，怎么找到具体是哪个中断：S5PV210中因为支持的中断源很多，所以直接设计了4个中断寄存器，每个32位，每位对应一个中断源。（理论上210最多支持128个中断，实际支持不足128个，有些位是空的）；210没有子中断寄存器，每个中断源都是并列的。当中断发生时，在irq_handler中依次去查询4个中断源寄存器，看哪一个的哪一位被置1，则这个位对应的寄存器就发生了中断，即找到了中断编号。

(2)**第二个问题**，怎么找到对应的isr的问题：210中支持的中断源多了很多，如果还使用2440的那一套来寻找isr地址就太慢了，太影响实时性了。于是210开拓了一种全新的寻找isr的机制。210提供了很多寄存器来解决每个中断源对应isr的寻找问题，具体寻找过程和建立过程见下节，**实现的效果**是当发生相应中断时，硬件会自动的将相应isr推入一定的寄存器中，我们软件只要去这个寄存器中执行函数就行了。

 

### 1.8.6.5、总结：第一阶段都相同，第二阶段各不同

(1)第一阶段（异常向量表阶段）2440和210几乎是完全相同的。实际上几乎所有的CPU在第一阶段都是相同的。

(2)第二阶段就彼此不同了。各个SoC根据自己对实时性的要求，和支持的中断源的多少，各自发明了各自处理中断，找到中断编号，进一步找到对应isr地    址的方式。

 

## 1.8.7.S5PV210中断处理的主要寄存器

### 1.8.7.1、VICnINTENABLE和VICnINTENCLEAR 

(1)VICnINTENABLE 对应interrupt enable，INTENCLEAR对应interrupt enable clear

(2)INTENABLE寄存器负责相应的中断的使能，INTENCLEAR寄存器负责相应的中断的禁止。

(3)当我们想使能（意思就是启用这个中断，意思就是当硬件产生中断时CPU能接收的到）某个中断时，只要在这个中断编号对应的VICnINTENABLE的相应bit位写1即可。

（注意这个位写1其他位写0对其他位没有影响）；如果我们想禁止某个中断源时，只要向VICnINTENCLEAR中相应的位写1即可。

注意：**这里的设计一共有2种**：

有些CPU是中断使能和禁止是一个寄存器位，写1就使能，写0就进制（或者反过来写1就进制写0就使能），这样的中断使能设计就要非常小心，要使用我们之前说过的读改写三部曲来操作；

另一种就是使能和禁止分开为2个寄存器，要使能就写使能寄存器，要禁止就写禁止寄存器。这样的好处是我们使能/禁止操作时不需要读改写，直接写即可。

### 1.8.7.2、VICnINTSELECT

(1)设置各个中断的模式为irq还是fiq。一般都设置成irq

(2)IRQ和FIQ究竟有何区别。210中支持2种中断，irq和fiq。irq是普通中断，fiq是快速中断。快速中断提供一种更快响应处理的中断通道，用于对实时性要求很高的中断源。fiq在CPU设计时预先提供了一些机制保证fiq可以被快速处理，从而保证实时性。fiq的限制就是只能有一个中断源被设置为fiq，其他都是irq。

(3)CPU如何保证fiq比irq快？**有2个原因**：

第一，fiq模式有专用的r8～r12，因此在fiq的isr中可以直接使用r8-r12而不用保存，这就能节省时间；

第二，异常向量表中fiq是最后一个异常向量入口。因此fiq的isr不需要跳转，可以将代码直接写在原地，而不是像其他模式只有4个字节不能将代码直接放入，只能放入地址用指针来跳转到真正放代码的地址。这样就比其他异常少跳转一次，省了些时间。

### 1.8.7.3、VICnIRQSTATUS和VICnFIQSTATUS

(1)中断状态寄存器，是只读的。当发生了中断时，硬件会自动将该寄存器的对应位置为1，表示中断发生了。软件在处理中断第二阶段的第一阶段，就是靠查询这个寄存器来得到中断编号的。

### 1.8.7.4、VICnVECTPRIORITY0～VICnVECTPRIORITY31

(1)中断优先级设置寄存器，设置多个中断同时发生时先处理谁后处理谁的问题。一般来说高优先级的中断可以打断低优先级的中断，从而嵌套处理中断。当然了有些硬件/软件可以设置不支持中断嵌套。

### 1.8.7.5、VICnVECTADDR0～VICnVECTADDR31、VICnADDR

(1)这三个寄存器和210中断处理第二阶段的第二阶段有关。

(2**)VICnVECTADDR0**到31这32个寄存器分别用来存放真正的各个中断**对应的isr的函数地址**。相当于每一个中断源都有一个VECTADDR寄存器，程序员在设置中断的时候，把这个中断的isr地址直接放入这个中断对应的VECTADDR寄存器即可。

(3)**VICnADDR**这个寄存器是只需要读的，它里面的内容是由硬件自动设置的。当发生了相应中断时，**硬件会自动识别中断编号**，并且会自动找到这个中断的**VECT**ADDR寄存器，然后将其读出复制到VICnADDR中，供我们使用。这样的设计避免了软件查找中断源和isr，节省了时间，提高了210的中断响应速度。

 

## 1.8.8.S5PV210中断处理的编程实践1

### 1.8.8.1、上节中代码中的小问题

主要集中在start.S中，原因就是不常写，格式忽略。解决方案就是编译时发现再解决。

### 1.8.8.2、中断控制器初始化

主要工作有：

(1)第一阶段绑定异常向量表到异常处理程序；

(2)禁止所有中断源；

(3)选择所有中断类型为IRQ；

(4)清理VICnADDR寄存器为0.

### 1.8.8.3、中断的使能与禁止

思路是先根据中断号判断这个中断属于VIC几，然后在用中断源减去这个VIC的偏移量，得到这个中断号在本VIC中的偏移量，然后1<<x位，写入相应的VIC的INTENABLE/INTENCLEAR寄存器即可。

 

### 1.8.8.4、绑定自己实现的isr到VICnVECTADDR

(1)搞清楚2个寄存器的区别：VICnVECTADDR和VICnADDR

(1)VICVECTADDR寄存器一共有4×32个，每个中断源都有一个VECTADDR寄存器，我们应该将自己为这个中断源写的isr地址丢到这个中断源对应的VECTADDR寄存器中即可。

 

### 1.8.8.5、真正的中断处理程序如何获取isr

(1)当发生中断时，硬件会自动把相应中断源的isr地址从VICnVECTADDR寄存器中推入VICnADDR寄存器中，所以我们第二阶段的第二阶段isr_handler中，只需要到相应的VICnADDR中去拿出isr地址，调用执行即可。

 

总结：第4步绑定isr地址到VICnVECTADDR和第5步中断发生时第二阶段的第二阶段如何获取isr地址，这两步是相关的。这两个的结合技术，就是我们一直在说的210的硬件自动寻找isr的机制。

 

整个中断的流程梳理：

整个中断的工作分为2部分：

第一部分是我们为中断响应而做的预备工作：

​    \1. 初始化中断控制器

​    \2. 绑定写好的isr到中断控制器

​    \3. 相应中断的所有条件使能

第二部分是当硬件产生中断后如何自动执行isr：

​    \1. 第一步，经过异常向量表跳转入IRQ/FIQ的入口

​    \2. 第二步，做中断现场保护（在start.S中），然后跳入isr_handler

​    \3. 第三步，在isr_handler中先去搞清楚是哪个VIC中断了，然后直接去这个VIC的ADDR

​              寄存器中取isr来执行即可。

​    \4. 第四步，isr执行完，中断现场恢复，直接返回继续做常规任务。

 

## 1.8.9.S5PV210中断处理的编程实践2

 

\#include"stdio.h"

\#include"int.h"

\#include"main.h"

 

*//#define DEBUG_init*

*/***********************************************************************************************/*

*/**                   *假中断程序*                       **/*  

*/***********************************************************************************************/*  

 

void  reset_exception(void)

{

  printf("reset_exception.\n");

}

 

void  undef_exception(void)

{

  printf("undef_exception.\n");

}

void data_exception(void){

 

}

void  soft_int_exception(void)

{

  printf("soft_inttr_exception.\n");

}  

 

void  prefetch_exception(void)

{

  printf("prefetch_xception.\n");

}




*/***********************************************************************************************/*

*/**   *主要功能：绑定第一阶段异常向量表；禁止所有中断；选择所有中断类型为**IRQ**；*       **/*

*/**                *清除**VICnADDR**为**0                       \*/*  

*/***********************************************************************************************/*  

 

void system_init_exception(void)

{

  r_exception_reset   =  (unsigned int)reset_exception;

  r_exception_undef   =  (unsigned int)undef_exception;

  r_exception_soft_int  =  (unsigned int)soft_int_exception;

  r_exception_prefetch  =  (unsigned int)prefetch_exception;

  r_exception_data    =  (unsigned int )data_exception;

  r_exception_irq    =  (unsigned int)irq_handle;

  r_exception_fiq    =  (unsigned int)irq_handle;  

  

\#ifdef DEBUG_init

printf("test:  system_init_exception\n");

\#endif 

 

  intc_init();

}

 

*/***********************************************************************************************/*

*/**                    *初始化中断控制器*                   **/*  

*/***********************************************************************************************/*

void intc_init()

{

  *//* *禁止所有中断*

  *//* *为什么在中断初始化之初要禁止所有中断？*

  *//* *因为中断一旦打开，因为外部或者硬件自己的原因产生中断后一定就会寻找**isr*

  *//* *而我们可能认为自己用不到这个中断就没有提供**isr**，这时它自动拿到的就是乱码*

  *//* *则程序很可能跑飞，所以不用的中断一定要关掉。*

  *//* *一般的做法是先全部关掉，然后再逐一打开自己感兴趣的中断。一旦打开就必须*

  *//* *给这个中断提供相应的**isr**并绑定好。*

  

  VIC0INTENCLEAR = 0xffffffff;

  VIC1INTENCLEAR = 0xffffffff;

  VIC2INTENCLEAR = 0xffffffff;

  VIC3INTENCLEAR = 0xffffffff;

\#ifdef DEBUG_init

printf("test:  intc_init\n");

\#endif 

  

  intc_intselect();

  

}

 

*/***********************************************************************************************/*

*/**                 *选择寄存器是**IRQ**还是**FIQ**模式*                  **/*  

*/***********************************************************************************************/*

void intc_intselect()

{

   *//* *选择中断类型为**IRQ*

  VIC0INTSELECT = 0x0;

  VIC1INTSELECT = 0x0;

  VIC2INTSELECT = 0x0;

  VIC3INTSELECT = 0x0;

 

\#ifdef DEBUG_init

printf ("test:  intc_intselect\n");

\#endif   

  intc_clearvectaddr();

}

 

*/************************************************************************************************/*

*/**           *清除需要处理的中断的中断处理函数的地址*                 **/*

*/************************************************************************************************/*

 

void intc_clearvectaddr(void) 

{

  *// VICxADDR:**当前正在处理的中断的中断处理函数的地址*

  VIC0ADDR = 0;

  VIC1ADDR = 0;

  VIC2ADDR = 0;

  VIC3ADDR = 0;

\#ifdef DEBUG_init

printf("test:  intc_clearvectaddr\n");

\#endif   

}

 

*/************************************************************************************************/*

*/** *绑定我们写的**isr**到**VICnVECTADDR**寄存器*                              **/*

*/************************************************************************************************/*

void intc_setvectaddr(unsigned long *intnum*, void(*handler)(void))

{

  

  *//* *绑定我们写的**isr**到**VICnVECTADDR**寄存器*                              

  *//* *绑定过之后我们就把**isr**地址交给硬件了，剩下的我们不用管了，硬件自己会处理*            

  *//* *等发生相应中断的时候，我们直接到相应的**VICnADDR**中去取**isr**地址即可。*              

  *//* *参数：**intnum**是**int.h**定义的物理中断号，**handler**是函数指针，就是我们写的**isr*            

  *// VIC0VECTADDR**定义为**VIC0VECTADDR0**寄存器的地址，就相当于是**VIC0VECTADDR0**～**31**这个*            

  *//* *数组（这个数组就是一个函数指针数组）的首地址，然后具体计算每一个中断的时候*        

  *//* *只需要首地址**+**偏移量即可。*

  *// 4\*(intnum -0)* *乘以**4* *是因为地址是**4**个字节的*

  if(intnum < 32){

​    *((volatile unsigned long *)(VIC0VECTADDR + 4*(intnum -0)) ) = (unsigned) handler;

  }else if(intnum < 64 ){

​    *((volatile unsigned long *)(VIC1VECTADDR + 4*(intnum -32)) )= (unsigned) handler;

  }else if(intnum < 96 ){

​    *((volatile unsigned long *)(VIC2VECTADDR + 4*(intnum -64)) ) = (unsigned) handler;

  }else {

​    *((volatile unsigned long *)(VIC3VECTADDR + 4*(intnum -96)) )= (unsigned) handler;

  }

\#ifdef DEBUG_init

printf("test:  intc_setvectaddr\n");

\#endif

  

}

 

*/*************************************************************************************************/*

*/**                    *使能中断*                        **/*

*/** *通过传参的**intnum**来使能某个具体的中断源，中断号在**int.h**中定义，是物理中断号*             **/*

*/************************************************************************************************/*

 

void intc_enable(unsigned long *intnum*)

{  

  unsigned long temp;

  

  *//* *确定**intnum**在哪个寄存器的哪一位*

  *// <32**就是**0**～**31**，必然在**VIC0*

  if(intnum < 32){

​    temp = VIC0INTENABLE;  

​    temp |= (1<<(intnum - 0));     *//* *如果是第一种设计则必须位操作，第二种设计可以*                  

​    VIC0INTENABLE =temp;        *//* *直接写。*

  }else if(intnum < 64){

​    temp = VIC1INTENABLE;  

​    temp |= (1<<(intnum - 32));

​    VIC1INTENABLE =temp;

  }else if(intnum < 96){

​    temp = VIC2INTENABLE;  

​    temp |= (1<<(intnum - 64));

​    VIC2INTENABLE =temp;

  }else if(intnum < NUM_ALL){

​    temp = VIC3INTENABLE;  

​    temp |= (1<<(intnum - 96));

​    VIC3INTENABLE =temp;

  *// NUM_ALL : enable all interrupt*

  }else{

​    VIC0INTENABLE = 0xffffffff;

​    VIC1INTENABLE = 0xffffffff;

​    VIC2INTENABLE = 0xffffffff;

​    VIC3INTENABLE = 0xffffffff;

  }

\#ifdef DEBUG_init

printf("test:  intc_setintenable\n");

\#endif 

}

 

*/************************************************************************************************/*

*/**                    *禁止中断*                        **/*

*/** *通过传参的**intnum**来禁止某个具体的中断源，中断号在**int.h**中定义，是物理中断号*          **/*

*/************************************************************************************************/*

 

void intc_disenable(unsigned long *intnum*)

{

  unsigned long temp;

  

  if(intnum < 32){

​    temp = VIC0INTENCLEAR; 

​    temp |= (1<<(intnum - 0));

​    VIC0INTENCLEAR =temp;

  }else if(intnum <64){

​    temp = VIC1INTENCLEAR; 

​    temp |= (1<<(intnum - 32));

​    VIC1INTENCLEAR =temp;

  }else if(intnum <96){

​    temp = VIC2INTENCLEAR; 

​    temp |= (1<<(intnum - 64));

​    VIC2INTENCLEAR =temp;

  }else if(intnum < NUM_ALL){

​    temp = VIC3INTENCLEAR; 

​    temp |= (1<<(intnum - 96));

​    VIC3INTENCLEAR =temp;

  *// NUM_ALL : enclear all interrupt*

  }else{

​    VIC0INTENCLEAR = 0xffffffff;

​    VIC1INTENCLEAR = 0xffffffff;

​    VIC2INTENCLEAR = 0xffffffff;

​    VIC3INTENCLEAR = 0xffffffff;

  }

\#ifdef DEBUG_init

printf("test:  intc_setintclear\n");

\#endif

}



 

*/************************************************************************************************/*

*/**     *这个使我们真正的中断处理处理程序，这里只考虑中断处理不考虑恢复现场*          **/*

*/************************************************************************************************/*

 

void irq_handler(void)

{

  printf("IRQ_exception.\n");

  

  *//SoC**支持很多个（在低端**CPU**例如**2440**有**30**个多个中断，**210* *有**100**多个）*

  *//* *这么多中断**irq**在第一个阶段走的是一条路，都会进入到**irq_handler**来*

  *//* *我们在**irq_handler**中要去区分究竟是哪个中断发生了，然后再去调用该中断*

  *//* *对应的**isr**。*

  

  *//* *虽然硬件已经自动帮我们把**isr**的地址放入了**VICnADDR**中，但是因为有**4**个，所以我们必须*

  *//* *先去软件的检查出来到底哪个**VIC**中断了，也就是说**isr**到底在哪个**VICADDR**寄存器中*

  *//**而**s32440**则是要判断**VICIRQSTATUS**的哪一位发生了中断，获取编号后去取编号然后通过指针函数*

  *//**访问**isr**函数。这里之所以不能直接使用**isr**地址还需要判断**VICOIRQSTATUS* *是因为我们有**4**个**VICnADDRESS*

  *//**我需要确定这**4**个哪个寄存器发生了中断，然后去那个寄存器取地址。如果**210**只有一个**VICADDRESS**的话可以直接*

  *//**使用这个地址而不用去判断。*

  *//**通过代码显而易见**100+**的中断也只要**4**次**for**循环，相比**s32400**而言要**100**多次**for**循环提升效率是显而易见的。*

   int i;

   void (*isr)(void) = NULL;

   

​     *//* *通过读取**VICnIRQSTATUS**寄存器，判断其中哪个有一位为**1**，来得知哪个**VIC**发生中断了。*

   unsigned long getvicirqstatus[4] = {VIC0IRQSTATUS,VIC1IRQSTATUS,VIC2IRQSTATUS,VIC3IRQSTATUS};

   unsigned long getvicaddress[4]  = {VIC0ADDR,VIC1ADDR,VIC2ADDR,VIC3ADDR};

   

 

   for(i = 0; i < 4; i++){

​     *//* *发生一个中断时，**4**个**VIC**中有**3**个是全**0**，**1**个的其中一位不是**0*

​     if(getvicirqstatus[i] != 0){

​      \#ifdef DEBUG

​        printf("test:  for(i =%d)\n",i);

​      \#endif

​       isr = (void (*)(void))getvicaddress[i];

​       break;

​     }    

   }   

   *//* *通过函数指针来调用函数*

  (*isr)(); 

\#ifdef DEBUG

printf("test:  IRQ_handler\n");

\#endif

}

 

## 1.8.10.外部中断

### 1.8.10.1、什么是外部中断？数据手册在哪里？

(1)SoC支持的中断类型中有一类叫外部中断。内部中断就是指的中断源来自于SoC内部（一般是内部外设），譬如串口、定时器等部件产生的中断；外部中断是SoC外部的设备，通过外部中断对应的GPIO引脚产生的中断。

(2)按键在SoC中就使用外部中断来实现。具体实现方法是：将按键电路接在外部中断的GPIO上，然后将GPIO配置为外部中断模式。此时人通过按按键改变按键电路的电压高低，这个电压高低会触发GPIO对应的外部中断，通过引脚传进去给CPU处理。

(3)外部中断相关的介绍和寄存器都在2.2.6章节（属于GPIO部分）

 

### 1.8.10.2、电平触发和边沿触发

(1)外部中断的触发模式主要有2种：电平触发和边沿触发。

(1)电平触发就是说GPIO上的电平只要满足条件，就会**不停**触发中断。电平触发分为**高电平触发**和**低电平触发**。电平触发的特点是，只要电平满足条件就会不停触发中断。

(2)边沿触发分为**上升沿触发**、**下降沿触发**和**双边沿触发**三种。边沿触发不关心电平常规状态，只关心电平变化的瞬间（边沿触发不关心电平本身是高还是低，只关心变化是从高到低还是从低到高的这个过程）。

**分析按键的工作**：如果我们关注的是按键按下和弹起这两个事件本身，那么应该用边沿触发来处理按键；如果我们关心的是按键按下/弹起的那一段时间，那么应该用电平触发。

 

### 1.8.10.3、关键寄存器：CON、PEND、MASK

(1)外部中断的主要配置寄存器有3个：EXT_CON、EXT_PEND、EXT_MASK

(2)**EXT_CON**配置外部中断的触发方式。**触发方式**就是说外部电平怎么变化就能触发中断，也就是说这个外部中断产生的条件是什么

(3)**EXT_PEND**寄存器是中断挂起寄存器。这个寄存器中每一位对应一个外部中断，平时没有中断时值为0。当发生了中断后，硬件会自动将这个寄存器中该中断对应的位置1，我们去处理完这个中断后应该手工将该位置0。这个PEND寄存器的位就相当于是一个标志，如果发生了中断但是我们暂时忙来不及去处理时，这个位一直是1（**这就是挂起**），直到我有空了去处理了这个中断才会手工清除（写代码清除）这个挂起位表示这个中断被我处理了。

(4)**EXT_MASK**寄存器就是各个外部中断的使能/禁止开关。

 

分析X210开发板的按键对应的EINT编号：

EINT2(LEFT)、EINT3(DOWN)、EINT16(UP)、EINT17(RIGHT)、EINT18(BACK)、EINT19(MENU)

 

## 1.8.11.中断方式处理按键编程实践

1.8.11.1、外部中断对应的GPIO模式设置

1.8.11.2、中断触发模式设置

1.8.11.3、中断允许、清挂起  （注意：清除挂起写1清零）

1.8.11.4、中断处理程序isr编写

1.8.11.5、总结对比：轮询方式处理按键和中断方式的差异

 

//初始化按键

void key_init(void) 

{

  //设置GPHxCON寄存器，设置为输入模式

  //GPH0CON 的bit8~15全部设置为0，即可

rGPH0CON &= ~(0xFF<<8); 

void key_polling(void)

{

  //一次，挨个去独处每个GPIO的值，判断其值是1还是0，如果1为按下，0弹起。

  

  while(1){

​    //SW5

​    if(rGPH0DAT & (1<<2)){

​      led_off();

​    }

​    else {

​      led_SW5();

​    }

​    

​    //SW6

​    if(rGPH0DAT & (1<<3)){

​      led_off();

​    }

​    else {

​      led_SW6();

​    }

​    //SW7

​    if(rGPH2DAT & (1<<0)){

​      led_off();

​    }

​    else {

​      led_SW7();

​    }

​    //SW8

​    if(rGPH2DAT & (1<<1)){

​      led_off();

​    }

​    else {

​      led_SW8();

​    }

​    //SW9

 

 //GPH2CON 的bit0~15全部设置为0，即可

  rGPH2CON &= ~(0xFFFF<<0);

  

}

​    if(rGPH2DAT & (1<<2)){

​      led_off();

​    }

​    else {

​      led_SW9();

​    }

​    //SW10

​    if(rGPH2DAT & (1<<3)){

​      led_off();

​    }

​    else {

​      led_SW10();

​    }

  

  }

 

}

 

//-----------------------中断方式处理按键--------------------------------------------------------------------------------------//

// 以中断方式来处理按键的初始化  

  

void key_init_interrupt(void)

{

  

//第一步外部中断对应的GPIO模式设置

  rGPH0CON |= (0xFF<<8);     // GPH0_2 GPH0_3设置为外部中断模式

  rGPH2CON |= (0xFFFF<<0);    // GPH2_0123共4个引脚设置为外部中断模式

  

//第二步中断触发模式设置

  //设置 SW5,6(EINT2(LEFT)、EINT3(DOWN))，先把bit8 ~ bit15 全部清零;

  rEXT_INT_0_CON &= ~(0xff<<8);

  //然后再把bit8~11，bit12和bit15 设置为0b10 下降沿触发模式

  rEXT_INT_0_CON |=((0x2 << 8)|(0x2 << 12));

  //设置 SW7~10（EINT16(UP)、EINT17(RIGHT)、EINT18(BACK)、EINT19(MENU)）先把bit0到bit14清零了

  rEXT_INT_2_CON &= ~(0xffff);

  //然后设置显影的各个为的下降沿模式bit0~2 EINT17 ~bit12~14EINT19(MENU)

  rEXT_INT_2_CON |= ((0x2<<0)|(0x2<<4)|(0x2<<8)|(0x2<<12));

  

//第三步步允许中断

  rEXT_INT_0_MASK &=~(0x3<<2);

 

// EINT2通道对应的按键，就是GPH0_2引脚对应的按键，就是开发板上标了LEFT的那个按键

//SW5(LEFT)

void isr_eint2(void)

{

  // 真正的isr应该做2件事情。

  // 第一，中断处理代码，就是真正干活的代码

  //这里用printf打印语句来做调试而已，而真正的应该是做左移的相关动作

  printf("isr_eint3_LEFT.\n");

  //清挂起

  rEXT_INT_0_PEN |=(1<<2);

  //清除需要处理的中断的中断处理函数的地址  

  intc_clearvectaddr(); 

}  

 

void isr_eint3(void)

{

  printf("isr_eint3_DOWN.\n");

  //清挂起

  rEXT_INT_0_PEN |=(1<<3);

  intc_clearvectaddr(); 

}  

//SW7~10（EINT16(UP)、EINT17(RIGHT)、EINT18(BACK)、EINT19(MENU)） 之所以写在一起是因为EINT16~31是一个中断源；

void isr_eint16171819(void)

{

  if(rEXT_INT_2_PEN & (1<<0)){

​    printf("isr_eint16_UP");

  }

  if(rEXT_INT_2_PEN & (1<<1)){

​    printf("isr_eint17_RIGHT");

  }

  if(rEXT_INT_2_PEN & (1<<2)){

​    printf("isr_eint18_BACK");

  }

  if(rEXT_INT_2_PEN & (1<<3)){

​    printf("isr_eint19_MENU");

  }

  

  rEXT_INT_2_PEN |=(0xf<<0);

  intc_clearvectaddr();

}

## 1.8.12.中断方式主函数编程实践

//mian.c

\#include "stdio.h"

\#include "int.h"

\#include "main.h"

 

//void uart_init(void);

 

\#define KEY_EINT2        NUM_EINT2  //left

\#define KEY_EINT3        NUM_EINT3  //down

\#define KEY_EINT16_to_19    NUM_EINT16_31  //其余4个

 

int main(void)

{

  uart_init();

  key_init_interrupt();

// 如果程序中要使用中断，就要调用中断初始化来初步初始化中断控制器

  system_init_exception();

 

  

printf("-------------key interrypt test--------------");

  // 绑定isr到中断控制器硬件

  intc_setvectaddr(KEY_EINT2,isr_eint2);

  intc_setvectaddr(KEY_EINT3,isr_eint3);

  intc_setvectaddr(KEY_EINT16_to_19,isr_eint16171819);

  //使能中断

  intc_enable(KEY_EINT2);

  intc_enable(KEY_EINT3);

  intc_enable(KEY_EINT16_to_19);

  

  while(1){

​    printf("AAAAA\n");

​    delay();

  }

  return 0;

}



 

# 第九章 定时器、看门狗和RTC

## 1.9.0 章节概要

**1.9.1.什么是定时器**

​    本节讲述定时器、计数器等的概念和基本工作原理，希望通过讲解让大家明白定时器到底是什么，为什么需要定时器。最后讲解了定时器和看门狗、RTC、蜂鸣器等的关系。

**1.9.2.S5PV210中的定时器**

​    本节以数据手册为纲领，讲述S5PV210中的4类时间模块，主要目的是让大家了解各个时间部件的区别和各自特点。

**1.9.3.S5PV210的PWM定时器1**

​    本节开始讲解PWM定时器，主要讲解一些外围概念和S5PV210中PWM定时器的结构框图，其中结构框图是本节的核心重点。

**1.9.4.S5PV210的PWM定时器2**

​    本节继续讲解S5PV210的PWM定时器，主要讲述预分频器与分频器、TCNTB和TCMPB寄存器及其工作原理、自动装载与双缓冲机制等。

**1.9.5.S5PV210的PWM定时器3**

​    本节继续讲解S5PV210的PWM定时器，主要讲述PWM波形的生成原理、输出电平翻转器和死区生成器等相关概念和应用方法。

**1.9.6.蜂鸣器和PWM定时器编程实践1**

​    本节进行PWM定时器的编程实践。首先讲解蜂鸣器的工作原理及其与PWM的关系，然后分析了原理图、数据手册、相关寄存器等，为下节写程序准备好理论基础。

**1.9.7.蜂鸣器和PWM定时器编程实践2**

​    本节接上节继续PWM定时器的编程实践，带领大家从零开始写代码驱动timer2发出2KHz和10KHz等不同频率的PWM波形驱动蜂鸣器发声。

**1.9.8.看门狗定时器**

​    本节详细讲解看门狗定时器的原理、概念及实践应用场景。并结合数据手册分析了S5PV210内置的看门狗定时器的框图、寄存器等。

**1.9.9.看门狗定时器的编程实践**

​    本节进行看门狗定时器的编程实战，从零开始写代码操作看门狗定时器。以中断方式和复位方式两种工作方式演示了看门狗定时器的实践用法。

**1.9.10.实时时钟RTC**

​    本节首先讲解RTC和timer的区别，然后分析了S5PV210的RTC模块的框图、时钟、寄存器，最后详细讲了BCD码的编码及意义，因为RTC中的时间全是用BCD码编码存储的。

**1.9.11.RTC编程实战1**

​    本节进行RTC的编码实践，在上节讲解RTC寄存器的基础上，编程实现RTC时间的设置、读取显示，及闹钟功能的演示，这些都是RTC最常用的功能。

**1.9.12.RTC编程实战2**

​    本节进行RTC的编码实践，在上节讲解RTC寄存器的基础上，编程实现RTC时间的设置、读取显示，及闹钟功能的演示，这些都是RTC最常用的功能。

## 1.9.1.什么是定时器（timer）

### 1.9.1.1、定时器是SoC中常见外设

(1)定时器与计数器。计数器是用来计数的（每隔一个固定时间会计一个数）；因为计数器的计数时间周期是固定的，因此到了一定时间只要用计数值×计数时间周期，就能得到一个时间段，这个时间段就是我们定的时间（这就是定时器了）。

(2)定时器/计数器作为SoC的外设，主要用来实现定时执行代码的功能。定时器相对于SoC来说，就好象闹钟相对于人来说意义一样。

 

### 1.9.1.2、定时器有什么用

(1)定时器可以让SoC在执行主程序的同时，可以（通过定时器）具有计时功能，到了一定时间（计时结束）后，定时器会产生中断提醒CPU，CPU会去处理中断并执行定时器中断的ISR。从而去执行预先设定好的事件。

(2)定时器就好象是CPU的一个秘书一样，这个秘书专门管帮CPU来计时，并到时间后提醒CPU要做某件事情。所以CPU有了定时器之后，只需预先把自己xx时间之后必须要做的事情绑定到定时器中断ISR即可，到了时间之后定时器就会以中断的方式提醒CPU来处理这个事情。

 

### 1.9.1.3、定时器的原理

(1)定时器计时其实是通过计数来实现的。定时器内部有一个计数器，这个计数器根据一个时钟（这个时钟源来自于ARM的APB总线，然后经过时钟模块内部的分频器来分频得到）来工作。每隔一个时钟周期，计数器就计数一次，定时器的时间就是计数器计数值×时钟周期。

(2)定时器内部有1个寄存器TCNT（timer count ），计时开始时我们会把一个总的计数值（譬如说300）放入TCNT寄存器中，然后每隔一个时钟周期（假设为1ms）TCNT中的值会自动减1（硬件自动完成，不需要CPU软件去干预），直到TCNT中减为0的时候，TCNT就会触发定时器中断。

(3)定时时间是由2个东西共同决定的：一个是**TCNT****中的计数值**，一个是**时钟周期**。譬如上例中，定时周期就为300×1ms = 300ms。

 

### 1.9.1.4、定时器和看门狗、RTC、蜂鸣器的关系

(1)这几个东西都是和时间有关的部件。

(2)看门狗其实就是一个定时器，只不过定时时间到了之后不只是中断，还可以复位CPU

(3)RTC是实时时钟，它和定时器的差别就好象**闹钟**（定时器）和**钟表**（RTC）的差别一样。

(4)蜂鸣器是一个发声设备，在ARM里面蜂鸣器是用定时器模块来驱动的。

 

## 1.9.2.S5PV210中的定时器

在S5PV210内部，一共有4类定时器件。这4类定时器件的功能、特征是不同的。

### 1.9.2.1、PWM(Pulse width modulation timer)定时器

(1)这种是最常用的，平时所说的定时器一般指的是这个。像简单单片机（譬如51单片机）中的定时器也是这类。

(2)为什么叫PWM定时器，因为一般SoC中产生PWM信号都是靠这个定时器模块的。

(3)给外设用的

### 1.9.2.2、(system timer)系统定时器

(1)系统（指的是操作系统）定时器，系统定时器也是用来产生固定时间间隔（TCNT×时钟周期）信号的，称为systick，这个systick用来给操作系统提供tick信号。

(2)产生systick作为操作系统的时间片（time slice）的。

(3)一般做操作系统移植的时候，这里不会由我们自己来做，一般原厂提供的基础移植部分就已经包含了，所以这里我也从来没有研究过。

(4)给操作系统用的，操作系统进程调度。

### 1.9.2.3、（watch dog）看门狗定时器

(1)看门狗定时器本质上也是一个定时器，和上面2个没有任何本质区别。

(2)看门狗定时器可以设置在时间到了的时候**产生中断**，也可以选择发出**复位信号**复位CPU。

(3)看门狗定时器在实践中应用很多，尤其是工业领域（环境复杂、干扰多）机器容易出问题，而且出问题后后果很严重，此时一般都会用看门狗来进行系统复位。本章节会用2节课来对210中的看门狗进行讲解和编程。

### 1.9.2.4、实时时钟RTC（real time clock）

(1)区分时间段和时间点。时间段是相对的，两个时间点相减就会得到一个时间段；而时间点是绝对的，是绝无仅有的一个时间点。

(2)定时器关注的是时间段（而不是时间点），定时器计时从开启定时器的那一刻开始，到定的时间段结束为止产生中断；RTC中工作用的是时间点（xx年x月x日x时x分x秒星期x）。

(3)RTC和定时器的区别，就相当于是**钟表**和**闹钟**的区别。

 

## 1.9.3.S5PV210的PWM定时器1

### 1.9.1.1、为什么叫PWM定时器

(1)叫定时器说明它本质上的原理是定时器

(2)叫PWM定时器，是因为这个定时器天然是用来产生PWM波形的。

### 1.9.3.2、PWM定时器介绍

(1)S5PV210有5个PWM定时器。其中0、1、2、3各自对应一个外部GPIO，可以通过这些对应的GPIO产生PWM波形信号并输出；timer4没有对应的外部GPIO（因此不是为了生成PWM波形而是为了产生内部定时器中断而生的）。

(2)S5PV210的5个PWM定时器的时钟源为PCLK_PSYS，timer0和timer1共同使用一个预分频器、timer2、3、4共同使用一个预分频器；每个timer有一个专用的独立的分频器；预分频器和分频器构成了2级分频系统，将PCLK_PSYS两级分频后生成的时钟供给timer模块作为时钟周期。

(3)剩下的介绍内容我就不逐句带读，大家自己读，读的时候结合后面的内容和翻译。

 

注意：PRESCALER(预分频器)是写倍率（倍率本来就是+1的所以要写的倍率要减去1）来分频的，而MUX(分频器)则是选择开关来选择分频的

### 1.9.3.3、S5PV210的PWM定时器框图简介

(1)关键点：时钟源、预分频器、分频器、TCMPB&TCNTB、dead zone

（2）   电平取反。

​    

## 1.9.4.S5PV210的PWM定时器2

### 1.9.4.1、预分频器与分频器

(1)两级分频是串联（级联）的，所以两级分频的分频数是相乘的。

(2)两级分频的分频系数分别在**TCFG0**（管理prescaler）和**TCFG1**（管理division，MUK）两个寄存器中设置。

(3)预分频器有2个，prescaler0为timer0&timer1共用；prescaler1为timer2、3、4共用；两个prescaler都是8个bit位，因此prescaler value范围为0～255；所以预分频器的分频值范围为1～256（注意实际分频值为prescaler value + 1）。

(4)分频器实质上是一个MUX开关，多选一开关决定了走哪个分频系数路线。可以选择的有1/1，1/2，1/4，1/8，1/16等。

(5)计算一下，两级分频下来，分频最小为1/1（也可能是1/2），最大分频为1/256×16（1/4096）。

(6)在PCLK_PSYS为66MHz的情况下（默认时钟设置就是66MHz的），此时两级分频后的时钟周期范围为0.03us到62.061us；再结合TCNTB的值的设置（范围为1～2的32次方），可知能定出来的时间最长为266548.27s（折合74小时多，远远够用了）。

 

### 1.9.4.2、TCNT&TCMP、TCNTB&TCMPB、TCNTO

(1)**TCNT**和**TCNTB**是相对应的，TCNTB是有地址的寄存器，供程序员操作；TCNT在内部和TCNTB相对应，它没有寄存器地址，程序员不能编程访问这个寄存器。

(2)**TCNT**寄存器功能就是用来减1的，它是内部的不能读写；我们向TCNT中写要通过TCNTB往进写；读取TCNT寄存器中的值要通过**读取相对应的TCNTO寄存器**。

为什么要有TCNT和TCNTB两个寄存器呢，是因为循环用 ，TCNT负责减，减完去TCNTB中拿原来的数据继续使用，进行来一个循环。

(3)工作流程就是：我们事先算好TCNT寄存器中开始减的那个数（譬如300），然后将之写入**TCNTB**寄存器中，在启动timer前，将TCNTB中的值刷到TCNT寄存器中（有一位寄存器专门用来操作刷数据过去的），刷过去后就可以启动定时器开始计时；在计时过程中如果想知道TCNT寄存器中的值减到多少了，可以读取相应的**TCNTO**寄存器来得知。

(4)定时功能只需要TCNT、TCNTB两个即可；TCNTO寄存器用来做一些捕获计时；TCMPB用来生成PWM波形。

 

### 1.9.4.3、自动重载和双缓冲（auto-reload and double buffering）

(1)定时器工作的时候，一次定时算一个工作循环。定时器默认是单个循环工作的，也就是说定时一次，计时一次，到期中断一次就完了。下次如果还要再定时中断，需要另外设置。

(2)但是现实中用定时器来做的时候往往是循环的，最简单最笨的方法就是写代码反复重置定时器寄存器的值（在每次中断处理的isr中再次给TCNTB中赋值，再次刷到TCNT中再次启动定时器），早期的单片机定时器就是这样的；但是现在的高级SoC中的定时器已经默认内置了这种循环定时工作模式，就叫**自动装载（auto-reload）机制**。

(3)自动装载机制就是当定时器初始化好开始计时后再不用管了，他一个周期到了后会自己从TCNTB中再次装载值到TCNT中，再次启动定时器开始下个循环。

 

## 1.9.5.S5PV210的PWM定时器3

### 1.9.5.1、什么是PWM？

(1)PWM(pulse width modulation 脉宽调制)

(2)PWM波形是一个周期性波形，周期为T，在每个周期内波形是完全相同的。每个周期内由一个高电平和一个低电平组成。

(3)PWM波形有2个重要参数：一个是**周期T**，另一个是**占空比duty**（占空比就是一个周期内高电平的时间除以周期时间的商）。

(4)对于一个PWM波形，知道了周期T和占空比duty，就可以算出这个波形的所有细节。譬如高电平时间为T*duty，低电平时间为T*(1-duty)。

(5)PWM波形有很多用处，譬如通信上用PWM来进行脉宽调制对基波进行载波调制；在发光二极管LED照明领域可以用PWM波形来调制电流进行调光；用来驱动蜂鸣器等设备。

 

### 1.9.5.2、PWM波形的生成原理

(1)PWM波形其实就是用时间来控制电平高低，所以用定时器来实现PWM波形是天经地义的。

(2)早期的简单单片机里（譬如51单片机）是没有专用的PWM定时器的，那时候我们需要自己结合GPIO和定时器模块来手工生产PWM波形（流程是这样：先将GPIO引脚电平拉高、同时启动定时器定T*duty时间，时间到了在isr中将电平拉低，然后定时T*(1-duty)后再次启动定时器，然后时间到了后在isr中将电平拉高，然后再定时T*duty时间再次启动定时器····如此循环即可得到周期为T，占空比为duty的PWM波形）。

(3)后来因为定时器经常和PWM产生纠结一起，所以设计SoC的时候就直接把定时器和一个GPIO引脚内部绑定起来了，然后在定时器内部给我们设置了PWM产生的机制，可以更方便的利用定时器产生PWM波形。此时我们利用PWM定时器来产生PWM波形再不用中断了。绑定了之后坏处就是GPIO引脚是固定的、死板的、不能随便换的；好处是不用进入中断isr中，直接可以生成PWM。

(4)在S5PV210中，PWM波形产生有2个寄存器很关键，一个是**TCNTB**、一个是**TCMPB**。其中，**TCNTB**决定了PWM波形的**周期**，TCMPB决定了**PWM**波形的**占空比**。

(5)最终生成的PWM波形的周期是：TCNTB×时钟周期（PCLK_PSYS经过两极分频后得到的时钟周期）。注意这个周期是PWM中高电平+低电平的总时间，不是其中之一。

(6)最终生成的PWM波形的占空比是：TCMPB/TCNTB

 

### 1.9.5.3、输电平翻转器

(1)PWM定时器可以规定：当TCNT>TCMPB时为高电平，当TCNT<TCMPB时为低电平。也可以规定：当TCNT>TCMPB时为低电平，当TCNT<TCMPB时为高电平。在这两种规定下，计算时TCMP寄存器的值会变化。

(2)基于上面讲的，当duty从30%变到70%时，我们TCMPB寄存器中的值就要改（譬如TCNTB中是300时，TCMPB就要从210变化到90）。这样的改变可以满足需要，但是计算有点麻烦。于是乎210的PWM定时器帮我们提供了一个友好的工具叫做**电平翻转器**。

(3)**电平翻转器**在电路上的实质就是一个电平取反的部件，在编程上反映为一个寄存器位。写0就关闭输出电平反转，写1就开启输出电平反转。开启后和开启前输出电平刚好高低反转。（输出电平一反转30%的duty就变成70%了）

(4)实战中到底是TCNT和TCMPB谁大谁小时高电平还是低电平，一般不用理论分析，只要写个代码然后用示波器实际看一下出来的波形就知道了；如果反了就直接开启电平翻转器即可。

 

### 1.9.5.4、死区生成器

(1)PWM有一个应用就是用在功率电路中用来对交流电压进行整流。整流时2路整流分别在正电平和负电平时导通工作，不能同时导通（同时导通会直接短路，瞬间的同时导通都会导致电路烧毁）。大功率的开关电源、逆变器等设备广泛使用了整流技术。特别是逆变器，用SoC的GPIO输出的PWM波形来分别驱动2路整流的IGBT。

  如果没有死区，两端在电流变换的瞬间有重叠部分，有可能会造成电路的烧毁。

(2)PWM波形用来做整理时要求不能同时高或低，因为会短路。但是实际电路是不理想的，不可能同时上升/下降沿，所以比较安全的做法是留死区。

(3)死区这东西离不了也多不了。死区少了容易短路，死区多了控制精度低了不利于产品性能的提升。

(4)S5PV210给大家提供了自带的死区生成器，只要开启死区生成器，生产出来的PWM波形就自带了死区控制功能，用户不用再自己去操心死区问题。

(5)大部分人工作是用不到这个的，直接关掉死区生成器即可。

 

## 1.9.6.蜂鸣器和PWM定时器编程实践1

### 1.9.6.1、蜂鸣器的工作原理

(1)蜂鸣器里面有2个金属片，离的很紧但没挨着；没电的时候两个片在弹簧本身张力作用下分开彼此平行；有电的时候两边分别充电，在异性电荷的吸力作用下两个片挨着；

(2)我们只要以快速的频率给蜂鸣器的正负极：供电、断电。进行这样的循环，蜂鸣器的两个弹簧片就会挨着分开挨着分开···形成敲击，发出声音。

(3)因为人的耳朵能听见的声音频率有限制（20Hz-20000Hz），我们做实验时一般给个2KHz的频率，大部分人都能听到（听不到的就就近医院处理）。

(4)频率高低会影响声音的音频，一般是音频越低声音听起来越低沉、音频越高听起来越尖锐。

(5)根据以上的分析，可以看出，只要用PWM波形的电压信号来驱动蜂鸣器，把PWM波形的周期T设置为要发出的声音信号的1/频率即可；PWM的占空比只要确保能驱动蜂鸣器即可（驱动能力问题，一般引脚驱动能力都不够，所以蜂鸣器会额外用三极管来放大流来供电）。

 

### 1.9.6.2、原理图和硬件信息

(1)查阅原理图可知，开发板底板上的蜂鸣器通过GPD0_2（XpwmTOUT2）引脚连接在SoC上。

(2)GPD0_2引脚通过限流电阻接在三极管基极上，引脚有电蜂鸣器就会有电（三极管导通）；引脚没电蜂鸣器就会没电（三极管关闭）。这些都是硬件问题，软件工程师不用管，软件工程师只要写程序控制GPD0_2引脚的电平产生PWM波形即可。

(3)GPD0CON(0xE02000A0)，要把bit8～bit11设置为0b0010（**功能选择为TOUT_2，就是把这个引脚设置为PWM输出功能**）。

(4)从GPD0_2引脚可以反推出使用的是timer2这个PWM定时器。

 

### 1.9.6.3、PWM定时器的主要寄存器详解

(1)相关的寄存器有TCFG0、TCFG1、CON、TCNTB2、TCMPB2、TCNTO2

为什么选2呢是因为蜂鸣器的引脚在第二个timer上，所以选择2。

 

 

 

## 1.9.7.蜂鸣器和PWM定时器编程实践2

基于uart_stdio项目源码来添加PWM定时器驱动蜂鸣器实验

注意：PWM定时器来产生PWM波形时是不需要中断干预的。

//初始化tiemr2，使其输出pwm波形：频率2KHz、duty为50%

void timer2_pwm_init(void)

{

  //设置GPD0_2将其配置为XpwmTOUT_2

  rGPD0CON &= ~(0xf << 8);

  rGPD0CON |= (0x2 << 8);

 

  //设置PWM定时前一干寄存器，使其工作

  rTCFG0 &= ~(0xff << 8);

  rTCFG0 |= (65 << 8);    //prescaler1 =65, 预分频后的频率为1MHz

  //设置MUX开关的倍数

  rTCFG1 &= ~(0xf << 8);

  rTCFG1 |= (1 << 8);     //设置为1/2，分频后为500KHz ，对应的时钟周期为2μs

 

  

 

  rCON |= (1<<15);     // 使能auto-reload，反复定时才能发出PWM波形

  // 计一次数。如果要定的时间是x，则TCNTB中应该写入x/2us

  //我们要得到2000Hz的频率， 计算 2000Hz =2KHz; 1/2 = 0.5ms; 0.5ms/2μs = 500/2 =250 

  rTCNTB2 = 500;

  rTCMPB2 = 250;    

 

  //第一次需要手工将TCNTB中的值刷新到TCNT中去，以后就可以auto-reload了

  rCON |= (1 <<13);    // 打开手动刷新功能

  rCON &= ~(1 <<13);    // 关闭手动刷新功能,如果不手动关闭的话，设置的频率将无效

​              //蜂鸣器估计工作在固定频率（系统预设？）的模式下。

 

  rCON |= (1<<12);    // 开timer2定时器。要先把其他都设置好才能开定时器

}

 

 

 

## 1.9.8.看门狗定时器

### 1.9.8.1、什么是看门狗、有什么用

(1)看门狗定时器和普通的定时器并无本质区别。定时器可以设定一个时间，在这个时间完成之前定时器不断计时，时间到的时候定时器会复位CPU（重启系统）。

(2)系统正常工作的时候当然不希望被重启，但是系统受到干扰、极端环境等可能会产生异常工作或者不工作，这种状态可能会造成不良影响（至少是不工作），此时解决方案就是重启系统。

(3)普通设备重启不是问题，但是有些设备人工重启存在困难。这时候我们希望系统能够自己检验自己是否已经跑飞，并且在意识到自己跑飞的时候，可以很快的（几个ms或者更短）自我重启。这个功能就要靠看门狗定时器来实现。

(4)典型应用的情景是：我们在应用程序中打开看门狗设备，初始化好给它一个时间，然后应用程序使用一个线程来喂狗，这个线程的执行时间安全短于看门狗的复位时间。当系统（或者应用程序）异常后，喂狗线程自然就不工作了，然后到时候看门狗就会复位。

(5)补充：实战中有时候为了绝对的可靠，我们并不会用SoC中自带的看门狗，而是使用专门的外置的看门狗芯片来实现看门狗。

 

### 1.9.8.2、S5PV210看门狗定时器的结构框图

(1)PCLK_PSYS经过两级分频后生成WDT（watchdog timer）的时钟周期，然后把要定的时间写到WTDAT寄存器中，刷到WTCNT寄存器中去减1，减到0时（定时时间到）产生复位信号或中断信号。

(2)**典型应用中**是配置为产生复位信号，我们应该在WTCNT寄存器减到0之前给WTDAT寄存器中重新写值以喂狗。

 

 

 `  

WTCON WTDAT WTCNT WTCLRINT

 

## 1.9.9.看门狗定时器的编程实践

### 1.9.9.1、产生中断信号

//wdt.c

\#define WTCON    0xE2700000 

\#define WTDAT    0xE2700004

\#define WTCNT    0xE2700008

\#define WTCLRINT  0xE270000C

 

\#define rWTCON    (*(volatile unsigned int *)WTCON )

\#define rWTDAT    (*(volatile unsigned int *)WTDAT )

\#define rWTCNT    (*(volatile unsigned int *)WTCNT )

\#define rWTCLRINT  (*(volatile unsigned int *)WTCLRINT )

 

//初始化WDT使之可以产生中断

void wdt_init_interrupt(void)

{

  rWTCON &= ~(0xff<<8);

  rWTCON |= (65<<8);     //1MHz

 

  rWTCON &= ~(3<<3);

  rWTCON |= (3<<3);     //1MHz / 128 ,

 

  //第二步设置中断和复位信号的使能

  rWTCON |= (1<<2);

  rWTCON &=~(1<<0);

 

  //第三步，设置定时时间

  //WDT定时计数个数，最终定时时间为这里的值X时钟周期

  rWTDAT = 10000;   //定时1.28s

  //如果不加rWTCHNT 的话，那么第一次产生中断的时间是他默认值（3w多）这样产生第一个中断的时间将会边长，和之后产生中断的

  //时间不一致，而加入下面CNT这句的话产生第一个的时间和后面的一致

  rWTCNT = 10000;   //定时1.28s

 

  //第四先把所有寄存器都设置好之后，再去开看门狗

  rWTCON |= (1<<5);   //   enable wdt     

}




//wdt的中断处理程序

void isr_wdt(void)

{

  static int i = 0;

  //看门狗定时器时间到了的时候应该做的有意义的事情

  printf("wdt interrupt,i = %d......\n", i++);

  //请中断

  intc_clearvectaddr();

  rWTCLRINT = 1;

}

 

 

 

//mian.c

\#include "stdio.h"

\#include "int.h"

\#include "main.h"

 

//void uart_init(void);



 

int main(void)

{

  uart_init();

  wdt_init_interrupt();

// 如果程序中要使用中断，就要调用中断初始化来初步初始化中断控制器

  system_init_exception();

 

  

printf("-------------wdt interrypt test--------------");

  // 绑定isr到中断控制器硬件

  intc_setvectaddr(NUM_WDT,isr_wdt);

 

  //是能中断

  intc_enable(NUM_WDT);

 

  

  while(1);

 

  return 0;

}

 

 

### 1.9.9.2、产生复位信号

//wdt.c

\#define WTCON    0xE2700000 

\#define WTDAT    0xE2700004

\#define WTCNT    0xE2700008

\#define WTCLRINT  0xE270000C

 

\#define rWTCON    (*(volatile unsigned int *)WTCON )

\#define rWTDAT    (*(volatile unsigned int *)WTDAT )

\#define rWTCNT    (*(volatile unsigned int *)WTCNT )

\#define rWTCLRINT  (*(volatile unsigned int *)WTCLRINT )

//初始化WDT使之可以产生中断

void wdt_init_reset(void)

{

  rWTCON &= ~(0xff<<8);

  rWTCON |= (65<<8);     //1MHz

 

  rWTCON &= ~(3<<3);

  rWTCON |= (3<<3);     //1MHz / 128 ,

 

  //第二步设置中断和复位信号的使能

  rWTCON &= ~(1<<2);  //disenable wdet interrupt

  rWTCON |= (1<<0);  //enable wdt reset

 

  //第三步，设置定时时间

  //WDT定时计数个数，最终定时时间为这里的值X时钟周期

  rWTDAT = 10000;   //定时1.28s

  //如果不加rWTCHNT 的话，那么第一次产生中断的时间是他默认值（3w多）这样产生第一个中断的时间将会边长，和之后产生中断的

  //时间不一致，而加入下面CNT这句的话产生第一个的时间和后面的一致

  rWTCNT = 10000;   //定时1.28s

 

  //第四先把所有寄存器都设置好之后，再去开看门狗

  rWTCON |= (1<<5);   //   enable wdt     

}

 

 

//mian.c

\#include "stdio.h"

\#include "int.h"

\#include "main.h"

 

//void uart_init(void);



 

int main(void)

{

  uart_init();

  wdt_init_reset();

// 如果程序中要使用中断，就要调用中断初始化来初步初始化中断控制器

  static int i = 0;

  //i++ 输出永远是0，为什么？ 因为看门狗时间到了，程序被复位了，所以main函数每次

  //都是被重新执行，所以i的值   

  //而中断是中断程序执行完之后返回来继续执行while（1的）。

  printf("-------------wdt interrypt test--------------%d",i++);

  

  /*注意： USB刷入和SD卡刷入现象不一样

​    SD卡刷入：程序复位了就没了，需要重新刷入，所以 printf只打印了一次

​    USB刷入：程序复位了，由于手按着电源相当于又从SD卡重启了程序，所以printf会重复打印

​    而且USB刷入，i的值会便随机,感觉是dnw软件USB刷入的问题

  */

  

  while(1);

 

  return 0;

}

 

 

## 1.9.10.实时时钟RTC

### 1.9.10.1、何为实时时钟

(1)real time clock，真实时间，就是所谓的xx年x月x日x时x分x秒星期x

(2)RTC是SoC中一个内部外设，RTC有自己独立的晶振提供RTC时钟源（32.768KHz），内部有一些寄存器用来记录时间（年月日时分秒星期）。一般情况下为了在系统关机时时间仍然在走，还会给RTC提供一个电池供电。

### 1.9.10.2、S5PV210实时时钟的结构框图 

(1)时间寄存器7个

(2)闹钟发生器

 

### 1.9.10.3、闹钟发生器

(1)可以定闹钟时间，到时间会产生RTC alarm interrupt，通知系统闹钟定时到了。

(2)闹钟定时是定的时间点，而timer定时是定的时间段。

 

### 1.9.10.4、S5PV210实时时钟的主要寄存器

(1)INTP 中断挂起寄存器

(2)RTCCON  RTC控制寄存器

(3)RTCALM ALMxxx   闹钟功能有关的寄存器

(4)BCDxxx  时间寄存器

 

### 1.9.10.5、BCD码

(1)RTC中所有的时间（年月日时分秒星期，包括闹钟）都是用BCD码编码的。

(2)BCD码本质上是对数字的一种编码。用来解决这种问题：由56得到0x56（或者反过来）。也就是说我们希望十进制的56可以被编码成56（这里的56不是十进制56，而是两个数字5和6）.

(3)BCD码的作用在于可以将十进制数拆成组成这个十进制数的各个数字的编码，变成编码后就没有位数的限制了。譬如我有一个很大的数123456789123456789，如果这个数纯粹当数字肯定超出了int的范围，计算机无法直接处理。要想让计算机处理这个数，计算机首先得能表达这个数，表达的方式就是先把这个数转成对应的BCD码（123456789123456789）

(4)BCD码在计算机中可以用十六进制的形式来表示。也就是说十进制的56转成BCD码后是56，在计算机中用0x56来表达（暂时存储与运算）。

(5)需要写2个函数，一个是bcd转十进制，一个是十进制转bcd。当我们要设置时间时（譬如要设置为23分），我们需要将这个23转成0x23然后再赋值给相应的寄存器BCDMIN；当我们从寄存器BCDMIN中读取一个时间时（譬如读取到的是0x59），需要将之当作BCD码转成十进制再去显示（0x59当作BCD码就是59，转成十进制就是59，所以显示就是59分）。

 

## 1.9.11.RTC编程实战1

### 1.9.11.1、设置时间与读取显示时间

(1)为了安全，默认情况下RTC读写是禁止的，此时读写RTC的时间是不允许的；当我们要更改RTC时间时，应该先打开RTC的读写开关，然后再进行读写操作，操作完了后立即关闭读写开关。

(2)读写RTC寄存器时，一定要注意BCD码和十进制之间的转换。

(3**)****年的问题**。S5PV210中做了个设定，BCDYEAR寄存器存的并不是完整的年数（譬如今年2015年），而**是基于2000年的偏移量来存储的**，譬如今年2015年实际存的就是15（2015-2000）.还有些RTC芯片是以1970年（貌似）为基点来记录的。

//函数功能：把十进制num转成BCD码，譬如把56转成0x56

static unsigned int num_2_bcd(unsigned int num)

{

  //第一步，把56拆分成5和6

  //第二步，把5和6组成0x56

  return ( ( (num/10) << 4 ) | (num%10) );

}

 

//函数功能：把十进制BCD码转成num，譬如把0x56转成56

static unsigned int bcd_2_num(unsigned int bcd)

{

  //第一步，把0x56拆分成5和6

  //第二步，把5和6组成56

  return ( ( (bcd & 0xf0) >>4) * 10 + (bcd&(0x0f)));

}

 

void rtc_set_time(const struct rtc_time *p)

{

  //第一步 ，打开RTC读写开关

  rRTCCON |= (1<<0);

  //第二步，写RTC的时间寄存器

  rBCDYEAR = num_2_bcd(p->year - 2000);

  rBCDMON = num_2_bcd(p->month);

  rBCDDATE = num_2_bcd(p->date);

  rBCDHOUR = num_2_bcd(p->hour);

  rBCDMIN = num_2_bcd(p->minute);

  rBCDSEC = num_2_bcd(p->second);

  rBCDDAY = num_2_bcd(p->day);

  

  //最后一步，关上RTC的读写开关

  rRTCCON &= ~(1<<0);

}

 

void rtc_get_time(struct rtc_time *p)

{

  //第一步 ，打开RTC读写开关

  rRTCCON |= (1<<0);

  //第二步，写RTC的时间寄存器

  p->year = bcd_2_num(rBCDYEAR )+ 2000;

  p->month = bcd_2_num(rBCDMON);

  p->date = bcd_2_num(rBCDDATE);

  p->hour = bcd_2_num(rBCDHOUR);

  p->minute = bcd_2_num(rBCDMIN);

  p->second = bcd_2_num(rBCDSEC);

  p->day = bcd_2_num(rBCDDAY);

 

  //最后一步，关上RTC的读写开关

  rRTCCON &= ~(1<<0);

}

————————————————————————————————————————————

//mian.c

\#include "stdio.h"

\#include "int.h"

\#include "main.h"

int main(void)

{

  printf("-------------rtctest--------------");

  struct rtc_time tWrite =

  {

​    .year  = 2019,

​    .month = 11,

​    .date  = 4,

​    .hour  = 14,

​    .minute = 13,

​    .second = 15,

​    .day  = 1

  };

  rtc_set_time(&tWrite);

 

  printf("-------------rtctest--------------");

  struct rtc_time tRead;

  

  while(1){

​    rtc_get_time(&tRead);

​    printf("The time read is : %dYear%dMonth%dDate%dHour%dminute%dsecond%day\n",\

​    tRead.year ,tRead.month,tRead.date,tRead.hour,tRead.minute,tRead.second,tRead.day);

​    

​    volatile int j,k;

​    for (j =10000; j>0; j--)

​      for(k = 1000; k>0; k--);

  }

 

  while(1);

}

 

 

### 1.9.11.2、闹钟实验

//rtc.c

\#include "main.h"

 

\#define   RTC_BASE   (0xE2800000)

\#define   rINTP    (*((volatile unsigned long *)(RTC_BASE + 0x30)))

\#define   rRTCCON   (*((volatile unsigned long *)(RTC_BASE + 0x40)))

\#define   rTICCNT   (*((volatile unsigned long *)(RTC_BASE + 0x44)))

\#define   rRTCALM   (*((volatile unsigned long *)(RTC_BASE + 0x50)))

\#define   rALMSEC   (*((volatile unsigned long *)(RTC_BASE + 0x54)))

\#define   rALMMIN   (*((volatile unsigned long *)(RTC_BASE + 0x58)))

\#define   rALMHOUR   (*((volatile unsigned long *)(RTC_BASE + 0x5c)))

\#define   rALMDATE   (*((volatile unsigned long *)(RTC_BASE + 0x60)))

\#define   rALMMON   (*((volatile unsigned long *)(RTC_BASE + 0x64)))

\#define   rALMYEAR   (*((volatile unsigned long *)(RTC_BASE + 0x68)))

\#define   rRTCRST   (*((volatile unsigned long *)(RTC_BASE + 0x6c)))

\#define   rBCDSEC   (*((volatile unsigned long *)(RTC_BASE + 0x70)))

\#define   rBCDMIN   (*((volatile unsigned long *)(RTC_BASE + 0x74)))

\#define   rBCDHOUR   (*((volatile unsigned long *)(RTC_BASE + 0x78)))

\#define   rBCDDATE   (*((volatile unsigned long *)(RTC_BASE + 0x7c)))

\#define   rBCDDAY   (*((volatile unsigned long *)(RTC_BASE + 0x80)))

\#define   rBCDMON   (*((volatile unsigned long *)(RTC_BASE + 0x84)))

\#define   rBCDYEAR   (*((volatile unsigned long *)(RTC_BASE + 0x88)))

\#define   rCURTICCNT  (*((volatile unsigned long *)(RTC_BASE + 0x90)))

\#define   rRTCLVD   (*((volatile unsigned long *)(RTC_BASE + 0x94)))

 

//函数功能：把十进制num转成BCD码，譬如把56转成0x56

static unsigned int num_2_bcd(unsigned int num)

{

  //第一步，把56拆分成5和6

  //第二步，把5和6组成0x56

  return ( ( (num/10) << 4 ) | (num%10) );

}

 

//函数功能：把十进制BCD码转成num，譬如把0x56转成56

static unsigned int bcd_2_num(unsigned int bcd)

{

  //第一步，把0x56拆分成5和6

  //第二步，把5和6组成56

  return ( ( (bcd & 0xf0) >>4) * 10 + (bcd&(0x0f)));

}

 

void rtc_set_time(const struct rtc_time *p)

{

  //第一步 ，打开RTC读写开关

  rRTCCON |= (1<<0);

  //第二步，写RTC的时间寄存器

  rBCDYEAR = num_2_bcd(p->year - 2000);

  rBCDMON = num_2_bcd(p->month);

  rBCDDATE = num_2_bcd(p->date);

  rBCDHOUR = num_2_bcd(p->hour);

  rBCDMIN = num_2_bcd(p->minute);

  rBCDSEC = num_2_bcd(p->second);

  rBCDDAY = num_2_bcd(p->day);

  

  //最后一步，关上RTC的读写开关

  rRTCCON &= ~(1<<0);

}

 

void rtc_get_time(struct rtc_time *p)

{

  //第一步 ，打开RTC读写开关

  rRTCCON |= (1<<0);

  //第二步，写RTC的时间寄存器

  p->year = bcd_2_num(rBCDYEAR )+ 2000;

  p->month = bcd_2_num(rBCDMON);

  p->date = bcd_2_num(rBCDDATE);

  p->hour = bcd_2_num(rBCDHOUR);

  p->minute = bcd_2_num(rBCDMIN);

  p->second = bcd_2_num(rBCDSEC);

  p->day = bcd_2_num(rBCDDAY);

 

  //最后一步，关上RTC的读写开关

  rRTCCON &= ~(1<<0);

}

void rtc_set_alarm(void)

{

  rALMSEC = num_2_bcd(23);

  rRTCALM |= 1<<0;

  rRTCALM |= 1<<6;

 

}

 

void isr_rtc_alarm(void)

{

  static int i = 0;

  printf("rtc alarm, i= %d...",i++);

 

  rINTP |= (1<<1);

  intc_clearvectaddr();

}

________________________________________________________________________

 

//mian.c

\#include "stdio.h"

\#include "int.h"

\#include "main.h"

int main(void)

{

  uart_init();

 

  system_init_exception();

  rtc_set_alarm();

 

  intc_setvectaddr(NUM_RTC_ALARM, isr_rtc_alarm);

  intc_enable(NUM_RTC_ALARM);

  

  printf("-------------rtc alarm test--------------");

  struct rtc_time tRead;

  //tRead.second = 15;

  //rtc_set_time(&tRead);

  while(1){

 

​    rtc_get_time(&tRead);

​    printf("The time read is : %d second",tRead.second);

​    volatile int j,k;

​    for (j =10000; j>0; j--)

​      for(k = 1000; k>0; k--) ;

  }

  while(1);

  return 0;}



 

# 第十章 SD卡启动详解

## 1.10.0 章节概要

**1.10.1.主流的外存设备介绍**

​    本节主要讲解目前为止出现过的主流外部存储设备如磁存储设备、Flash类存储设备以及其主要特点。

**1.10.2.SD卡的特点和背景知识**

​    本节主要讲解SD卡的简单背景，以及SD卡与MMC卡，SD卡与TF卡、MicroSD卡等的关联和区别。

**1.10.3.SD卡的编程接口**

​    本节从编程角度讲解SD卡的接口特征，SD协议和SPI协议访问SD卡的各自特点，主要目标是希望大家搞清楚SD卡的时序式访问和SRAM/DDR等的总线式访问的区别。

**1.10.4.S5PV210的SD卡启动详解1**

​    本节介绍S5PV210的S卡启动的基础知识，通过回顾S5PV210的iROM application note文档中的启动过程描述，来分析SD卡启动的方法。

**1.10.5.S5PV210的SD卡启动详解2**

​    本节着重讲解扇区和块的概念，试图让大家建立块设备的概念，并且明白Flash的以块为单位进行读写的操作特征。

**1.10.6.S5PV210的SD卡启动实战1**

​    本节详细分析210的iROM中的block device copy function及其使用细节，为编程实战打好基础，同时将编程中的细节参数都确定好。

**1.10.7.S5PV210的SD卡启动实战2**

​    本节带大家从零开始写代码并进行调试，实现分散加载的SD卡启动。

**1.10.8.解决X210开发板的软开关按键问题**

​    本节讲解X210开发板的软启动开关电路设计原理，通过分析教会大家如何在原有程序中添加代码来实现开发板置锁，以解决要不停按下POWER按键给开发板供电的问题。

## 1.10.1.主流的外存设备介绍

**内存和外存的区别**：

**内存**：RAM(random access memory,随机访问存储器：特点是任意字节读写，掉电丢失。

**外存**：ROM（read only memory，只读存储器：类似于Flash SD卡之类的，用来存储东西，掉电不丢失，不能随机地址访问，只能以块为单位来访问）。

### 1.10.1.1、软盘、硬盘、光盘、CD、磁带

(1)存储原理大部分为磁存储，缺点是读写速度、可靠性等。优点是技术成熟、价格便宜。广泛使用在桌面电脑中，在嵌入式设备中几乎无使用。

(2)现代存储的发展方向是Flash存储，闪存技术是利用电学原理来存储1和0，从而制成存储设备。所以闪存设备没有物理运动（硬盘中的磁头），所以读写速度可以很快，且无物理损耗。

### 1.10.1.2、纯粹的Flash：NandFlash、NorFlash

(1)这些是最早出现的、最原始的Flash颗粒组成芯片。也就是说NandFlash、NorFlash芯片中只是对存储单元做了最基本的读写接口，然后要求外部的SoC来提供Flash读写的控制器以和Flash进行读写时序。

(2)缺陷：1、读写接口时序比较复杂。2、内部无坏块处理机制，需要SoC自己来管理Flash的坏块；3、各家厂家的Flash接口不一致，甚至同一个厂家的不同型号、系列的Flash接口都不一致，这就造成产品升级时很麻烦。

(3)NandFlash分MLC和SLC两种。SLC技术比较早，可靠性高，缺点是容量做不大（或者说容量大了太贵，一般SLC Nand都是512MB以下）；MLC技术比较新，不成熟，可靠性差，优点是容量可以做很大很便宜，现在基本都在发展MLC技术。

### 1.10.1.3、SD卡、MMC卡、MicroSD、TF卡

(1)这些卡其实内部就是Flash存储颗粒，比直接的Nand芯片多了统一的外部封装和接口。

(2)卡都有统一的标准，譬如SD卡都是遵照SD规范来发布的。这些规范规定了SD卡的读写速度、读写接口时序、读写命令集、卡大小尺寸、引脚个数及定义。这样做的好处就是不同厂家的SD卡可以通用。

### 1.10.1.4、iNand、MoviNand、eSSD

(1)电子产品如手机、相机等，前些年趋势是用SD卡/TF卡等扩展存储容量；但是近年来的趋势是直接内置大容量Flash芯片而不是外部扩展卡。

(2)外部扩展卡时间长了卡槽可能会接触不良导致不可靠。

(3)现在主流的发展方向是使用iNand、MoviNand、eSSD（还有别的一些名字）来做电子产品的存储芯片。这些东西的本质还是NandFlash，内部由Nand的存储颗粒构成，再集成了块设备管理单元，综合了SD卡为代表的各种卡的优势和原始的NandFlash芯片的优势。

(4)优势：1、向SD卡学习，有统一的接口标准（包括引脚定义、物理封装、接口时序）。2、向原始的Nand学习，以芯片的方式来发布而不是以卡的方式；

3、内部内置了Flash管理模块（MCU），提供了诸如坏块管理等功能，让Nand的管理容易了起来。

 

 

**拓展：**

**NOR**的特点是芯片内执行(XIP, eXecute In Place)，这样应用程序可以直接在Flash 闪存内运行，不必再把代码读到系统RAM中。 NOR的传输效率很高，在1～4MB的小容量时具有很高的成本效益，但是很低的写入和擦除速度大大影响了它的性能。 

**NAND**结构能提供极高的单元密度，可以达到高存储密度，并且写入和擦除的速度也很快。应用NAND的困难在于Flash的管理和需要特殊的系统接口。

**OneNand**是针对消费类电子和下一代移动手机市场而设计的，一种高可靠性嵌入式存储设备。随着过去几十年的Nand技术的发展，一些公司，基于原先的NAND的架构，设计出一种理想的单存储芯片，其集成了SRAM的缓存和逻辑接口。OneNand既实现NOR Flash的高速读取速度，又保留了Nand Flash的大容量数据存储的优点。

 

**一、iNAND**

 

iNAND是SanDisk公司研发的存储芯片，可以简单的看成SD卡或MMC卡芯片化。用户完全可以默认他是SD卡或者MMC卡。   相对MLC，iNAND有以下优点：

1、提高性能

1）减少SOC的工作量，节约SOC资源。如果使用MLC做存储，SOC要参与FLASH的坏块管理、ECC校正等管理，会牺牲部分SOC性能，而使用iNAND的话，FLASH的管理工作都有iNAND完成，SOC只在需要时对iNAND进行读写，其他时候完全可以不需要理会iNAND。

2）读写速度快

（1）iNAND内置Cache模块，如果要存储小于4K的小容量文件时，Cache能够帮助用户将速度提高至MLC的10倍左右，并且Cache模块不需要用户控制，只要存储小容量文件，Cache自动启动，非常方便。

（2）iNAND可以将内置的MLC FLASH模拟成为为SLC，是iNAND具有SLC的读写速度及其他性能，从而提高读写速度。

3）产品更可靠稳定iNAND内置掉电保护、Wear leveling等SANDISK专利技术，可以帮助客户提高FLASH的读写寿命，以及防止系统忽然掉电损坏系统文件，降低产品返修率。

2、降低系统成本   

首先因为iNANDZ中选用的FLASH一般都是市场上最新、最先进制程的FLASH，所以iNAND具有一定的价格优势。    

其次，iNAND不同容量的封装一致，客户如果某款机型有不同容量的几个型号，那么它PCB只需要做一套即可，可以帮助客户简化工作、提高效率，比如苹果iPHONE有8G、16G等容量产品，他的PCB只需要一套，生产时候贴上对用的iNAND即可。

3、方便采购     

采购iNAND时候只需要注意使用的容量，不需要管制程、架构。而很多CPU对普通NAND FLASH不是完全兼容，假如某款CPU最多支持51nm制程的FLASH，如果FLASH厂家产品升级，该客户就可能遇到采购困难等问题，而且市场上也有三星、现代、美 光等公司的产品，他们都是完全遵照JEDEC委员会的标准，产品完全兼容。  

4、使用简单，加快贵司产品研发进度

1）对软件工程师而言，FLASH制程改变，其对应驱动也需要随之变化，其程序移植、代码升级都要重新调试，而iNAND的产品驱动完全一样，一次调试成功就无后顾之忧；

2）对应硬件工程师也可能会因为新FLASH要重新布板，增加工作强度，而iNAND不管多大容量，封装都一样，如果贵司产品容量升级，可以直接在原先的PCB上换上更高容量的iNAND即可。 

 

 

 

**二、oneNAND**

 

 OneNand是针对消费类电子和下一代移动手机市场而设计的，一种高可靠性嵌入式存储设备。

随着过去几十年的Nand技术的发展，一些公司，基于原先的NAND的架构，设计出一种理想的单存储芯片，其集成了SRAM的缓存和逻辑接口。

OneNand既实现NOR Flash的高速读取速度，又保留了Nand Flash的大容量数据存储的优点。

与OneNand对应的是之前早就出现的Nand Flash和Nor Flash。

 

【OneNand Flash的特点】

和其他两种相比较，就比较容易看清OneNand的特点了：

OneNand Nand Nor 三种Flash的区别

 

 

三星推出的OneNAND是结合NAND型Flash高密度特性，与NOR型Flash读取速度快的优点，主要适用消费性电子市场，包括手机、数字电视、数码相机、全球卫星定位系统（GPS）等，对于需要嵌入式应用的厂商，选择以OneNAND来替代NAND型Flash加上NOR型Flash，是可行的解决方案。

 

我记得S5PV210 拥有oneNand控制器，看看是咋样接口的

S5PV210 supports external 16-bit bus for OneNAND and Flex-OneNAND memory devices. The OneNAND 

controller supports asynchronous and synchronous read/ write bus operations. It also integrates its own dedicated 

DMA engine to accelerate the operations of OneNAND memory device. 

 

从上面可以看出，oneNand其实就是具有Nand 便宜的价格特性，大容量的Norflash非常类似。这个接口缺点就是需要太多数据线了。

而iNand只要4bit 的SDIO接口就可以了，所以oneNand 和iNand比起来，完败！这就是oneNand 在市场上很少见到的原因。

 

 

**三、moviNAND**

 

MoviNAND 是 NAND + MMC controller 封装在一起，透过 eMMC 4.3的protocol 去存取NAND 的资料

好处是embedded系统不用考虑NAND Flash 读写演算法(FTL)与 Hardware ECC 部份，因为FTL须考虑断电资料保护，平均抹除，坏块处理等等问题

MoviNAND  和iNand一样，其实是emmc 标准的一种！

所以moviNAND 就是和iNand 一样的，甚至是兼容的东西，只是估计三星棒子价格比较贵，大家都选择sandisk的emmc iNand了。

————————————————

版权声明：本文为CSDN博主「andylauren」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/andylauren/article/details/52204895

### 1.10.1.5、SSD（固态硬盘）

SSD也是用flash做成的 。eSSD和SSD的却别在于，eSSD是做成芯片的样子旱灾板子上的，而SSD是封装好，有插槽，插在板子上的。

 

## 1.10.2.SD卡的特点和背景知识

### 1.10.2.1、SD卡和MMC卡的关系

(1)MMC标准比SD标准早，SD标准兼容MMC标准。

(2)MMC卡可以被SD读卡器读写，而SD卡不可以被MMC读卡器读写。

### 1.10.2.2、SD卡和Nand、Nor等Flash芯片差异

(1)SD卡/MMC卡等卡类有统一的接口标准，而Nand芯片没有统一的标准（各家产品会有差异）。

### 1.10.2.3、SD卡与MicroSD的区别

(1)体积大小区别而已，传输与原理完全相同。

### 1.10.2.4、SD卡与TF卡的区别

(1)外观上，SD卡大而TF卡小；用途上，SD卡用于数码相机等而TF卡广泛用于手机、GPS等；

(2)时间上，SD卡1999年推出，TF卡于2004年推出；SD卡由日本松下、东芝与美国SanDisk共同推出，而TF卡由Motorola与SanDisk共同推出。

(3)SD卡有写保护而TF卡没有，TF卡可以通过卡套转成SD卡使用。

 

## 1.10.3.SD卡的编程接口

### 1.10.3.1、SD卡的物理接口

(1)SD卡由9个针脚与外界进行物理连接，这9个脚中有2个地，1个电源，6个信号线。

### 1.10.3.2、SD协议与SPI协议

(1)SD卡与SRAM/DDR/SROM之类的东西的不同：SRAM/DDR/SROM之类的存储芯片是总线式的，只要连接上初始化好之后就可以由SoC直接以地址方式来访问；但是SD卡不能直接通过接口给地址来访问，**它的访问需要按照一定的接口协议（时序）来访问**。

(2)SD卡虽然只有一种物理接口，但是却支持两种读写协议：SD协议和SPI协议。

 

### 1.10.3.3、SPI协议特点（低速、接口操作时序简单、适合单片机）

(1)SPI协议是单片机中广泛使用的一种通信协议，**并不是为SD卡专门发明的**。

(2)SPI协议相对SD协议来说速度比较低。

(3)SD卡支持SPI协议，就是为了单片机方便使用。

 

### 1.10.3.4、SD协议特点（高速、接口时序复杂，适合有SDIO接口的SoC）

(1)SD协议是专门用来和SD卡通信的。

(2)SD协议要求SoC中有SD控制器，运行在高速率下，要求SoC的主频不能太低。

 

### 1.10.3.5、S5PV210的SD/MMC控制器

(1)数据手册Section8.7，为SD/MMC控制器介绍。

(2)SD卡内部除了存储单元Flash外，还有SD卡管理模块，我们SoC和SD卡通信时，通过9针引脚以SD协议/SPI协议向SD卡管理模块发送**命令**、**时钟**、**数据**等信息，然后从SD卡返回信息给SoC来交互。工作时每一个任务（譬如初始化SD卡、譬如读一个块、譬如写、譬如擦除····）都需要一定的时序来完成（所谓时序就是先向SD卡发送xx命令，SD卡回xx消息，然后再向SD卡发送xx命令····）。

 

## 1.10.4.S5PV210的SD卡启动详解1（很重要）

### 1.10.4.1、SoC为何要支持SD卡启动

(1)一个普遍性的原则就是：SoC支持的启动方式越多，将来使用时就越方便，用户的可选择性就越大，SoC的适用面就越广。

(2)SD卡有一些好处：譬如可以在不借用专用烧录工具（类似Jlink）的情况下对SD卡进行刷机，然后刷机后的SD卡插入卡槽，SoC既可启动；譬如可以用SD卡启动进行量产刷机（量产卡）。像我们X210开发板，板子贴片好的时候，内部iNand是空的，此时直接启动无启动；板子出厂前官方刷机时是把事先做好的量产卡插入SD卡卡槽，然后打到iNand方式启动；因为此时iNand是空的所以第一启动失败，会转而第二启动，就从外部SD2通道的SD卡启动了。启动后会执行刷机操作对iNand进行刷机，刷机完成后自动重启（这回重启时iNand中已经有image了，所以可以启动了）。刷机完成后SD量产卡拔掉，烧机48小时，无死机即可装箱待发货。

 

### 1.10.4.2、SD卡启动的难点在哪里（SRAM、DDR、SDCard）

(1)SRAM、DDR都是总线式访问的，SRAM不需初始化既可直接使用而DDR需要初始化后才能使用，但是总之CPU可以直接和SRAM/DRAM打交道；而SD卡需要时序访问，CPU不能直接和SD卡打交道；NorFlash读取时可以总线式访问，所以Norflash启动非常简单，可以直接启动，但是SD/NandFlash不行。

(2)以前只有Norflash可以作为启动介质，台式机笔记本的BIOS就是Norflash做的。后来三星在2440中使用了SteppingStone的技术，让Nandflash也可以作为启动介质。SteppingStone（翻译为启动基石）技术就是在SoC内部内置4KB的SRAM，然后开机时SoC根据OMpin判断用户设置的启动方式，如果是NandFlash启动，则SoC的启动部分的硬件直接从外部NandFlash中读取开头的4KB到内部SRAM作为启动内容。

(3)启动基石技术进一步发展，在6410芯片中得到完善，在210芯片时已经完全成熟。210中有96KB的SRAM，并且有一段iROM代码作为BL0，BL0再去启动BL1（210中的BL0做的事情在2440中也有，只不过那时候是硬件自动完成的，而且体系没有210中这么详细）。

 

### 1.10.4.3、S5PV210的启动过程回顾

(1)210启动首先执行内部的iROM（也就是BL0），BL0会判断OMpin来决定从哪个设备启动，如果启动设备是SD卡，则BL0会从SD卡读取前16KB（不一定是16，反正16是工作的）到SRAM中去启动执行（这部分就是BL1，这就是steppingstone技术）

(2)BL1执行之后剩下的就是软件的事情了，SoC就不用再去操心了。

 

### 1.10.4.4、SD卡启动流程（bin文件小于16KB时和大于16KB时）

(1)**启动的第一种情况：**是整个镜像大小小于16KB。这时候相当于我的整个镜像作为BL1被steppingstone直接硬件加载执行了而已。

(2)**启动的第二种情况：**就是整个镜像大小大于16KB。（只要大于16KB，哪怕是17KB，或者是700MB都是一样的）这时候就要把整个镜像分为2部分：第一部分16KB大小，第二部分是剩下的大小。然后第一部分作为BL1启动，负责去初始化DRAM并且将第二部分加载到DRAM中去执行（uboot就是这样做的）。

### 1.10.4.5、最重要的但是却隐含未讲的东西

(1)问题：iROM究竟是怎样读取SD卡/NandFlash的？

(2)三星在iROM中事先内置了一些代码去初始化外部SD卡/NandFlash，并且内置了读取各种SD卡/NandFlash的代码在iROM中。BL0执行时就是通过调用这些device copy function来读取外部SD卡/NandFlash中的BL1的。

 

## 1.10.5.S5PV210的SD卡启动详解2

### 1.10.5.1、SoC支持SD卡启动的秘密（iROM代码）

(1)三星系列SoC支持SD卡/NandFlash启动，主要是依靠**SteppingStone**技术，具体在S5PV210中支持steppingstone技术的是内部的iROM代码。

 

### 1.10.5.2、再看iROM application note：block device copy function

 

globlBlockSize 设备总共有多少个块的组成

goblSDHCinfoBit 这个SD卡使用几Bit来读写的

V210_SDMMC_BASE 因为210有4个SD CHANEL，通道0 和通道2是用来启动，那么210是怎么判断是哪个通道启动？就是通过这个，你把硬件赛道哪个通道里，这个BASE就会自动置位1，然后通过软件来读这个地址当中的值，就可以知道它的卡在那个位置。

 

Copy Function是在IROM里面的，固化的。 NF8 nandflash  8bit接口的

   我们要用的是这个Copy Function，

这oxD0037F98 **这里面存的是Copy Function的函数指针**

 

所以我们就可以用函数指针来访问。

 

 

 

 

这个就是要调用的Copy Function

(bool(*)(int, unsigned int, unsigned short, unsigned int*, bool)

返回值是个bool类型，接受5个类型的参数，返回值一般都用来表示成功还是失败了。

第一个int 是通道号， 210启动只支持 0,2 ， 0通道inand占用了， 我们要用通道2。

第二 unsigned int 是起始块地址。

第三个  unsigned short 你要复制多少个块。

第4个  unsigned int*  你要复制到我们内存的那里去。

第5个  bool   决定卡的初始化  ，给0就可以。

 

### 1.10.5.3、扇区和块的概念（重点）

(1)早期的块设备就是软盘硬盘这类磁存储设备，这种设备的存储单元不是以字节为单位，而是以扇区为单位。磁存储设备读写的**最小单元就是扇区**，不能只读取或写部分扇区。这个限制是磁存储设备本身物理方面的原因造成的，也成为了我们编程时必须遵守的规律。

(2)一个扇区有好多个字节（一般是512个字节）。早期的磁盘扇区是512字节，实际上后来的磁盘扇区可以做的比较大（譬如1024字节，譬如2048字节，譬如4096字节），但是因为原来最早是512字节，很多的软件（包括操作系统和文件系统）已经默认了512这个数字，因此后来的硬件虽然物理上可能支持更大的扇区，但是实际上一般还是兼容512字节扇区这种操作方法。

(3)一个扇区可以看成是一个块block（块的概念就是：不是一个字节，是多个字节组成一个共同的操作单元块），所以就把这一类的设备称为块设备。常见的块设备有：磁存储设备硬盘、软盘、DVD和Flash设备（U盘、SSD、SD卡、NandFlash、Norflash、eMMC、iNand）。

(4)linux里有个mtd驱动，就是用来管理这类块设备的。

(5)磁盘和Flash以块为单位来读写，就决定了我们启动时device copy function只能以整块为单位来读取SD卡。

 

### 1.10.5.4、用函数指针方式调用device copy function

(1)第一种方法：宏定义方式来调用。好处是简单方便，坏处是编译器不能帮我们做参数的静态类型检查。

(2)第二种方法：用函数指针方式来调用。

 

typedef unsigned int bool;

//第一种方法：宏定义

\#define CopySDMMCtoMem(z,a,b,c,e)\

(((bool(*)(int, unsigned int, unsigned short, unsigned int*, bool)) \ (*((unsigned int *)0xD0037F98)))(z,a,b,c,e))

 

//第二种方法：用函数指针方式调用

typedef bool(*pCopySDMMCC2Mem)(int, unsigned int, unsigned short, \

unsigned int*, bool)

 

//实际使用时

pCopySDMMCC2Mem p1 =(pCopySDMMCC2Mem)0xD0037F98;

 

p1(x, x, x, x, x);// 第一种调用方法

(*p1)(x, x, x, x, x)//第二种调用方法

*p1(x, x, x, x, x)//这种调用方法错误 ，因为p1先和（）结合了

 

 

## 1.10.6.S5PV210的SD卡启动实战1

### 1.10.6.1、任务：大于16KB的bin文件使用SD卡启动

(1)**总体思路**：将我们的代码分为2部分：**第一部分**BL1小于等于16KB**，第二部分**为任意大小，iROM代码执行完成后从SD卡启动会自动读取BL1到SRAM中执行；BL1执行时负责初始化DDR，然后手动将BL2从SD卡copy到DDR中正确位置，然后BL1远跳转到BL2中执行BL2.

 

 

 

(2)**细节1**：程序怎么安排？程序整个分为2个文件夹BL1和BL2，各自管理各自的项目。

(3)**细节2**：BL1中要完成：关看门狗、设置栈、开iCache、初始化DDR、从SD卡复制BL2到DDR中特定位置，跳转执行BL2.

(4)**细节3**：BL1在SD卡中必须从Block1开始（Block0不能用，这个是三星官方规定的），长度为16KB内，我们就定为16KB（也就是32个block）；BL1理论上可以从33扇区开始，但是实际上为了安全都会留一些空扇区作为隔离，譬如可以从45扇区开始，长度由自己定（实际根据自己的BL2大小来分配长度，我们实验时BL2非常小，因此我们定义BL2长度为16KB，也就是32扇区）。

 

(5)**细节4**：DDR初始化好之后，整个DDR都可以使用了，这时在其中选择一段长度足够BL2的DDR空间即可。我们选0x23E00000（因为我们BL1中只初始化了DDR1，地址空间范围是0x20000000～0x2FFFFFFF）。只要在这个范围之内，都可以。之所以选择这个是因为uboot选择了这个位置。

 

 

### 1.10.6.2、代码划分为2部分（BL1和BL2）

 

### 1.10.6.3、BL1中的重定位

. = 0xd0020010;

### 1.10.6.4、BL2远跳转

(1)因为我们BL1和BL2其实是2个独立的程序，链接时也是独立分开链接的，所以不能像以前一样使用ldr pc, =main这种方式来通过链接地址实现元跳转到BL2.

(2)我们的解决方案是使用地址进行强制跳转。因为我们知道**BL2在内存地址0x23E00000处**，(BL2 link.lsd 里面的连接起始地址地改成这个地址)所以直接去执行这个地址即可。



 

### 1.10.6.5.1 inux中dd命令的解析

**1****、dd命令的作用（功能）**

主用功能是用于拷贝文件，也就是用指定大小的块去拷贝一个文件，并在拷贝的同时进行指定的转换（默认从标准输入拷贝到标准输出，这意味dd可以在管道中使用）。这个拷贝过程简单理解就是读取，转换并输出数据。

**语　　法**：dd [bs=<字节数>][cbs=<字节数>][conv=<关键字>][count=<区块数>][ibs=<字节数>][if=<文件>][obs=<字节数>][of=<文件>][seek=<区块数>][skip=<区块数>][--help][--version]

**补充说明**：dd可从标准输入或文件读取数据，依指定的格式来转换数据，再输出到文件，设备或标准输出。

 

**2****、dd命令使用示例一**

sudo dd iflag=dsync oflag=dsync if=210.bin of=/dev/sdb seek=1

 

解析：sudo是超级用户权限，dd是linux 的命令；dsync 读写数据采用同步IO；

 

iflag=flag              使用iflag来控制输入(读取数据)时的行为特征。

 

oflag=flag             使用oflag来控制输出(写入数据)时的行为特征。

 

seek=1               表示跳过第零个扇区，从第一个扇区开始

 

因此意思是：使用**超级用户权限**把210.bin读取进来，经过处理再输出到设备sdb上，跳过该设备的第一个block（每个block的大小为512B）

 

**3****、dd命令使用示例二：破坏iNAND的bootloader**

S5PV210默认从内置的eMMC中启动，官方默认在这里iNAND中刷入了Android4.0，如果我们想要从SD卡启动，就需要先破坏iNAND中的Android镜像，方法是这样的：

 

进入android系统控制台，执行如下指令： busybox dd if=/dev/zero of=/dev/block/mmcblk0 bs=512 seek=1 count=1 conv=sync 

为了确保执行数据有效，再执行sync同步一下，即可破坏掉前一个块的数据。 

 

linux的dd命令，是用来读写磁盘的，我们把内部的iNAND作为一个磁盘，位于：/dev/block/mmcblk0，也就是我们这里的of输出文件，输入if文件是：/dev/zero，这样就把iNAND写入了全0，写入块大小为512字节（一个扇区），seek表示写入第一个扇区，因为bootloader就是从扇区1开始的，count为1表示写入长度为1个扇区，剩余的扇区不要动，只要破坏一个扇区uboot就启动不起来了。

 

【S5PV210_iROM_ApplicationNote_Preliminary_20091126】 这份文档中截图如下：

 

**常用选项说明**

 bs=比特数      一次读写的比特数

 cbs=比特数     一次转换的比特数

 conv=CONVS  依照每个逗号分割的标志列表转换文件

 count=块数      只将指定个块数复制到块

 ibs=比特数      一次读取的比特数(默认：512)

 if=文件         从指定文件中读取

 iflag=flag       按照以逗号分隔的符号列表指定的方式读取

 obs=比特数     一次写入指定比特数(默认：512)

 of=文件        写入到指定文件

 oflag=flag       按照以逗号分隔的符号列表指定的方式写入

 seek=块数      在输出开始处跳过指定的块数

 skip=块数      在输入开始处跳过指定的块数

 status=noxfer    禁止传输统计

 

  status=LEVEL LEVEL用来控制dd程序的输出信息的。分别有三个，“none”，“noxfer”和“progress”，默认是“progress”。“none”的意思是不输出任何相关信息，除非出错信息。“noxfer”不会输出最后的统计信息，而“progress”会输出所有信息。

 

补充：在上面所有选项的BYTES和N中，我们都可以使用特殊的字符来表示数据大小，常用的有b=512，K=1024，M=1024*1024，G=1024*1024*1024。

 

**flag****参数说明**

 append    追加模式(仅对输出有意义；隐含了conv=notrunc)

 direct     使用直接I/O 存取模式

 directory  除非是目录，否则 directory 失败

 dsync     使用同步I/O 存取模式

 sync      与上者类似，但同时也对元数据生效

 fullblock   为输入积累完整块(仅iflag)

 nonblock  使用无阻塞I/O 存取模式

 noatime   不更新存取时间

 nocache  丢弃缓存数据

 noctty     不根据文件指派控制终端

 nofollow   不跟随链接文件

 

————————————————

版权声明：本文为CSDN博主「aoxiang_ywj」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/baidu_37973494/article/details/82734594

这是我们所要执行烧录的BL1和BL2

sudo dd iflag=dsync oflag=dsync if=./BL1/BL1.bin of=/dev/sdb seek=1

sudo dd iflag=dsync oflag=dsync if=./BL2/BL2.bin of=/dev/sdb seek=45

 

### 1.10.6.5 .2 同时执行BL1和BL2的Makefile

all:

  \#进入到这个目录底下去make

  make -C ./BL1  

  make -C ./BL2

 

clean:

  make clean -C ./BL1

  make clean -C ./BL2

 

## 1.10.7.S5PV210的SD卡启动实战2

### 1.10.7.1、烧录启动实验

//sd_relocate.c

 

\#define SD_BLOCK_CNT  32

\#define SD_START_BLOCK 45

\#define DDR_START_ADDR 0X23E00000

 

typedef unsigned int bool;

 

/*

第1个  int 是通道号， 210启动只支持 0,2 ， 0通道inand占用了， 我们要用通道2

第2个  unsigned int 是起始块地址

第3个 unsigned short 你要复制多少个块

第4个  unsigned int*  你要复制到我们内存的那里去

第5个  bool   决定卡的初始化 ，给0就可以。

*/

 

typedef void(*pBL2Type)(void);

 

typedef bool(*pCopySDMMCC2Mem)(int, unsigned int, unsigned short, unsigned int*, bool);

 

//从SD卡第45扇区开始，复制32个扇区内容到DDR的0x23E00000

void copy_bl2_2_ddr(void)

{  //第一步，读取SD卡扇区到我们DDR中

  pCopySDMMCC2Mem p1 =(pCopySDMMCC2Mem)(*(unsigned int *)0xD0037F98);

  p1 (2,SD_START_BLOCK ,SD_BLOCK_CNT,(unsigned int *)DDR_START_ADDR,0);

  

  //第二步，跳转到DDR中的BL2去执行

  // (1)因为我们BL1和BL2其实是2个独立的程序，链接时也是独立分开链接的

  //，所以不能像以前一样使用ldr pc, =main这种方式来通过链接地址实现远跳转到BL2.

  //(2)我们的解决方案是使用地址进行强制跳转。因为我们知道BL2在内存地址

  //0x23E00000处，所以直接去执行这个地址即可。

  pBL2Type p2 =(pBL2Type)DDR_START_ADDR;

  p2();

}

//BL1/start.S

 

\#define WTCON    0xE2700000

\#define SVC_STACK  0xd0037d80

 

.global _start         // 把_start链接属性改为外部，这样其他文件就可以看见_start了

_start:

  // 第1步：关看门狗（向WTCON的bit5写入0即可）

  ldr r0, =WTCON

  ldr r1, =0x0

  str r1, [r0]

  

  // 第2步：设置SVC栈

  ldr sp, =SVC_STACK

  

  // 第3步：开/关icache

  mrc p15,0,r0,c1,c0,0      // 读出cp15的c1到r0中

  //bic r0, r0, #(1<<12)     // bit12 置0 关icache

  orr r0, r0, #(1<<12)      // bit12 置1 开icache

  mcr p15,0,r0,c1,c0,0

 

  // 第4步：初始化ddr

  bl sdram_asm_init

  

  // 第5步：重定位,从SD卡第45扇区开始，复制32个扇区内容到DDR的0x23E00000

  bl copy_bl2_2_ddr

 

  

// 汇编最后的这个死循环不能丢

  b .

  

 

起初写的是这一句

 pCopySDMMCC2Mem p1 =(pCopySDMMCC2Mem)0xD0037F98);

发现烧录执行的过程中没有任何反应，经过排查，0xD0037F98，这个地址里面存的是

指向CopyFuction的指针地址，所以我们要先解引用它：

pCopySDMMCC2Mem p1 =(pCopySDMMCC2Mem)(*(unsigned int *)0xD0037F98);

这样子才是对的；

pBL2Type p2 =(pBL2Type)DDR_START_ADDR;

这一句之所以不用解引用是因为函数的地址本来就在那儿，他不是存的指向函数的指针地址；

 

// ./BL2/start.S

 

.global _start   

_start:

  //run_on_dram:

  ldr pc, =main;   //ldr指令是长跳转指令

 

​    

// 汇编最后的这个死循环不能丢

  b .

 

// BL2/led.c 这就是将BL2加载到DDR真正运行的程序

\#define GPJ0CON   0xE0200240

\#define GPJ0DAT   0xE0200244

 

\#define rGPJ0CON  *((volatile unsigned int *)GPJ0CON)

\#define rGPJ0DAT  *((volatile unsigned int *)GPJ0DAT)

 

void delay(void);

 

 

// 该函数要实现led闪烁效果

void main(void)

{

  // led初始化，也就是把GPJ0CON中设置为输出模式

  //volatile unsigned int *p = (unsigned int *)GPJ0CON;

  //volatile unsigned int *p1 = (unsigned int *)GPJ0DAT;

  rGPJ0CON = 0x11111111;

  

  while (1)

  {

​    // led亮

​    rGPJ0DAT = ((0<<3) | (0<<4) | (0<<5));

​    // 延时

​    delay();

​    // led灭

​    rGPJ0DAT = ((1<<3) | (1<<4) | (1<<5));

​    // 延时

​    delay();

  }

}

 

void delay(void)

{

  volatile unsigned int i = 900000;    // volatile 让编译器不要优化，这样才能真正的减

  while (i--);              // 才能消耗时间，实现delay

}

 

  

### 1.10.7.2、代码分为2部分启动（上一节讲的）的缺陷

(1)代码分为2部分，这种技术叫分散加载。这种分散加载的方法可以解决问题，但是比较麻烦。

(2)**分散加载的缺陷**：第一，代码完全分2部分，完全独立，代码编写和组织上麻烦；第二，无法让工程项目兼容SD卡启动和Nand启动、NorFlash启动等各种启动方式。

​    这个方法后来就被摒弃掉了。

### 1.10.7.3、uboot中的做法

(1)第二种思路：程序代码仍然包括BL1和BL2两部分，但是组织形式上不分为2部分而是作为一个整体来组织。它的实现方式是：iROM启动然后从SD卡的扇区1开始读取16KB的BL1然后去执行BL1，BL1负责初始化DDR，然后从SD卡中读取整个程序（BL1+BL2）到DDR中，然后从DDR中执行（利用ldr pc, =main这种方式以远跳转从SRAM中运行的BL1跳转到DDR中运行的BL2）。

 

### 1.10.7.4、再来分析uboot的SD卡启动细节

(1)uboot编译好之后有200多KB，超出了16KB。uboot的组织方式就是前面16KB为BL1，剩下的部分为BL2。

(2)uboot在烧录到SD卡的时候：

1、先截取uboot.bin的前16KB（实际脚本截取的是8KB）烧录到SD卡的block1～bolck32；

2、然后将整个uboot烧录到SD卡的某个扇区中（譬如49扇区）

(3)**实际uboot从SD卡启动时是这样的**：iROM先执行，根据OMpin判断出启动设备是SD卡，然后从S卡的block1开始读取16KB（8KB）到SRAM中执行BL1，BL1执行时负责初始化DDR，并且从SD卡的49扇区开始复制整个uboot到DDR中指定位置（0x23E00000）去备用；然后BL1继续执行直到ldr pc, =main时BL1跳转到DDR上的BL2中接着执行uboot的第二阶段。

 

**总结：**uboot中的这种启动方式比上节讲的分散加载的好处在于：**能够兼容各种启动方式**。

 

## 1.10.8.解决X210开发板的软开关按键问题

### 1.10.8.1、X210开发板的软启动电路详解

(1)210供电需要的电压比较稳定，而外部适配器的输出电压不一定那么稳定，因此板载了一个文稳压器件MP1482.这个稳压芯片的作用就是外部适配器电压在一定范围内变化时稳压芯片的输出电压都是5V。

(2)MP1482芯片有一个EN（Enable）引脚，这个引脚可以让稳压芯片输出或关闭输出。EN为高电平时有输出电压，EN引脚为低电平时稳压芯片无输出。

(3)两个因素可以影响EN引脚的电平：

第一个是POWER按键（SW1），POWER按键按下时EN为高电平，POWER按键弹起时EN为低电平；

第二个是POWER_LOCK（EINT0）引脚，这个引脚为POWER_LOCK模式下高电平，则EN为高；若这个引脚为EINT0模式或者为POWER_LOCK模式但输出为低电平，则EN为低。

(4)图中还有EINT1引脚，这个引脚的作用是用来做中断，提供给CPU用来唤醒的。

 

### 1.10.8.2、为什么要软启动

(1)一般的电路设计都是用拨码开关来做电源开关的（打到一侧则接通，打到另一侧则关闭）。这种方式的优点是设计简单，缺点是电路太简单，整个主板要么有电要么没电无法做休眠模式、低功耗模式等。

(2)软启动电路是比较接近于实际产品的，其他开发板的硬开关其实是简化版的，和实际产品还有差异。

 

### 1.10.8.3、开发板供电置锁原理和分析

(1)软开关在设计时有一个置锁电路，用EINT0（也就是GPH0_2）引脚来控制的。

(2**)EINT0****这个引脚是有复用设计**（两个完全不相干的功能挤在同一个引脚上，同时我们只能让这个引脚用于其中一种功能，这就叫复用）的，一个是GPIO（也就是GPH0_2引脚）、一个是PS_HOLD_CONTROL。（注意：EINT0功能算是GPIO下的一个子功能）

(3)PS_HOLD在Section2.4 Power Management章节下的4.10.5.8节下。

(4)PS_HOLD_CONTROL寄存器（0xE010E81C），共有3个位有用。

​        bit0, 0表示这个引脚为GPIO功能，1表示这个引脚为PS_HOLD功能

​        bit9，0表示这个引脚方向为输入，1表示这个引脚方向为输出

​        bit8，0表示这个引脚输出为低电平，1表示输出为高电平。

​    (1 <<0) | (1<<8) | (1<<9) 

分析：我们要使用软启动置锁，则需要将bit0、8、9都置为1即可。

### 1.10.8.4、写代码+实验验证

(1)要想让开发板和普通的开发板一样，一按下按键程序运行后即可松手不会断电，则只要在程序的开头部分添加代码去置锁开关板即可。

(2)置锁代码的方法是：给PS_HOLD_CONTROL寄存器的bit0、8、9均写入1即可。

(3)注意：此时开发板已经置锁，POWER按键已经失效，关机时需要按下复位按键。

 

//第0步：置锁启动开关

  //第一种方法：不读出来直接写，因为其他为都是reserved的，不会改写到其他位

  ldr r0, = PS_HOLD_CONTROL

  ldr r1, =0x301

  ldr r1, [r0]

  //第二种写法，读改写三步走

  ldr r0, = PS_HOLD_CONTROL

  ldr r1, [r0]

   //这里为什么不直接写0x301呢，因为0x301是非法立即数，，0x300是合法立即数，所以要分开写

  orr r1, r1, #0x300

  orr r1, r1, #0x1    

  str r1, [r0]

  //第三种种写法，读改写三步走，避免非法立即数

  ldr r0, = PS_HOLD_CONTROL

  ldr r1, [r0]

  ldr r2, =0x301

  orr r1, r1,r2      

  str r1, [r0]



 

# 第十一章 NandFlash和iNand

## 1.11.0 章节概要

**1.11.1.NandFlash的接口**

​    本节首先讲解NandFlash的型号命名规则，然后重点解析了NandFlash的结构框图，通过这份数据手册中提供的结构框图，希望大家对Nand的矩阵式存储有个轮廓印象和理解。

**1.11.2.NandFlash的结构**

​    本节讲述Nand的内部结构，包括block、page等概念，带内数据及带外数据(oob)、ECC、坏块标志、Nand的多周期地址时序，Nand的命令码等。

**1.11.3.NandFlash的常见操作及流程分析**

​    本节介绍了NandFlash的典型操作：块擦除、页读、页写。并且以数据手册中的流程图为引向大家讲解这些操作的顺序，以及涉及到的命令码、地址时序、状态寄存器检查等细节。

**1.11.4.S5PV210的NandFlash控制器**

​    本节简单介绍S5PV210的NandFlash控制器，重点讲了Nand控制器的作用，有无控制器的差异，这个是理解Nand控制器的关键，最后简单浏览了S5PV210的Nand控制器的寄存器列表。

**1.11.5.Nand操作代码解析**

​    本节讲解Nand操作代码，以调试好的Nand读写代码为原材料，对照数据手册中之前讲过的知识和流程图，讲述这些代码是怎么写出来的。本节的目的是教会大家如何学习，如何结合手头资源资料学习代码。

**1.11.6.iNand介绍**

​    本节系统介绍iNand，将其与Nand、与SD卡等进行对比，最后得出准确结论，本节课的目的是让大家对iNand芯片有框架式的认可，先知道到底什么是iNand。

**1.11.7.SD卡/iNand操作**

​    本节讲述iNand/SD卡的一些操作概念，包括：iNand的硬件接口、iNand的命令响应式工作模式、iNand的内部结构框图及SoC的iNand控制器的寄存器简介。

**1.11.8.SD/iNand代码实战分析1**

​    本节以linux驱动中iNand操作的代码为原材料，逐行分析代码，讲述这些代码和iNand协议文档、数据手册之间的对应关系，试图告诉大家这些代码是怎样写出来的。一共3节，此为第1节。

**1.11.9.SD/iNand代码实战分析2**

​    本节以linux驱动中iNand操作的代码为原材料，逐行分析代码，讲述这些代码和iNand协议文档、数据手册之间的对应关系，试图告诉大家这些代码是怎样写出来的。一共3节，此为第2节。

**1.11.10.SD/iNand代码实战分析3**

​    本节以linux驱动中iNand操作的代码为原材料，逐行分析代码，讲述这些代码和iNa

## 1.11.1.NandFlash的接口

### 1.11.1.1、Nand的型号与命名

(1)Nand的型号命名都有含义，就拿K9F2G08来示例分析一下：K9F表示是三星公司的NandFlash系列。2G表示Nand的大小是2Gbit（256MB）。08表示Nand是8位的（8位就是数据线有8根）。

(2)Nand命名中可以看出：厂家、系列型号、容量大小、数据位数。

### 1.11.1.2、Nand的数据位

(1)Nand有8位数据位的，有16位数据位的。做电路时/写软件时应该根据自己实际采购的Nnad的位数来设计电路/写软件。

(2)说明Nand是并行接口的（8/16位）

(3)Nand的数据线上传递的不一定全部是有效数据，也可能有命令、地址等。

### 1.11.1.3、Nand的功能框图

 

(1)Nand的结构可以看成是一个矩阵式存储器，其中被分成一个一个的小块，每一小块可以存储一个bit位，然后彼此以一定单位组合成整个Nand。

(2)Nand中可以被单次访问的最小单元（就是说对Nand进行一次读写至少要读写这么多，或者是这么多的整数倍）叫做Page（页），在K9F2G08芯片中，Page的大小是2KB+64B。也就是说我们要读写K9F2G08，每次至少要读写2KB或者n*2KB，即使我们只是想要其中的一个字节。这就是我们说的典型的块设备（现在有些块设备为了方便，提供了一种random read模式，可以只读取1个字节）。

(3)**页**往上还有个Block（块）的概念，1个块等于若干个页（譬如在K9F2G08中1个块等于64页）。

(4)**块**往上就是整个Nand芯片了，叫做Device。一个Device是若干个Block，譬如K9F2F08一个Device有2028个block。所以整个Device大小为：2048×64×2K = 256MB

(5)**块设备分page、block有什么意义**？首先要明白，块设备不能完全按字节访问而必须块访问是物理上的限制，而不是人为设置的障碍。其次，Page和Block各有各的意义，譬如Nand中：**Page****是读写Nand的最小单位；Block是擦除Nand的最小单位**。（这些规则都是Nand的物理原理和限制要求的，不是谁想要这样的，所以对于我们做软件的来说，只能去想办法适应硬件，不是想着超越硬件）。

(6)Nand芯片中主要包含2部分：**Nand****存储颗粒+Nand接口电路**。存储颗粒就是纯粹的Nand原理的存储单元，类似于仓库；Nand接口电路是用来管理存储颗粒，并且给外界提供一个统一的Nand接口规格的访问接口的。Soc提供NAND 的控制器和NAND电路接口对接。

 

 

(7)Nand中有多个存储单元，每个单元都有自己的地址（地址是精确到字节的）。所以Nand是地址编排精确到字节，但是实际读写却只能精确到页（所以Nand的很多操作都要求给的地址是页对齐的，譬如2K、4K、512K等这样的地址，不能给3000B这样的地址）。Nand读写时地址传递是通过IO线发送的，**因为地址有30位而IO只有8位，所以需要多个cycle才能发送完毕。一般的Nand都是4cycle或者5cycle发送地址**（从这里把Nand分为了4cycle Nand和5cycle Nand）。

 

 

**总结：**Nand芯片内部有存储空间，并且有电路来管理这些存储空间，向外部提供统一的Nand接口的访问规则，然后外部的SoC可以使用Nand接口时序来读写这个Nand存储芯片。Nand接口是一种公用接口，是一种标准，理论上来说外部SoC可以直接模拟Nand接口来读写Nand芯片，但是实际上因为nand接口对时序要求非常严格，而且时序很复杂，所以一般的SoC都是通过专用的硬件的Nand控制器（这些控制器一般是作为SoC的内部外设来存在的）来操控Nand芯片的。

## 1.11.2.NandFlash的结构

### 1.11.2.1、Nand的单元组织：block与page（大页Nand与小页Nand）

(1)Nand的页和以前讲过的块设备（尤其是硬盘）的扇区是类似的。**扇区**最早在磁盘中是512字节，后来也有些高级硬盘扇区不是512字节而是1024字节/2048字节/4096字节等。Nand也是一样，不同的Nand的页的大小是不同的，也有512字节/1024字节/2048字节/4096字节等。·把字节较大的页叫大页，他是相对的，不是绝对的。

(2)一个block等于多少page也是不定的，不同的Nand也不同。一个Nand芯片有多少block也是不定的，不同的Nand芯片也不同。

**总结：**Nand的组织架构挺乱的，接口时序也不同，造成结构就是不同厂家的Nand芯片，或者是同一个厂家的不同系列型号存储容量的nand接口也不一样。所以nand有一个很大的问题就是一旦升级容量或者换芯片系列则硬件要重新做、软件要重新移植。

 

### 1.11.2.2、带内数据和带外数据（ECC与坏块标记）

(1)Nand的每个页由2部分组成，这2部分各自都有一定的存储空间。譬如K9F2G08中为2K+64字节。其中的2K字节属于带内数据，是我们真正的存储空间，将来存储在Nand中的有效数据就是存在这2K范围内的（我们平时计算nand的容量时也是只考虑这2KB）；64字节的带外数据不能用来存储有效数据，是作为别的附加用途的（譬如用来存储**ECC数据**、用来存储坏块标志等····）

(2)什么是**ECC****：（error correction code，错误校验码）**。因为nand存储本身出错（位反转）概率高（Nand较Nor最大的缺点就是稳定性），所以当我们将有效信息存储到Nand中时都会同时按照一定算法计算一个ECC信息（譬如CRC16等校验算法），将ECC信息同时存储到Nand这个页的带外数据区。然后等将来读取数据时，对数据用同样的算法再计算一次ECC，并且和从带外数据区读出的ECC进行校验。如果校验通过则证明Nand的有效数据可信，如果校验不通过则证明这个数据已经被损坏（只能丢弃或者尝试修复）。

(3)**坏块标志**：Nand芯片用一段时间后，可能某些块会坏掉（这些块无法擦除了，或者无法读写了），nand的坏块非常类似于硬盘的坏道。坏块是不可避免的，而且随着Nand的使用坏块会越来越多。当坏块还不算太多时这个Nand都是可以用的，除非坏块太多了不划算使用了才会换新的。所以我们为了管理Nand发明了一种**坏块标志机制**。Nand的每个页的64字节的带外数据中，我们（一般是文件系统）定义一个固定位置（譬如定位第24字节）来标记这个块是好的还是坏的。文件系统在发现这个块已经坏了没法用了时会将这个块标记为坏块，以后访问nand时直接跳过这个块即可。

 

### 1.11.2.3、Nand的地址时序

(1)nand的地址有多位，分4/5周期通过IO引脚发送给Nand芯片来对Nand进行寻址。寻址的最小单位是字节，但是读写的最小单位是页。

(2)nand的地址在写代码时要按照Nand要求的时序和顺序去依次写入。

 

### 1.11.2.4、Nand的命令码

(1)外部SoC要想通过Nand控制器来访问Nand（实质就是通过Nand接口），就必须按照Nand接口给nand发送命令、地址、数据等信息来读写Nand。

(2)Nand芯片内部的管理电路本身可以接收外部发送的命令，然后根据这些命令来读写Nand内容与外部SoC交互。所以我们对nand进行的所有操作（擦除、读、写···）都要有命令、地址、数据的参与才能完成，而且必须按照Nand芯片规定的流程来做。

 

## 1.11.3.NandFlash的常见操作及流程分析

### 1.11.3.1、坏块检查

(1)Flash使用之前要先统一擦除（擦除的单位是块）。Flash类设备擦除后里面全是1，所以擦干净之后读出来的值是0xff。

(2)检查坏块的思路就是：先块擦除，然后将整块读出来，依次检测各自节是否为0xff，如果是则表明不是坏块，如果不是则表明是坏块。

 

 

### 1.11.3.2、页写（program）操作

(1)写之前确保这个页是被擦除干净的。如果不是擦除干净的（而是脏的、用过的）页，写进去的值就是错的，不是你想要的结果。

 

(2)**写操作（write）在flash的操作中就叫编程（program）**

 

什么叫80h呢？是通过命令线发送0x80h的命令码进去。

 

(3)SoC写Flash时通过命令线、IO线依次发送写命令、写页地址、写数据等进入NandFlash。

(4)写的过程：SOC通过Nand控制器和Nand芯片完成顺序对接，然后按照时序要求将一页数据发给Nand芯片内部的接口电路。接口电路先接收收据到自己的**缓冲区**，然后再集中写入Nand芯片的存储区域中。Nand接口电路将一页数据从缓冲区中写入Nand存储系统中需要一定的时间，这段时间Nand芯片不能再响应SOC发过来的其他命令，所以SoC要等待Nnad接口电路忙完。

等待方法是SoC不断读取状态寄存器，这个状态寄存器有2种情况：

一种是SoC的Nand控制器自带的，

另一种是SoC通过发命令得到命令响应得到的），然后通过检查这个状态寄存器的状态位就能知道Nand接口电路刚才写的那一页数据写完了没、写好了没。直到SoC收到正确的状态寄存器响应才能认为刚才要写的那一页数据已经ok。（如果SoC收到的状态一直不对，可以考虑重写或者认为这一页所在的块已经是坏块，或者整个Nand芯片已经挂掉了）。

 

 

(5)正常情况下到了第四步就已经完了。但是因为Nand的读写有不靠谱情况，因此我们为了安全会去做ECC校验。ECC校验有硬件式校验和软件式校验2种。

软件式校验可以采用的策略有很多，其中之一（Nand芯片手册上推荐的方式是）：**软件ECC**将刚才写入的1页数据读出来，和写入的内容进行逐一对比。如果读出的和写入的完全一样，说明刚才的写入过程正确完成了；如果读出来的和写入的不完全一样那就说明刚才的写入有问题。

(6**)****硬件式ECC**：SoC的Nand控制器可以提供硬件式ECC（这个也是比较普遍的情况）。硬件式ECC就是在Nand的控制器中有个硬件模块专门做ECC操作。当我们操作Nand芯片时，只要按照SoC的要求按时打开ECC生成开关，则当我们写入Nand芯片时SoC的Nand控制器的ECC模块会自动生成ECC数据放在相应的寄存器中，然后我们只需要将这生成的ECC数据写入Nand芯片的带外数据区即可；在将来读取这块Nand芯片时，同样要打开硬件ECC开关，然后开始读，在读的过程当中硬件ECC会自动计算读进来的一页数据的ECC值并将之放到相应的寄存器中。然后我们再读取带外数据区中原来写入时存入的ECC值，和我们刚才读的时候得到的ECC值进行校验。校验通过则说明读写正确，校验不通过则说明不正确（放弃数据或者尝试修复）。

 

### 1.11.3.3、擦除（erase）读（read）操作

(1)擦除时必须给块对齐的地址。如果给了不对齐的地址，结果是不可知的（有些Nand芯片没关系，它内部会自动将其对齐，而有些Nand会返回地址错误）。

(2)读写时给的地址也是一样，要求是页对齐地址。如果给了不对齐的，也是有可能对有可能错。

 

## 1.11.4.S5PV210的NandFlash控制器

### 1.11.4.1、SoC的Nand控制器的作用

 

   (1)Nand芯片本身通过Nand接口电路来存取数据，Nand接口电路和SOC之间通过Nand接口时序来通信。Nand接口时序相对复杂，如果要SoC完全用软件来实现Nand接口时序有一些不好（主要是：第一很难保证时序能满足、容易不稳定；第二代码很难写）。解决方案是：在SoC内部集成一个Nand控制器（实质就是一块硬件电路，这个硬件电路完全满足Nand接口时序的操作，然后将接口时序的操作寄存器化）。

(2)SOC和Nand芯片之间通信，在SoC没有Nand控制器时需要SoC自己来处理接口时序，编程很麻烦，需要程序员看Nand芯片的接口时序图，严格按照接口时序图中编程（尤其要注意各个时间参数）；在SoC有Nand控制器时SoC只需要编程操控Nand控制器的寄存器即可，Nand控制器内部硬件会根据寄存器值来生成合适的Nand接口时序和Nand芯片通信。所以在有Nand控制器时编程要简单很多，我们读写Nand芯片时再也不用关注Nand接口时序了，**只要关注SoC的Nand控制器的寄存器即可**。

(3)扩展来讲，**现在的技术趋势就是**：几乎所有的外设在SoC内部都有对应的控制器来与其通信，那么SoC内部集成的各种控制器（也就是各种内部外设）越多，则SoC硬件能完成的功能越多，将来用这个SoC来完成相应任务时软件编程越简单。譬如说图形处理和图像处理领域，2D图像编码（jpeg编码）、视频编码（h.264编码），现在大部分的application级别的SoC都有集成的内部编码器（像S5PV210就有、更复杂的譬如4418、6818就更不用说了，只会更多更先进），我们可以利用这些硬件编码器来进行快速编解码，这样软件工作量和难度降低了很多（这就是所谓的硬件加速）。

 

### 1.11.4.2、结构框图分析

(1)结构框图中关键点：SFR（我们后续编程的关键，编程时就是通过读写SFR来产生Nand接口时序以读写Nand芯片的） + Nand interface（硬件接口，将来和Nand芯片的相应引脚进行连接） + ECC生成器。

 

Control&State Machine 是用来控制Nand的时序的，这样是硬件控制，减少了软件的复杂程度，写软件是不用考虑Nand 的复杂时序。

ECC Gen ECC发生器，用来管理ECC的。

### 1.11.4.3、S5PV210的Nand控制器的主要寄存器

NFCONF、NFCONT、NFCMMD、NFADDR、NFDATA、NFMECCD0&NFMECCD1、NFSECCD、NFSTAT

 

 

## 1.11.5.Nand操作代码解析

### 1.11.5.0、子函数

static void nand_reset(void);

static void nand_wait_idle(void);

static void nand_select_chip(void);

static void nand_deselect_chip(void);

static void nand_send_cmd(unsigned long cmd);

static void nand_send_addr(unsigned long addr);

static unsigned char nand_read8(void);

static void nand_write8(unsigned char data);

static unsigned int nand_read32(void);

static void nand_write32(unsigned int data);

 

typedef struct nand_id_info

{

  //marker code

  unsigned char IDm; 

  //device code

  unsigned char IDd; 

  unsigned char ID3rd;

  unsigned char ID4th;

  unsigned char ID5th;

}nand_id_info;

 

// 复位 

void nand_reset(void)

{

  nand_select_chip();

  nand_send_cmd(NAND_CMD_RESET);

  nand_wait_idle();

  nand_deselect_chip();

}

 

// 等待就绪 

void nand_wait_idle(void)

{

  unsigned long i;

  while( !(rNFSTAT & (1<<4)) )

​    for(i=0; i<10; i++);

}

 

// 发片选 

void nand_select_chip(void)

{

  unsigned long i;

  rNFCONT &= ~(1<<1);

  for(i=0; i<10; i++);

}

 

// 取消片选 

void nand_deselect_chip(void)

{

  unsigned long i = 0;

  rNFCONT |= (1<<1);

  for(i=0; i<10; i++);

}

 

// 发命令 

void nand_send_cmd(unsigned long cmd)

{

  unsigned long i = 0;

 

  rNFCMMD = cmd;

  for(i=0; i<10; i++);

}

 

// 发地址 

void nand_send_addr(unsigned long addr)

{

  unsigned long i;

  unsigned long col, row;

 

  // 列地址，即页内地址 

  col = addr % NAND_PAGE_SIZE;    

  // 行地址，即页地址       

  row = addr / NAND_PAGE_SIZE;

 

  // Column Address A0~A7 

  rNFADDR = col & 0xff;      

  for(i=0; i<10; i++);    

 

  // Column Address A8~A11 

  rNFADDR = (col >> 8) & 0x0f;    

  for(i=0; i<10; i++);

 

  // Row Address A12~A19 

  rNFADDR = row & 0xff;      

  for(i=0; i<10; i++);

 

  // Row Address A20~A27 

  rNFADDR = (row >> 8) & 0xff;

  for(i=0; i<10; i++);

 

  // Row Address A28~A30 

  rNFADDR = (row >> 16) & 0xff;

  for(i=0; i<10; i++);

}

 

unsigned int nand_read32(void)

{

  return rNFDATA;

}

 

void nand_write32(unsigned int data)

{

  rNFDATA = data;

}

 

// 读一个字节的数据 

unsigned char nand_read8(void)

{

  return rNFDATA8;

}

 

// 写一个字节的数据 

void nand_write8(unsigned char data)

{

  rNFDATA8 = data;

}

 

 

### 1.11.5.1、擦除函数

int nand_erase(unsigned long block_addr)

{

  int i = 0;

  if((nand_read_status() & 0x80) == 0) 

  {

​    printf("Write protected.\n");

​    return -1;

  }

  

  unsigned long row = block_addr >> 18;

  // 1. 发出片选信号 

  nand_select_chip();

  // 2. 擦除：第一个周期发命令0x60，第二个周期发块地址，第三个周期发命令0xd0 

  nand_send_cmd(NAND_CMD_BLOCK_ERASE_1st);

  for(i=0; i<10; i++);

  

  // Row Address A12~A19 

  rNFADDR = row & 0xff;              

  for(i=0; i<10; i++);

  // Row Address A20~A27 

  rNFADDR = (row >> 8) & 0xff;

  for(i=0; i<10; i++);

  // Row Address A28~A30 

  rNFADDR = (row >> 16) & 0x01;  // 只要最低1bit为 A28

  for(i=0; i<10; i++);

  

  rNFSTAT |= (1<<4);     // clear RnB bit 

  

  nand_send_cmd(NAND_CMD_BLOCK_ERASE_2st);

  for(i=0; i<10; i++);

  // 3. 等待就绪 

  nand_wait_idle();

 

  // 4. 读状态 

  unsigned char status = nand_read_status();

  if (status & 1)

  {

​    // statas[0] = 1，表示擦除失败，详见NAND Flash数据手册中 READ STATUS一节的描述

​    // 取消片选信号 

​    nand_deselect_chip();            

​    printf("masking bad block %d\r\n", block_addr);

​    return -1;

  }

  else

  {

​    // status[0] = 0，表示擦除成功，返回0

​    nand_deselect_chip();

​    return 0;

  }

}

 

 

1.11.5.2、页读取函数

int nand_page_read(unsigned int pgaddr, unsigned char *buf, unsigned int length)

{

  int i = 0;

  

  // 1 发出片选信号 

  nand_select_chip();

 

  // 2 写页读命令1st 

  nand_send_cmd(NAND_CMD_READ_1st);

  

  // 3 写入页地址

  rNFADDR = 0;                    

  rNFADDR = 0;

  rNFADDR = pgaddr&0xff;

  rNFADDR = (pgaddr>>8)&0xff;

  rNFADDR = (pgaddr>>16)&0xff;

  

  // 4 clear RnB

  rNFSTAT |= (1<<4);

  

  // 5 写页读命令2st 

  nand_send_cmd(NAND_CMD_READ_2st);

  

  // 6 等待空闲

  nand_wait_idle();

  

  // 7 连续读取2KB的Page main区数据 （继续读取可读出64B的spare area数据）

  for (i=0; (i<NAND_PAGE_SIZE) && (length!=0); i++,length--)

​    *buf++ = nand_read8();

  

  // 8 读状态 

  unsigned char status = nand_read_status();

  if (status & 1 )

  {

​    // 读出错，取消片选信号，返回错误码-1 

​    nand_deselect_chip();

​    printf("nand random read fail\r\n");

​    return -1;

  }

  else

  {

​    // 读正确，取消片选，返回0

​    nand_deselect_chip();

​    return 0;

  }

}

 

 

 

### 1.11.5.3、页写入函数

int nand_page_write(unsigned int pgaddr, const unsigned char *buf, unsigned int length)

{

  int i = 0;

  

  // 1 发出片选信号 

  nand_select_chip();

 

  // 2 write cmd 1st 

  nand_send_cmd(NAND_CMD_WRITE_PAGE_1st);

  

  // 3 write page addr

  rNFADDR = 0;

  rNFADDR = 0;

  rNFADDR = pgaddr&0xff;

  rNFADDR = (pgaddr>>8)&0xff;

  rNFADDR = (pgaddr>>16)&0xff;

 

  // 4 写入一页内容

  for(; i<NAND_PAGE_SIZE && length!=0; i++,length--)

​    nand_write8(*buf++);

  

  // 5 clear RnB

  rNFSTAT = (rNFSTAT)|(1<<4);

  

  // 6 write cmd 2

  nand_send_cmd(NAND_CMD_WRITE_PAGE_2st);

  

  // 7 wait idle

  nand_wait_idle();

  

  // 8 读状态 

  unsigned char status = nand_read_status();

  if (status & 1 )

  {

​    // 取消片选信号 

​    nand_deselect_chip();

​    printf("nand random write fail\r\n");

​    return -1;

  }

  else

  {

​    nand_deselect_chip();

​    return 0;

  }

 

 

总结：

(1)像NandFlash这类芯片，通过专用的接口时序和SoC内部的控制器相连（这种连接方式是非常普遍的，像LCD、DDR等都是类似的连接）。这种接法和设计对我们编程来说，关键在于两点：SoC的控制器的寄存器理解和Nand芯片本身的文档、流程图等信息。

(2)对于我们来说，学习NandFlash，要注意的是：

第一，要结合SoC的数据手册、Nand芯片的数据手册、示例代码三者来理解。

第二，初学时不要尝试完全不参考自己写出Nand操作的代码，初学时应该是先理解实例代码，知道这些代码是怎么写出来的，必要时对照文档来理解代码。代码理解之后去做实践，实践成功后以后再考虑自己不参考代码只参考文档来写出nand操作的代码。

 

 

## 1.11.6.iNand介绍

### 1.11.6.1、iNand/eMMC/SDCard/MMCCard的关联

(1)最早出现的是MMC卡，卡片式结构，按照MMC协议设计。（相较于NandFlash芯片来说，

MMC卡有2个优势：

第一是卡片化，便于拆装；

第二是统一了协议接口，兼容性好。

(2)后来出现SD卡，兼容MMC协议。SD卡较MMC有一些改进，譬如写保护、速率、容量等。

(3)SD卡遵守SD协议，有多个版本。多个版本之间向前兼容。

(4)iNand/eMMC在SD卡的基础上发展起来，较SD卡的区别就是将SD卡芯片化了（解决卡的接触不良问题，便于设备迷你化）。

(5)iNand和eMMC的关联：**eMMC是协议，iNand是Sandisk公司符合eMMC协议的一种芯片系列名称。他是eMMC的一种。**

 

### 1.11.6.2、iNand/eMMC的结构框图及其与NandFlash的区别

(1)iNand内部也是由存储系统和接口电路构成（和Nand结构特性类似，不同之处在于接口电路功能不同）。

(2)iNand的接口电路挺复杂，功能很健全。譬如：

第一，提供eMMC接口协议，和SoC的eMMC接口控制器通信对接。

第二，提供块的ECC校验相关的逻辑，也就是说iNand本身自己完成存储系统的ECC功能，SoC使用iNand时自己不用写代码来进行ECC相关操作，大大简化了SoC的编程难度。（NandFlash分2种：SLC和MLC，SLC更稳定，但是容量小价格高；MLC容易出错，但是容量大价格低）。

第三，iNand芯片内部使用MLC Nand颗粒，所以性价比很高。

第四，iNand接口电路还提供了cache机制，所以inand的操作速度很快。

 

### 1.11.6.3、iNand/eMMC的物理接口和SD卡物理接口的对比

(1)S5PV210芯片本身支持4通道的SD/MMC，在X210中实际是在SD/MMC0通道接了iNand芯片，而SD/MMC2接了SD卡（SD/MMC3也接了SD卡）。

(2)对比inand和SD卡接线，发现：这两个接线几乎是一样的，唯一的区别就是SD卡IO线有4根，而iNand的IO线有8根。

(3)这个告诉我们，我们在实际操作iNand芯片时和操作SD卡时几乎是一样的（物理接线几乎一样，软件操作协议几乎一样）。

 

### 1.11.6.4、结论：

iNand/eMMC其实就是芯片化的SD/MMC卡，软件操作和SD卡相同。

分析iNand芯片的操作代码时，其实就是以前的SD卡的操作代码。一些细节的区别就是为了区分各种不同版本的SD卡、iNand的细节差异。

 

## 1.11.7.SD卡/iNand操作

### 1.11.7.1、硬件接口：DATA、CLK、CMD

(1)iNand的IO线有8根，支持1、4、8线并行传输模式；SD卡IO线有4根，支持1、4线并行传输模式。

(2)CMD线用来传输命令、CLK线用来传输时钟信号。

(3)接口有CLK线，工作时主机SoC通过CLK线传输时钟信号给SD卡/iNand芯片，说明：SD/iNand是同步的，SD/iNand的工作速率是由主机给它的CLK频率决定的。

 

### 1.11.7.2、命令响应的操作模式

(1)SD协议事先定义了很多标准命令（CMD0、CMD1·····），每个命令都有它的作用和使用条件和对应的响应。**SD卡工作的时候就是一个一个的命令周期组合起来的，在一个命令周期中，主机先发送CMD给SD卡，然后SD卡解析这个命令并且执行这个命令，然后SD卡根据结果回发给主机SoC一个响**应。（有些命令是不需要响应的，这时SD卡不会给主机回发响应，主机也不用等待响应）。标准的命令+响应的周期中，主机发完一个命令后应该等待SD卡的响应而不是接着发下一条命令。

 

 

### 1.11.7.3、SD/iNand的体系结构图

(1)SD卡内部有一个接口控制器，这个控制器类似于一个单片机，这个单片机的程序功能就是通过CMD线接收外部主机SoC发给SD卡的命令码，然后执行这个命令并且回发响应给主机SoC。这个单片机处理命令及回发响应遵循的就是SD协议。这个单片机同时可以控制SD卡内部的存储单元，可以读写存储单元。

 

 

### 1.11.7.4、SD/iNand的寄存器（重点是RCA寄存器）

(1)注意这里说的是SD卡内部的寄存器，而不是主机SoC的SD控制器的寄存器。（很多外置芯片内部都是有寄存器的，这些寄存器可以按照一定的规则访问，访问这些寄存器可以得知芯片的一些信息）。

(2)**RCA**（relative address，相对地址寄存器）。我们在访问SD卡时，实际上SD卡内部每个存储单元的地址没有绝对数字，都是使用相对地址。相对地址由SD卡自己决定的，存放在RCA寄存器中。

 

### 1.11.7.5、SoC的SD/MMC/iNand控制器简介

(1)不同的SoC可能在SD/MMC/iNand等支持方面有差异，但是如果支持都是通过内部提供SD控制器来支持的。

(2)S5PV210的SD卡控制器在Section8.7部分

 

 

## 1.11.8.SD/iNand代码实战分析1

### 1.11.8.1、命令码CMD和ACMD

(1)SD卡工作在命令+响应的模式下。

(2)SD协议的命令分2种：CMDx和ACMDx。CMD是单命令命令，就是单独发一个CMD即可表示一个意思。ACMD是一种扩展，就是发2个CMD加起来表示一个意思。可以认为ACMDx = CMDy+CMDz（y一般是55）

 

### 1.11.8.2、卡类型识别SD or MMC？

(1)MMC协议、SD协议、eMMC协议本身是一脉相承的，所以造成了一定的兼容性，所以当我们SoC控制器工作时连接到SoC上的可能是一个MMC卡、也可能是SD卡、也可能是iNand芯片。主机SoC需要去识别这个卡到底是什么版本的卡。

(2)SoC如何区分卡种类？因为不同版本的卡内部协议不同的，所以对卡识别命令的响应也是不同的。SoC通过发送一些命令、听取响应就可以根据不同的响应判定卡的版本。

 

### 1.11.8.3、卡状态

(1)SD卡内部的接口控制器类似于一个单片机，这个单片机其实是一个状态机。所以SD卡任何时候都属于某一种状态（空闲状态、准备好状态、读写状态、出错状态····都是事先定义好的），在这种状态下能够接受的命令是一定的，接受到命令之后执行一定的操作然后根据操作结果会跳转为其他状态。如果主机发过来的命令和当前状态不符状态机就不响应，如果收到命令和当前状态相符就会执行相应操作，执行完之后根据结果跳转为其他状态。

 

### 1.11.8.4、卡回复类型

(1)一般来说，SD卡的命令都属于：命令+响应的模式。也有极少数的SD卡命令是不需要回复的。

(2)卡回复有R1、R7、R1B等8种类型，每种卡回复类型都有自己的解析规则。然后卡在特定状态下响应特定命令时有可能回复哪种响应都是SD协议事先规定好的，详细细节要查阅协议文档。

 

## 1.11.9.SD/iNand代码实战分析2

### 1.11.9.1、linux内核风格的寄存器定义

(1)定义一个基地址，然后定义要访问的寄存器和基地址之间的偏移量，在最终访问寄存器时地址就等于基地址+偏移量。

(2)给大家提供的代码中宏定义是不完整的，很多宏定义只能从字面意思来理解对应，无法通过语法完全获得。这样写代码的好处是可以见名知意，就算代码不全都能读。

\#define HSMMC_NUM    2

\#if (HSMMC_NUM == 0)

\#define HSMMC_BASE (0xEB000000)

\#elif (HSMMC_NUM == 1)

\#define HSMMC_BASE (0xEB100000)

\#elif (HSMMC_NUM == 2)

\#define HSMMC_BASE (0xEB200000)

\#elif (HSMMC_NUM == 3)

\#define HSMMC_BASE (0xEB300000)

\#else

\#error "Configure HSMMC: HSMMC0 ~ HSMM3(0 ~ 3)"

\#endif

 

### 1.11.9.2、SD/iNand相关的GPIO初始化

 

int Hsmmc_Init(void)

{

  int32_t Timeout;

  uint32_t Capacity;

  uint32_t i;

  uint32_t OCR;

  uint32_t Temp;

  uint8_t SwitchStatus[64];

  SD_SCR SCR;

  uint8_t CSD[16];

  uint32_t c_size, c_size_multi, read_bl_len; 

 

  // 设置HSMMC的接口引脚配置

\#if (HSMMC_NUM == 0)

  // channel 0,GPG0[0:6] = CLK, CMD, CDn, DAT[0:3]

  GPG0CON_REG = 0x2222222;

  // pull up enable

  GPG0PUD_REG = 0x2aaa;

  GPG0DRV_REG = 0x3fff;

  // channel 0 clock src = SCLKEPLL = 96M

  CLK_SRC4_REG = (CLK_SRC4_REG & (~(0xf<<0))) | (0x7<<0);

  // channel 0 clock = SCLKEPLL/2 = 48M

  CLK_DIV4_REG = (CLK_DIV4_REG & (~(0xf<<0))) | (0x1<<0); 

  

\#elif (HSMMC_NUM == 1)

  // channel 1,GPG1[0:6] = CLK, CMD, CDn, DAT[0:3]

  GPG1CON_REG = 0x2222222;

  // pull up enable

  GPG1PUD_REG = 0x2aaa;

  GPG1DRV_REG = 0x3fff;

  // channel 1 clock src = SCLKEPLL = 96M

  CLK_SRC4_REG = (CLK_SRC4_REG & (~(0xf<<4))) | (0x7<<4);

  // channel 1 clock = SCLKEPLL/2 = 48M

  CLK_DIV4_REG = (CLK_DIV4_REG & (~(0xf<<4))) | (0x1<<4);

  

\#elif (HSMMC_NUM == 2)

  // channel 2,GPG2[0:6] = CLK, CMD, CDn, DAT[0:3]

  GPG2CON_REG = 0x2222222;

  // pull up enable

  GPG2PUD_REG = 0x2aaa;

  GPG2DRV_REG = 0x3fff;

  // channel 2 clock src = SCLKEPLL = 96M

  CLK_SRC4_REG = (CLK_SRC4_REG & (~(0xf<<8))) | (0x7<<8);

  // channel 2 clock = SCLKEPLL/2 = 48M

  CLK_DIV4_REG = (CLK_DIV4_REG & (~(0xf<<8))) | (0x1<<8); 

  

\#elif (HSMMC_NUM == 3)

  // channel 3,GPG3[0:6] = CLK, CMD, CDn, DAT[0:3]

  GPG3CON_REG = 0x2222222;

  // pull up enable

  GPG3PUD_REG = 0x2aaa;

  GPG3DRV_REG = 0x3fff;

  // channel 3 clock src = SCLKEPLL = 96M

  CLK_SRC4_REG = (CLK_SRC4_REG & (~(0xf<<12))) | (0x7<<12);

  // channel 3 clock = SCLKEPLL/2 = 48M

  CLK_DIV4_REG = (CLK_DIV4_REG & (~(0xf<<12))) | (0x1<<12);  

  

\#endif

  // software reset for all 复位主机SoC控制器，而不是复位SD卡

  __REGb(HSMMC_BASE+SWRST_OFFSET) = 0x1;

  Timeout = 1000; // Wait max 10 ms

  while (__REGb(HSMMC_BASE+SWRST_OFFSET) & (1<<0)) {

​    if (Timeout == 0) {

​      return -1; // reset timeout

​    }

​    Timeout--;

​    Delay_us(10);

 

(1)GPG0相关的GPIO初始化，参考LED部分的设置技术

(2)时钟设置参考裸机第六部分时钟那一章，设置时使用到了位操作技巧，参考C高级第二部分

(3)要求能够在两三分钟之内完全看懂这些代码涉及到的知识，要能够在数据手册、原理图中找到相对应的点，要能够瞬间明白代码中涉及到的C语言语法技巧，这样才叫融会贯通，才能够从代码中学到东西。

### 1.11.9.3、SD/iNand相关的时钟系统设置

 

 

 

### 1.11.9.4、SD/iNand的时钟设置

Hsmmc_SetClock(400000); // 400k 

 

static void Hsmmc_ClockOn(uint8_t On)

{

  uint32_t Timeout;

  if (On) {

​    __REGw(HSMMC_BASE+CLKCON_OFFSET) |= (1<<2); // sd时钟使能

​    Timeout = 1000; // Wait max 10 ms

​    while (!(__REGw(HSMMC_BASE+CLKCON_OFFSET) & (1<<3))) {

​      // 等待SD输出时钟稳定

​      if (Timeout == 0) {

​        return;

​      }

​      Timeout--;

​      Delay_us(10);

​    }

  } else {

​    __REGw(HSMMC_BASE+CLKCON_OFFSET) &= ~(1<<2); // sd时钟禁止

  }

}

 

static void Hsmmc_SetClock(uint32_t Clock)

{

  uint32_t Temp;

  uint32_t Timeout;

  uint32_t i;

  Hsmmc_ClockOn(0); // 关闭时钟  

  Temp = __REG(HSMMC_BASE+CONTROL2_OFFSET);

  // Set SCLK_MMC(48M) from SYSCON as a clock source 

  Temp = (Temp & (~(3<<4))) | (2<<4);

  Temp |= (1u<<31) | (1u<<30) | (1<<8);

  if (Clock <= 500000) {

​    Temp &= ~((1<<14) | (1<<15));

​    __REG(HSMMC_BASE+CONTROL3_OFFSET) = 0;

  } else {

​    Temp |= ((1<<14) | (1<<15));

​    __REG(HSMMC_BASE+CONTROL3_OFFSET) = (1u<<31) | (1<<23);

  }

  __REG(HSMMC_BASE+CONTROL2_OFFSET) = Temp;

  

  for (i=0; i<=8; i++) {

​    if (Clock >= (48000000/(1<<i))) {

​      break;

​    }

  }

  Temp = ((1<<i) / 2) << 8; // clock div

  Temp |= (1<<0); // Internal Clock Enable

  __REGw(HSMMC_BASE+CLKCON_OFFSET) = Temp;

  Timeout = 1000; // Wait max 10 ms

  while (!(__REGw(HSMMC_BASE+CLKCON_OFFSET) & (1<<1))) {

​    // 等待内部时钟振荡稳定

​    if (Timeout == 0) {

​      return;

​    }

​    Timeout--;

​    Delay_us(10);

  }

  

  Hsmmc_ClockOn(1); // 使能时钟

}

 

(1)SD卡本身工作需要时钟，但是自己又没有时钟发生单元，依靠主机SoC的控制器通过SD接口中的CLK线传一个时钟过来给SD卡内部使用。所以主机SD卡控制器先初始化好自己的时钟，然后将自己的时钟传给SD卡。

(2)因为此时刚开始和SD卡通信，主机不清楚SD卡属于哪个版本（高版本和低版本的SD卡的读写速率不同，高版本的可以工作在低版本的速率下，低版本的SD卡不能工作在高版本速率下），所以先给SD卡发400KHz的低速率时钟，SD卡拿到这个时钟后就能工作了。然后在后面和SD卡进行进一步通信时去识别SD卡的版本号，识别后再根据SD卡的版本进一步给它更合适的时钟。

## 1.11.10.SD/iNand代码实战分析3

### 1.11.10.1、命令发送函数解析

要完全搞懂这个代码，深入理解，查210的数据手册和SD的协议。

 

### 1.11.10.2、卡类型识别操作时序及代码分析

### 1.11.10.3、卡读写时序及代码分析

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

# 第十二章 I2C通信详解

## 1.12.0 章节概要

**1.12.1.什么是I2C通信**

​    本节简单介绍I2C接口的物理特征、通信特征（串行、同步、非差分、低速率）、主从设备、总线式通信等概念，希望大家对I2C总线通信有个框架性的了解。

**1.12.2.由I2C学通信时序**

​    本节主要讲解I2C总线的通信时序，希望借用I2C通信的时序分析让大家明白通信接口究竟是如何工作的。尽管现代SoC都是通过专用控制器来产生时序信号并不需自己编码，但是理解这些时序仍然对编程有很积极的作用。

**1.12.3.S5PV210的I2C控制器**

​    本节介绍S5PV210的I2C控制器，主要讲了它的结构框图、时钟来源与分频、主要寄存器及其作用分析等。

**1.12.4.X210板载gsensor介绍**

​    本节带领大家学习X210开发板上自带的gsensor芯片，主要是通过分析原理图、数据手册让大家对gsensor芯片的I2C接口、读写流程图等有个了解，以不影响I2C总线通信的学习。gsensor芯片本身的原理、寄存器列表、编程方法等并不是我们本课的重点。

**1.12.5.I2C总线的通信流程**

​    本节结合S5PV210的数据手册，来讲解I2C总线的工作流程。主要讲解主发送、主接收这两种流程，同时结合gsensor数据手册中的操作流程来两方印证。实际的编程就是按照这些流程在写。

**1.12.6.I2C通信代码分析1**

​    本节带大家分析I2C通信物理层的代码，源码来自于linux内核中。主要看了其中几个I2C发送接收的函数，通过函数的寄存器操作和上节讲的数据手册中的流程图相印证，让大家理解代码是怎么写出来的。

**1.12.7.I2C通信代码分析2**

​    本节分析gsensor驱动，及其与I2C物理层驱动的关联。通过这种层次结合和调用，让大家对驱动的分层有所理解。

## 1.12.1.什么是I2C通信

### 1.12.1.1、物理接口：SCL + SDA

(1)**SCL(serial clock)****：时钟线**，传输CLK信号，一般是I2C主设备向从设备提供时钟的通道。

(2)**SDA(serial data):** **数据线，**通信数据都通过SDA线传输。

 

### 1.12.1.2、通信特征：串行、同步、非差分、低速率

(1)**I2C****属于串行通信**：所有的数据以**位**为单位在SDA线上串行传输。

(2)**同步通信：同步通信双方工作在同一个时钟下**，一般是通信的A方通过一根CLK信号线传输A自己的时钟给B，B工作在A传输的时钟下。所以同步通信的显著特征就是：通信线中有CLK

(3)**非差分**：因为I2C通信速率不高，而且通信双方距离很近，所以使用电平信号通信。

​        高速用差分信号，低速用非差分。

(4)**低速率**：I2C一般是用在同一个板子上的2个**IC**之间的通信，而且用来传输的数据量不大，所以本身通信速率很低（一般几百KHz，不同的I2C芯片的通信速率可能不同，具体在编程的时候要看自己所使用的设备允许的I2C通信最高速率，不能超过这个速率）

 

### 1.12.1.3、突出特征1：主设备+从设备

(1)I2C通信的时候，通信双方地位是不对等的，而是分主设备和从设备。通信由主设备发起，由主设备主导，从设备只是按照I2C协议被动的接受主设备的通信，并及时响应。

(2)谁是主设备、谁是从设备是由通信双方来定的（I2C协议并无规定），一般来说一个芯片可以只能做主设备、也**可以只能做从设备、也可以既能当主设备又能当从设备**（软件配置）。

 

### 1.12.1.3、突出特征2：可以多个设备挂在一条总线上（从设备地址）

(1)I2C通信可以一对一（1个主设备对1个从设备），也可以一对多（1个主设备对多个从设备）。

(2)**主设备来负责调度总线**：决定某一时间和哪个从设备通信。注意：同一时间内，I2C的总线上只能传输一对设备的通信信息，所以**同一时间只能有一个从设备和主设备通信**，其他从设备处于“冬眠”状态，不能出来捣乱，否则通信就乱套了。

(3)**主设备怎么甄别要找的从设备**：每一个I2C从设备在通信中都有一个I2C从设备地址，这个设备地址是从设备本身固有的属性，然后通信时主设备需要知道自己将要通信的那个从设备的地址，然后在通信中通过地址来甄别是不是自己要找的那个从设备。（这个地址是一个电路板上唯一的，不是全球唯一的）。

 

### 1.12.1.3、主要用途：

SoC和周边外设之间的通信（典型的如EEPROM、电容触摸IC、各种sensor等）

## 1.12.2.由I2C学通信时序

### 1.12.2.1、什么是时序？

(1)时序：字面意思，时序就是时间顺序，实际上在通信中时序就是通信线上按照时间顺序发生的电平变化，以及这些变化对通信的意义就叫时序。

 

### 1.12.2.2、I2C的总线空闲状态、起始位、结束位

 

 

(1)I2C总线上有1个主设备，n（n>=1）个从设备。

I2C总线上有**2****种状态**：

**空闲态**（所有从设备都未和主设备通信，此时总线空闲）

**忙态** （其中一个从设备在和主设备通信，此时总线被这一对占用，其他从设备必须歇着）。

   (2)整个通信分为一个周期一个周期的，两个相邻的通信周期是空闲态。每一个通信周期由一个起始位开始，一个结束位结束，中间是本周期的通信数据。

(3)起始位并不是一个时间点，起始位是一个时间段，在这段时间内总线状态变化情况是：**SCL****线维持高电平，同时SDA线发生一个从高到低的下降沿。**

 

(4)与起始位相似，结束位也是一个时间段。在这段时间内总线状态变化情况是：**SCL****线维持高电平，同时SDA线发生一个从低到高的上升沿。**

 

（5）、数据传输：当CLK t1发生上升沿去读，DATA电平，低电平代表这个bit位为0否则为1。

 

 

Acknowledge:响应，回复。

### 1.12.2.3、I2C数据传输格式（数据位&ACK）

 

(1)每一个通信周期的发起和结束都是由主设备来做的，从设备只有被动的响应主设备，没法自己自发的去做任何事情。

(2)主设备在每个通信周期会先发8位的从设备地址（其实8位中只有7位是从设备地址，还有1位表示主设备下面要写入还是读出）到总线（主设备**是以广播的形式发送的**，只要是总线上的所有从设备其实都能收到这个信息）。然后总线上的每个从设备都能收到这个地址，并且收到地址后和自己的设备地址比较看是否相等。如果相等说明主设备本次通信就是给我说话，如果不想等说明这次通信与我无关，不用听了不管了。

(3)**发送方**发送一段数据后，**接收方**需要回应一个ACK（acknowledge）。这个响应本身只有1个bit位，不能携带有效信息，只能表示2个意思（**要么表示收到数据，即有效响应；要么表示未收到数据，无效响应**）。

(4)在某一个通信时刻，主设备和从设备只能有一个在发（占用总线，也就是向总线写），另一个在收（从总线读）。如果在某个时间主设备和从设备都试图向总线写那就完蛋了，通信就乱套了。

 

### 1.12.2.4、数据在总线上的传输协议

 

(1)I2C通信时的基本数据单位也是以字节为单位的，每次传输的有效数据都是1个字节（8位）。

(2)起始位及其后的8个clk中都是主设备在发送（这设备掌控总线），此时从设备只能读取总线，通过读总线来得知主设备发给从设备的信息；然后到了第9周期，按照协议规定从设备需要发送ACK给主设备，所以此时主设备必须释放总线（主设备把总线置为高电平然后不要动，其实就类似于总线空闲状态），同时从设备试图拉低总线发出ACK。如果从设备拉低总线失败，或者从设备根本就没有拉低总线，则主设备看到的现象就是总线在第9周期仍然一直保持高，这对主设备来说，**意味着我没收到ACK**，主设备就认为刚才给从设备发送的8字节不对（接收失败）。

 

## 1.12.3.S5PV210的I2C控制器

通信双方本质上是通过时序在工作，但是时序会比较复杂不利于SoC软件完成，于是乎解决方案是SoC内部内置了硬件的控制器来产生通信时序。这样我们写软件时只需要向控制器的寄存器中写入配置值即可，控制器会产生适当的时序在通信线上和对方通信。

### 1.12.3.1、结构框图

 

(1)时钟部分，时钟来源是PCLK_PSYS，经过内部分频最终得到I2C控制器的CLK，通信中这个CLK会通过SCL线传给从设备。

(2)I2C总线控制逻辑（前台代表是I2CCON、I2CSTAT这两个寄存器），主要负责产生I2C通信时序。实际编程中要发送起始位、停止位、接收ACK等都是通过这两个寄存器（背后所代表的电路模块）实现的。

(3)移位寄存器（shift register），将代码中要发送的字节数据，通过移位寄存器变成1个位一个位的丢给SDA线上去发送/接收。学过数字电路的同学应该对移位寄存器不陌生。

(4)地址寄存器+比较器。本I2C控制器做从设备的时候用。(我没用过，理论分析)

 

### 1.12.3.2、系统分析I2C的时钟

(1)I2C时钟源头来源于PCLK（PCLK_PSYS，等于65MHz），经过了2级分频后得到的。

(2)第一级分频是I2CCON的bit6，可以得到一个中间时钟I2CCLK（等于PCLK/16或者PCLK/512）

(3)第二级分频是得到最终I2C控制器工作的时钟，以I2CCLK这个中间时钟为来源，分频系数为[1,16]

(4)最终要得到时钟是2级分频后的时钟，譬如一个可用的设置是：65000KHz/512/4=31KHz

 

### 1.12.3.3、主要寄存器I2CCON、I2CSTAT、I2CADD、I2CDS

I2CCON + I2CSTAT：主要用来产生通信时序和I2C接口配置。

I2CADD：用来写自己的slave address

I2CDS：发送/接收的数据都放在这里

 

## 1.12.4.X210板载gsensor介绍

### 1.12.4.1、原理图查阅

 

(1)gsensor的供电由PWMTOUT3引脚控制。当PWMTOUT3输出低电平时gsensor无电不工作；当输出高电平时gsensor才会工作。

(2)gsensor的SDA和SCL接的是S5PV210的I2C端口0。

(3)将来编程时在gsensor_init函数中要去初始化相关的GPIO。要把相应的GPIO设置为正确的模式和输入输出值。

 

### 1.12.4.2、重力加速度传感器简介

(1)用在手机、平板、智能手表等设备上，用来感受人的手的移动，获取一些运动的方向性信息用来给系统作为输入参量。

(2)可以用来设计智能手表的计步器功能。

(3)重力加速度传感器、地磁传感器、陀螺仪等三个传感器结合起来，都是用来感谢运动的速度、方位等信息的，所以现在最新的有9轴传感器，就是把三者结合起来，并且用一定的算法进行综合得出结论，目的是更加准确。

(4)一般传感器的接口有2种：模拟接口和数字接口。

模拟接口：是用接口电平变化来作为输出的（譬如模拟接口的压力传感器，在压力不同时输出电平在0～3.3V范围内变化，每一个电压对应一个压力。），**SOC需要用AD接口来对接这种传感器对它输出的数据进行AD转换**，转换得到数字电压值，再用数字电压值去校准得到压力值；

数字接口：是后来发展出来的，数字接口的sensor是在模拟接口的sensor基础上，内部集成了AD，直接（通过一定的总线接口协议，一般是i2C）输出一个数字值的参数，这样SoC直接通过总线接口初始化、读取传感器输出的参数即可（譬如gsensor、电容触摸屏IC）。

 

### 1.12.4.3、I2C从设备的设备地址

(1)KXTE9的I2C地址固定为0b0001111（0x0f）

(2)I2C从设备地址本身是7位的，但是在I2C通信中发送I2C从设备地址时实际发送的是8位，这8位中高7位（bit7-bit1）对应I2C从设备的7位地址，最低一位（LSB）存放的是R/W信息（就是说下一个数据是主设备写从设备读（对应0），还是主设备读从设备写（对应1））。

(3)基于上面讲的，对于KXTE9来说，主设备（SoC）发给gsensor信息时，SAD应该是：0b00011110(0x1E)

如果是主设备读取gsensor信息时，SAD应该是：0b00011111（0x1F）。

### 1.12.4.4、I2C从设备的通信速率

(1)I2C协议本身属于低速协议，通信速率不能太高。

(2)实际上通信的主设备和从设备本身都有最高的通信速率限制（属于各个芯片本身的参数），实际编程时怎么确定最终的通信速率？只要小于两个即可（主和从）。

(3)一般来说只能做从设备的sensor芯片本身i2c通信速率偏低，像KXTE9最高支持400KHz的频率。

## 1.12.5、I2C总线的通信流程

### 1.12.5.1、S5PV210的主发送流程图

 

### 1.12.5.2、S5PV210的主接收流程图

 

### 1.12.5.3、gsensor的写寄存器流程图

 

### 1.12.5.4、gsensor的读寄存器流程图

 

SAD+W （star address）为什么这个地址最后一位还是发送W（write）呢，而不是R（read）？

因为主设备需要发送从设备的地址，找到从设备之后才可以去读取数据，这时候才发送SAD+R。

## 1.12.6、I2C通信代码分析1

### 1.12.6.1、I2C控制器初始化：s3c24xx_i2c_init

(1)初始化做的事情：初始化GPIO，设置IRQEN和ACKEN，初始化I2C时钟

### 1.12.6.2、I2C控制器主模式开始一次读写：s3c24xx_i2c_message_start

​    

### 1.12.6.3、I2C控制器主模式结束一次读写：s3c24xx_i2c_stop

 

 

## 1.12.7.I2C通信代码分析2

**框架分析**：我们最终目的是通过读写gsensor芯片的内部寄存器来得到一些信息。为了完成这个目的，我们需要能够读写gsensor的寄存器，根据gsensor的规定我们需要按照一定的操作流程来读写gsensor的内部寄存器，这是一个层次（姑且叫做传输层、协议层、应用层）；

我们要按照操作流程去读写寄存器，就需要考虑I2C接口协议（这就是所谓的**物理层，**本质就是那些时序）。此时主机SoC有或者没有控制器，有控制器时考虑控制器的寄存器，没控制器时要自己软件模拟时序。

协议层的代码主要取决于gsensor芯片；物理层代码主要取决于主机SoC。

 

 

### 1.12.7.1、gsensor写寄存器：gsensor_i2c_write_reg

### 1.12.7.2、gsensor读寄存器：gsensor_i2c_read_reg

### 1.12.7.3、gsensor编程：gsensor_initial等

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

# 第十三章 ADC

## 1.13.0 章节概要

**1.13.1.ADC的引入**

​    本节主要讲解ADC的概念，核心是模拟量、数字量这两个概念。

**1.13.2.ADC的主要相关概念**

​    本节详解ADC中主要的几个参数，如模拟量的量程、数字量的精度位数、AD转换的速率等。

**1.13.3.S5PV210的ADC控制器**

​    本节讲述S5PV210的ADC控制器，主要讲了ADC的时钟来源和设置，ADC控制器的主要寄存器。

**1.13.4.AD转换的编程实践1**

​    本节开始ADC的编程实践，首先从原理图入手，然后落脚在控制器的寄存器设置上，从头开始写代码，带领大家完成ADC转换的编程。

**1.13.5.AD转换的编程实践2**

​    本节进行编程调试，将上节写的代码进行编译运行、调试、改进，使其圆满工作。希望大家能够从调试过程中学到东西。

## 1.13.1.ADC的引入

### 1.13.1.1、什么是ADC

(1)ADC:analog digital converter,AD转换，模数转换（也就是模拟转数字）

(2)CPU本身是数字的，而外部世界变量（如电压、温度、高度、压力···）都是模拟的，所以需要用CPU来处理这些外部的模拟变量的时候就需要做AD转换。

 

### 1.13.1.2、为什么需要ADC

(1)为了用数字技术来处理外部的模拟物理量。

 

### 1.13.1.3、关于模拟量和数字量

(1)**模拟**的就是连续的，现实生活当中的时间、电压、高度等都是模拟的（连续分布的，划分的话可以无限的更小划分）。模拟量反映在数学里面就是无限小数位（从0到1之间有无数个数）.

(2)数字的就是离散的，离线的就是不连续的。这种离散处理实际上是从数学上对现实中的模拟量的一种有限精度的描述。数字化就是离散化，就是把连续分布的模拟量按照一定精度进行取点（采样）变成有限多个不连续分布的数字值，就叫**数字量**。

(3)数字化的意义就在于可以用（离散）数学来简化描述模拟量，这东西是计算机技术的基础。

(4)计算机处理参量的时候都是数字化的，计算机需要数字化的值来参与运算。如果系统输入参数中有模拟量，就需要外加AD转换器将模拟量转成数字量再给计算机。

 

### 1.13.1.4、有AD自然就有DA

(1)AD是analog to digital，DA自然就是digital to analog，数字转模拟。

(2)纯粹用cpu是不可能实现数字转模拟，因为cpu本身就是数字的。使用一些（具有一些积分或微分效果的）物理器件就可实现数字转模拟。

(3)数字转模拟的作用。譬如可以用来做波形发生器。

 

 

## 1.13.2.ADC的主要相关概念

### 1.13.2.1、量程（模拟量输入范围）

(1)AD转换器是一个电子器件，所以他只能输入电压信号。其他种类的模拟信号要先经过传感器（Sensor）的转换变成模拟的电压信号然后才能给AD。

(2)AD输入端的模拟电压要求有一个范围，一般是0～3.3V或0～5V或者是0～12V等等。模拟电压的范围是AD芯片本身的一个参数。实际工作时给AD的电压信号不能超过这个电压范围。

 

### 1.13.2.2、精度（分辨率resolution）

(1)AD转换输出的数字值是有一定的位数的（譬如说10位，意思就是输出的数字值是用10个二进制位来表示的，这种就叫10位AD）。这个位数就表示了转换精度。

(2)10位AD就相当于把整个范围分成了1024个格子，每个格子之间的间隔就是电压的表示精度。加入AD芯片的量程是0～3.3V，则每个格子代表的电压值是3.3V/1024=0.0032265V。如果此时AD转换后得到的数字量是447，则这个数字量代表的模拟值是：447×0.0032265V=1.44V。

(3)AD的位数越多，则每个格子表示的电压值越小，将来算出来的模拟电压值就越精确。

(4)AD的模拟量程一样的情况下，AD精度位数越多精度越高，测出来的值越准。但是如果AD的量程不一样。譬如2个AD，A的量程是0～50V，B的量程是0～0.5V，A是12位的，B是10位的，可能B的精度比A的还要高。（A的精度：50/1024=0.04883，B的精度：0.5/4096=0.000122）.

 

### 1.13.2.3、转换速率（MSPS与conventor clock的不同）

(1)首先要明白：AD芯片进行AD转换是要耗费时间的。这个时间需要多久，不同的芯片是不一样的，同一颗芯片在配置不一样（譬如说精度配置为10位时时间比精度配置为12位时要小，譬如说有些AD可以配转换时钟，时钟频率高则转换时间短）时转换时间也不一样。

(2)详细的需要时间可以参考数据手册。一般数据手册中描述转换速率用的单位是MSPS（第一个M是兆，S是sample，就是采样；PS就是per second，总的意思就是兆样本每秒，每秒种转出来多少M个数字值）

(3)AD工作都需要一个时钟，这个时钟有一个范围，我们实际给他配置时不要超出这个范围就可以了。AD转换是在这个时钟下进行的，时钟的频率控制着AD转换的速率。

注意：时钟频率和MSPS不是一回事，只是成正比不是完全相等。譬如S5PV210中的AD转换器，MSPS = 时钟频率/5。

 

### 1.13.2.4、通道数

(1)AD芯片有多少路analog input通道，代表了将来可以同时进行多少路模拟信号的输入。

## 1.13.3.S5PV210的ADC控制器

### 1.13.3.1、ADC和（电阻式）触摸屏的关系

(1)ADC在210的数据手册的Section10.7

(2)电阻式触摸屏本身工作时依赖于AD转换，所以在210的SoC中电阻触摸屏接口本身和ADC接口是合二为一的。或者说电阻触摸屏接口使用了（复用了）ADC的接口。

 

### 1.13.3.2、ADC的工作时钟框图

 

(1)ADCCLK是ADC控制器工作的时钟，也就是1.13.2.3节中讲到的conventor clock。从时钟框图可以看出，它是PCLK（当然是PCLK_PSYS）经过了一次分频后得到的。所以将来初始化ADC控制器时一定有一个步骤是初始化这里的分频器。（这个图先主要看PCLK这行）。

 

### 1.13.3.3、210的10个ADC通道（注意ADC引脚和GPIO的区别）

(1)210一共支持10个ADC通道，分别叫AIN[0]~AIN[9]。理论上可以同时做10路AD转换。

(2)S**oC****的引脚至少分2种**：digit数字引脚和analog模拟引脚。

我们以前接触的GPIO都属于数字引脚，ADC channel通道引脚属于模拟引脚。数字引脚和模拟引脚一般是不能混用的。

 

### 1.13.3.4、ADC控制器的主要寄存器

TSADCCON0           用来做控制的

TSDATX0 TSDATY0      转出来的AD值存在这里，我们读也是读这里

CLRINTADC0           清中断

ADCMUX               选择当前正在操作的AD通道

(1)**等待触摸屏转换完毕的方法有2种**：一种是检查标志位，第二种是中断。

第一种方式下我们先开启一次转换然后循环不停检查标志位直到标志位为1表明已经转换完可以去读；

第二种方式下就是设置好中断，写好中断isr来读取AD转换数据。然后开启中断后CPU就不用管了，等AD转换完成后会生成一个中断信号给CPU，就会进入中断处理流程。第一种方法是同步的，第二种方式是异步的。

(2)AD转换都是需要反复进行的，那么转完一次一般要立即开启下一次转换，所以需要有一种机制能够在一次转完时自动开启下一次。这个机制就叫start by read，这个机制的工作方法是：**当我们读取本次AD转换的AD值后，硬件自动开启下一次AD转换**。

 

 

## 1.13.4.AD转换的编程实践1

### 1.13.4.1、AD控制器初始化

//初始化控制器的函数

static void adc_init(void)

{

  rTSADCCON0 |= (1<<16);   //resolution set to 12bit

  rTSADCCON0 |= (1<<14);    //A/D converter prescaler enable

 

 //A/D converter prescaler value 

  rTSADCCON0 &= ~(0xff<<6);      // 清零

  rTSADCCON0 |= (65<<6);      // convertor clock = 66/66M = 1MHz;MSPS(clock/5) = 200kHZ   

  rTSADCCON0 &= ~(1<<2);     //Normal operation mode

  rTSADCCON0 &= ~(1<<0);   //A/D conversion starts by enable ,自动转换关闭 

  rADCMUX  &= ~(0xf<<0);   //选择通道0；

 

}

 

### 1.13.4.2、循环进行AD采样

//测试ADC，完成的功能就是循环检测ADC并得到ADC转换数字值打印出来

void adc_test(void)

{  

  int val = 0;

  adc_init();

 

  while(1){

​    //第一步：手工开启ADC转换

​    rTSADCCON0 |= (1<<0); 

​    //第二步：等待ADC转换完毕

​    while(!(rTSADCCON0 & (1<<15)) );

​    //第三步：读取ADC的数字值

​    

​    //第四步：处理/显示数字值

​    val = rTSDATX0;

​    printf("X:bit14 = %d\n",(val & (1 << 14)));

​    printf("X:adc value =%d.\n",(val & (0xfff << 0)));

 

​     val = rTSDATX0;

​    printf("Y:bit14 = %d\n",(val & (1 << 14)));

​    printf("Y:adc value =%d.\n",(val & (0xfff << 0)));

​    //第五步：延时一段

​    delay();

  }

 

}

 

 

## 1.13.5.AD转换的编程实践2

### 1.13.5.1、编译运行调试

### 1.13.5.2、start by read模式介绍

(1)应用方法：开启start by read模式，第一次先读一次丢掉，这次读就能开启下一次AD转换，然后以后就可以不停的读取AD值了。

 

 

 

 

 

 

 



 

# 第十四章 LCD显示器

## 1.14.0 章节概要

**1.14.1.LCD简介**

​    本节简单介绍LCD的显示原理、其他主流显示技术以及LCD的发展史和分类。本节的内容虽然和编程无直接关联，但是对大家了解LCD的背景有极大意义。

**1.14.2.LCD的接口技术**

​    本节主要介绍LCD的硬件接口，分析各种不同接口类型的差异，从而引出LCD的时序信号，为后面章节的正式展开打下基础。

**1.14.3.LCD如何显示图像1**

​    本节讲述LCD显示图像的基本原理：像素的概念、扫描显示方式、LCD驱动器和LCD控制器的分别、显示缓存区的概念等，这些概念有助于我们从编程角度理解LCD如何工作。

**1.14.4.LCD如何显示图像2**

​    本节讲述LCD显示图像的基本原理：像素的概念、扫描显示方式、LCD驱动器和LCD控制器的分别、显示缓存区的概念等，这些概念有助于我们从编程角度理解LCD如何工作。

**1.14.5.LCD的六个主要时序参数1**

​    本节介绍LCD初始化过程中很重要的6个参数，这个六个参数是CRT年代继承而来，但是对于LCD来说却很重要，也是我们后面写程序初始化LCD时很重要的几个参数。

**1.14.6.LCD的六个主要时序参数2**

​    本节介绍LCD初始化过程中很重要的6个参数，这个六个参数是CRT年代继承而来，但是对于LCD来说却很重要，也是我们后面写程序初始化LCD时很重要的几个参数。

**1.14.7.LCD显示的主要相关概念**

​    本节讲解LCD显示中关键的几个概念，如像素、像素深度、清晰度、分辨率等，这些概念在后面的编程实践中用得上，而且对我们理解显示原理至关重要。

**1.14.8.颜色在计算机中的表示**

​    本节主要讲了颜色相关的一些概念，颜色的物理含义、颜色的表达方式、颜色在计算机中如何展示等，这些基本概念对我们学习计算机的显示技术非常重要，对理解LCD显示也至关重要。

**1.14.9.S5PV210的LCD控制器**

​    本节介绍SOC的LCD控制器，主要介绍了FIMD的结构框图、工作原理及主要寄存器，本节的关键点在于理解显存的意义和工作原理。

**1.14.10.LCD编程实战1-LCD控制器初始化**

​    本节进入LCD编程实战，重点分析了LCD控制器初始化代码，整个初始化的目的就是完成LCD显示的第一个步骤：绑定显存和LCD屏幕，在两者之间建立一个映射。

**1.14.11.LCD编程实战2-显示像素&刷背景**

​    本节是LCD编程实战的第二节，主要讲了2个显示函数。第一个是在LCD屏幕上绘制一个像素点的函数，第二个是绘制整个LCD屏幕背景色的函数。

**1.14.12.LCD编程实战3-横线竖线斜线&画圆**

​    本节是LCD编程实战的第三节，主要讲了几个图形绘制函数，包括画横线、竖线、斜线、画圆等。通过这几个函数，希望大家进一步理解LCD中填充像素与绘制图形的对应关系。

**1.14.13.LCD编程实战4-写英文中文字符**

​    本节是LCD编程实战的第四节，主要讲了在LCD上绘制中英文字的函数，通过实际分析ASCII码显示的函数，将文字的显示原理讲的清清楚楚。

**1.14.14.LCD编程实战5-画图**

​    本节是LCD编程实战的第五节，主要讲了在LCD上绘制图像的函数，本节介绍了一个重要工具Image2LCD，讲了如何用该工具获取图像数据，以及在LCD中将之显示出来。

**1.14.15.LCD编程实战6-画图测试及调试**

​    本节是LCD编程实战的最后一节，主要任务是调试上节所写的显示图片的函数，并且研究了RGB的像素顺序以及搞错像素顺序的实验现象，让大家学会调试程序。

**1.14.16.未完成事项展望**

​    本节课对整个ARM裸机第十四部分进行总结，并且展望一些因为时间原因没有列出的LCD相关内容，我们希望以后在实战项目中用到这些内容并且给大家做详细的讲解和训练。

## 1.14.1.LCD简介

### 1.14.1.1、什么是LCD？

(1)LCD(Liquid Crystal Display)俗称液晶.

(2)液晶是一种材料，液晶这种材料具有一种**特点**：可以在电信号的驱动下液晶分子进行旋转，旋转时会影响透光性，因此我们可以在整个液晶面板后面用白光照（称为背光），可以通过不同电信号让液晶分子进行选择性的透光，此时在液晶面板前面看到的就是各种各样不同的颜色，这就是LCD显示。

(3)被动发光和主动发光。有些显示器（譬如LED显示器、CRT显示器）自己本身会发光称为主动发光，有些（LCD）本身不会发光只会透光，需要背光的协助才能看起来是发光的，称为被动发光。

(4)液晶应用领域：电视机、电脑显示屏、手机显示屏、工业显示屏等····

 

### 1.14.1.2、其他主流显示设备（LED、CRT、等离子、OLED）

(1)CRT：阴极摄像管显示器。

(2)等离子显示：未成为主流

(3)OLED：目前未成为主流，但是很有市场潜力

(4)LED：主要用在户外大屏幕

(5)LCD：目前是主流显示器

 

### 1.14.1.3、LCD的显示原理和特点(液晶分子透光+背光)

(1)白光其实是由各种不同颜色的光组成的，所以白光被选择性透光之后可以产生各种不同颜色的光。

 

### 1.14.1.4、LCD的发展史和种类(TN/STN/TFT)

(1)TN最早。坏处是响应性不够好，有拖尾现象。（2002-2003年左右）。

(2)STN是TN的升级版。有效解决拖尾现象，显示更清晰。 

(3)TFT的最大特点就是超薄。

(4)TFT技术之上发展出来很多更新的技术。

参考资料一：http://blog.163.com/tao198352__4232/blog/static/85020645201062285210682

参考资料二：

http://display.ofweek.com/2013-12/ART-8321301-8300-28763136.html)

 

## 1.14.2.LCD的接口技术

### 1.14.2.1、从电平角度来讲本质上都是TTL信号

(1)什么是TTL接口。+5V表示逻辑1，0V表示逻辑0.这种就叫TTL电平，和CMOS电平相对比。

(2)SoC的LCD控制器硬件接口是TTL电平的，LCD这边硬件接口也是TTL电平的。所以他们俩本来是可以直接对接的，手机、平板、开发板都是这样直接对接的（一般用软排线连接）。

(3)TTL电平的**缺陷**就是不能**传递太远**，如果LCD屏幕和主板控制器太远（1米甚至更远）就不能直接TTL连接了，要进行转换。**转换方式**：主机SoC(TTL) ->VGA-> LCD屏幕(TTL)。

 

### 1.14.2.2、各种接口（TTL、LVDS、EDP、MIPI、）

在传输速率、距离、适配性方面不同（参考资料：http://blog.csdn.net/wocao1226/article/details/23870149）。

 

### 1.14.2.3、RGB接口详解(参考数据手册P1207页时序图)

(1)VD[23:0]：24根数据线，用来传输图像信息。可见LCD是并行接口，速率才够快。

(2)HSYNC(水平同步信号) 。

(3)VSYNC(垂直同步信号)：时序信号线，为了让LCD能够正常显示给的控制信号

(4)VCLK(像素时钟)：LCD工作时需要主板控制器给LCD模组一个工作时钟信号，就是VCLK。

(5)VDEN(数据有效标志)：时序信号，和HSYNC、VSYNC结合使用。

(6)LEND(行结束标志，不是必须的)：时序信号，非必须，譬如X210接口就没有。

 

 

## 1.14.3.LCD如何显示图像1

### 1.14.3.1、像素(pixel)

(1)像素就是组成图像的最基本元素，或者说显示中可以被控制的最小单位，整个图像就是由很多个像素组成的。

(2**单色屏：**像素可以被单独控制，或控制其亮或不亮。

**灰度屏：**控制其亮度强弱（譬如亮50%，35%，这样叫，以前的黑白电视机）、

**彩色显示屏：**控制其显示一定的颜色（这就是我们现在最常用的）。

**总结：**像素很重要，整个显示图像是由一个个的像素组成的。我们要在显示器上显示一个图像，就是把这个图像离散化成一个一个的点，然后把各个点的颜色对应在显示器的像素上。

### 1.14.3.2、扫描

(1)扫描是一个动作而不是一个名词，扫描就是依次将颜色数值放入屏幕中所有的像素的这个过程。

(2)扫描这个词是由最早的CRT显示器遗留下来的，到LCD显示器的年代本来已经失去意义了，但是我们还是延续着这么叫。

(3)显示器的扫描显示原理依赖于人眼的视觉暂留。只要显示器扫描频率大于人眼的发现频率，人眼看到的图像就是恒定的。如果扫描频率偏小人眼就会看到闪动。（扫描频率的概念就叫做刷新率）。

 

### 1.14.3.3、驱动器&控制器

 

(1)LCD驱动器一般和LCD显示面板集成在一起。本来是分开的，做面板的是只做面板的，譬如说三星、LG、台湾的友达、奇美都是做面板的；驱动器也由专门的IC厂商生产；集成厂商买来面板和驱动器后集成在一起做成LCD屏幕。

面板只负责里面的液晶分子旋转透光，面板需要一定的模拟电信号来控制液晶分子；LCD驱动器芯片负责给面板提供控制液晶分子的模拟电信号，驱动器的控制信号（数字信号）来自于自己的数字接口，这个接口就是LCD屏幕的外部接口（第二节中讲到的接口）。

(2)LCD控制器一般集成在SoC内部，他负责通过数字接口向远端的LCD驱动器提供控制像素显示的数字信号。LCD控制器的关键在于时序，它必须按照一定的时序和LCD驱动器通信；LCD控制器受SoC控制，SoC会从内存中拿像素数据给LCD控制器并最终传给LCD驱动器。

 

### 1.14.3.4、显示内存(简称：显存)

 

(1)SoC在内存中挑选一段内存（一般来说是程序员随便挑选的，但是挑选的时候必须符合一定规矩），然后通过配置将LCD控制器和这一段内存（以后称为显存）连接起来构成一个映射关系。一旦这个关系建立之后，LCD控制器就会自动从显存中读取像素数据传输给LCD驱动器。这个显示的过程不需要CPU的参与。SoC 主要是将flash中的图像放到内存中去，以及图像解码之类的工作。

(2)显示体系建立起来后，CPU就不用再管LCD控制器、驱动器、面板这些东西了；以后CPU就只关心显存了，因为我只要把要显示的图像的像素数据丢到显存中，硬件就会自动响应（屏幕上就能自动看到显示的图像了）。

 

**总结**：LCD显示是分为2个阶段的：

第一个阶段就是建立显示体系的过程，目的就是CPU初始化LCD控制器使其和显存联系起来构成映射；

第二个阶段就是映射建立之后，此阶段主要任务是将要显示的图像丢到显存中去。

 

 

## 1.14.5.LCD的六个主要时序参数

### 1.14.5.1、LCD显示单位：帧（frame）

(1)显示器上一整个画面的内容成为一个帧(frame)，整个显示器工作时是一帧一帧的在显示。

(2)电影实际就是以每秒种24帧的速度在播放图片。

(3)帧内数据：一帧分为多行，一行分为多像素，因此一帧图像其实就是多个像素组成的矩阵。

(4)帧外数据：整个视频由很多个帧构成，最终播放视频时逐个播放各个图像帧即可。

 

### 1.14.5.2、LCD显示一帧图像的过程

(1)首先把帧分为行，然后再把行分为像素，然后逐个像素去显示。（显示像素：其实就是LCD驱动器按照接收到的LCD控制器给的显示数据，驱动一个像素的液晶分子旋转，让这个像素显示出相应的颜色值的过程）

(2)关键点：**LCD****控制器和驱动器之间一次只能传一个像素点的显示数据**。所以一帧图像在屏幕上其实是串行的依次被显示上去的，不是同一时间显示出来的。

 

### 1.14.5.3、为了向前兼容出现的六个时序参数

HSPW 水平同步信号脉宽

HBPD 水平同步信号前肩

HFPD 水平同步信号后肩

VSPW 垂直同步信号脉宽

VBPD 垂直同步信号前肩

VFPD 垂直同步信号后肩

 

 

(1)一行的通信过程是这样的：LCD控制器先发送一个HSYNC高电平脉冲（脉冲宽度是HSPW），脉冲告诉驱动器下面的信息是一行信息。然后开始这一行信息，这一行信息包括3部分：HBPD+有效行信息+HFPD。其中前肩和后肩都属于**时序信息**（和LCD屏幕具体有关），有效行信息就是横向分辨率。所以你可以认为一行总共包含4部分：**HSPW+HBPD+****有效行信息+HFPD。**

 

(2)一帧图像其实就是一列，一列图像由多个行组成，每行都是上面讲的这个时序。

(3)一帧图像的通信过程是这样的：整个帧图像信号分为4部分：**VSPW+VBPD+****帧有效信号+VFPD**。VSPW是帧同步信号宽度，用来告诉驱动器一帧图像要开始了；VBPD和VFPD分别是垂直同步信号前后肩。

 

(4)**必须说明**：这6个参数对于LCD显示器其实本来是没用的，这些信号其实是老式的CRT显示器才需要的，LCD本身不需要，但是出于历史兼容性要求，LCD选择了兼容CRT显示器的这些时序要求，所以理解LCD显示器时序和编程时，用CRT的方式来理解不会错。

(5)要注意，这几个时序参数本身是LCD屏幕本身的参数，与LCD控制器无关。所以同一个主板如果接的屏幕不一样则时序参数设置也会不同。这些参数的来源一般是：第一，厂家会直接给出，一般以实例代码的形式给出；第二，来自于LCD的数据手册。

 

第一种方式，查看九鼎的210裸机教程（x210v3裸机开发教程\src\template-framebuffer-font\source\hardware\s5pv210-fb.c的第774行）

​       .h_fp           = 210,      // 160-210-354

​       .h_bp          = 38,       // 46

​       .h_sw          = 10,       // 1-40

​       .v_fp           = 22,       // 7-22-147

​       .v_fpe          = 1, 

​       .v_bp          = 18,       // 23

​       .v_bpe         = 1,    

​       .v_sw          = 7,    // 1-20

第二种方式，查看LCD数据手册（X210光盘资料\A盘\DataSheet\AT070TN92.pdf）

 

补充：

1、注意这些数字的单位。H开头的三个单位都是DCLK(像素时钟),V开头的三个单位是TH。这样设置的好处是我们改变了像素时钟的设置时，不用改变这里的时序参数。

2、这些时序参数如果没设置好会影响什么？屏幕会跑偏。

 

 

## 1.14.7.LCD显示的主要相关概念

### 1.14.7.1、像素（pixel）

(1)整个图像是由一个个的像素组成的，像素就是一个显示点。

### 1.14.7.2、像素间距（pitch）

(1)pitch是连续2个像素的像素中心的距离。一般的像素是方形的，所以横向pitch和纵向的pitch一样的。但是也有不一样的。

(2)像素间距会影响屏幕的最佳观看距离。像素间距大的适合远距离看，像素间距小的适合近距离看。

 

### 1.14.7.3、分辨率（resolution）

(1)整个屏幕的横向和纵向的像素个数就叫分辨率，譬如X210开发板用的屏幕是800×480.

(2)屏幕尺寸和分辨率无关的，像开发板的屏幕尺寸是7寸的（纯屏幕对角线尺寸是7英寸）。

(3)屏幕尺寸和分辨率和像素间距三者之间有关联。

 

### 1.14.7.4、清晰度

(1)清晰度是一个主观概念，是人眼对显示效果的一个主观判断。说白了就是人看起来感觉清晰不清晰。

(2)客观来讲，清晰度由分辨率和像素间距共同决定。一般的，屏幕尺寸固定时分辨率越高越清晰，分辨率越低就越不清晰；分辨率固定下，屏幕尺寸越小越清晰，越大越不清晰。

(3)清晰度还由其他很多因素共同决定。

 

### 1.14.7.5、像素深度（bits per pixel，简称bpp）

(1)一个像素在计算机中由多少个字节数据来描述。

(2)计算机中用二进制位来表示一个像素的数据，用来表示一个像素的数据位越多，则这个像素的颜色值更加丰富、分的更细，颜色深度就更深。

(3)一般来说像素深度有这么几种：1位、8位、16位、24位、32位 （调节亮度）。

 

 

## 1.14.8.颜色在计算机中的表示

### 1.14.8.1、颜色的本质

(1)颜色是主观存在，颜色其实是自然光在人的眼睛中和大脑中产生的一种映像。

(2)颜色的本质决定于光的波长。

### 1.14.8.2、自然光的颜色是连续的

(1)光的波长是连续的，导致颜色也是连续的。理论上，只要你的眼睛分辨能力足够好，可以在自然界中发现无数中颜色。

 

### 1.14.8.3、计算机中的颜色是离散的

(1)计算机中不可能存储无数种颜色，所以必须将颜色有限化，所以就用有限种颜色来代表自然界中的无限种颜色。这个理论非常类似于之前学过的AD转换。

(2)这种离散化表达颜色的缺点是不够真实，漏掉了很多种颜色。因此计算机中所能表达的颜色没有自然界中丰富（计算机屏幕上显示的图像和真实图像有差别）

(3)计算机所能表达的颜色种类个数，这个参数叫：像素深度bpp。

 

### 1.14.8.4、常见像素深度：1位、8位、16位、24位、32位

**1****位**：用1个二进制位来表示颜色，这种就叫单色显示。示例就是小饭店、理发店门口的LED屏。

**8****位**：用8个二进制位来表示颜色，此时能表示256种颜色。这种叫**灰度显示**。这时候是黑白的，没有彩色，我们把纯白到纯黑分别对应255到0，中间的数值对应不同的灰。示例就是以前的黑白电视机。

**16****位**：用16个二进制位表示颜色，此时能表示65536种颜色。这时候就可以彩色显示了，一般是**RGB565的颜色分布**（用5位二进制表示红色、用6位二进制表示绿色、用5位二进制表示蓝色）。这种红绿蓝都有的颜色表示法就是一种模拟自然界中所有颜色的表示方式。但是因为RGB的颜色表达本身二进制位数不够多（导致红绿蓝三种颜色本身分的都不够细致），所以这样显示的彩色失真比较重，人眼能明显看到显示的不真实。

**24****位**：用24个二进制位来表示颜色，此时能表示16777216种颜色。这种表示方式和16位色原理是一样的，只是RGB三种颜色各自的精度都更高了（RGB各8位），叫RGB888。此时颜色比RGB565更加真实细腻，虽然说比自然界无数种颜色还是少了很多，不过由于人眼的不理想性所以人眼几乎不能区分1677万种颜色和无数种颜色的差别了。**于是乎就把这种RGB888的表示方法叫做真彩色。（RGB565就是假彩色）。**

**32****位**：总共用32位二进制来表示颜色，其中24位表示红绿蓝三元色（还是RGB888分布），剩下8位表示透明度（颜色透明度）。这种显色方式就叫ARGB（A是阿尔法，表示透明度），现在PC机中一般都用ARGB表示颜色。

 

补充：**颜色的组成，三元色（三基色）是RGB，也就是说所有的颜色都可以由红绿蓝三种颜色组成。**

 

 

## 1.14.9.S5PV210的LCD控制器

### 1.14.9.1、FIMD结构框图

(1)210的LCD控制器叫FIMD，FIMD是210内部和图像处理相关的一些部件，在摄像头等和图像处理有关的部分都可以有关联。

(2)FIMD在内部与AHB总线等相连接，在外部提供RGB接口、I80接口、YUV接口与外部相连接，我们实际使用的是RGB接口。

 

### 1.14.9.2、虚拟屏幕叠加（数据手册P1194）

(1)虚拟屏幕的意思是，我们平时看到的屏幕上显示出来的场景实际是很多个屏幕显示叠加在一起的效果（譬如新闻图像、电视台台标、下方飘动的字幕新闻）

(2)像S5PV210的LCD控制器中有5个虚拟屏幕Window0到Window4，虚拟屏幕不存在于真实而存在于内存中。（之前讲过，LCD显示时实际是显示的是对应的内存中的显存区域的数值）虚拟屏幕其实就是一个内存中的显存区域，有几个显存区域就有几个虚拟屏幕，但是这些虚拟屏幕都被映射到一个真实的显示屏上面，所以将来真实的现实效果实际是这几个虚拟屏幕的显示内容的叠加。（叠加时要注意上面一层会覆盖下面一层，所以要注意谁在前谁在后，设置寄存器时有这个选项）。

(3)使用虚拟屏幕而不是整个LCD使用一个显存是有一定好处的：第一，可以保证不污染源图像，方便程序处理；第二，可以减少屏幕刷新，提高显示效率，减少CPU工作量。

 

### 1.14.9.3、虚拟显示（数据手册P1206）

(1)如何实现在小分辨率的屏幕上（真实）显示大分辨率的图像

(2)细节上，我们需要屏幕上看到不同图像时，需要对显存区域进行刷新。即使我们只需要屏幕显示移动一点点，整个屏幕对应的显存空间也需要整个重新刷新，工作量和完全重新显示一幅图像是一样的。这个显然不好，这样CPU刷新屏幕的工作量太大了，效率很低。

(3)如何能够在显示一个大图片的不同区域时让CPU刷新屏幕工作量减少？有，方法就是**虚拟显示**。具体做法就是在内存中建立显示缓存的时候实际建立一个很大的区域，然后让LCD去对应其中的一部分区域作为有效的显示区域。将来要显示大图像时，直接将大图像全部一次性加载入显示缓存区，然后通过移动有效显示区域就可以显示大图像的不同区域了。

 

### 1.14.9.4、主要寄存器简介

 

 

## 1.14.10.LCD编程实战1-LCD控制器初始化

参考代码lcd_init函数详解

(1)要想LCD工作，必须给LCD屏幕和显存之间建立一个映射（映射是在CPU初始化LCD控制器来完成的）。

本部分就是在完成这个过程（这也是LCD显示的2个阶段的第一阶段，第二阶段中我们只需要给显存中丢入相应的数据，LCD屏幕就会自动显示相应内容）。

\#include "main.h"

 

\#define GPF0CON     (*(volatile unsigned long *)0xE0200120)

\#define GPF1CON     (*(volatile unsigned long *)0xE0200140)

\#define GPF2CON     (*(volatile unsigned long *)0xE0200160)

\#define GPF3CON     (*(volatile unsigned long *)0xE0200180)

 

\#define GPD0CON     (*(volatile unsigned long *)0xE02000A0)

\#define GPD0DAT     (*(volatile unsigned long *)0xE02000A4)

 

\#define CLK_SRC1    (*(volatile unsigned long *)0xe0100204)

\#define CLK_DIV1    (*(volatile unsigned long *)0xe0100304)

\#define DISPLAY_CONTROL (*(volatile unsigned long *)0xe0107008)

 

\#define VIDCON0     (*(volatile unsigned long *)0xF8000000)

\#define VIDCON1     (*(volatile unsigned long *)0xF8000004)

\#define VIDTCON2    (*(volatile unsigned long *)0xF8000018)

\#define WINCON0     (*(volatile unsigned long *)0xF8000020)

\#define WINCON2     (*(volatile unsigned long *)0xF8000028)

\#define SHADOWCON    (*(volatile unsigned long *)0xF8000034)

\#define VIDOSD0A    (*(volatile unsigned long *)0xF8000040)

\#define VIDOSD0B    (*(volatile unsigned long *)0xF8000044)

\#define VIDOSD0C    (*(volatile unsigned long *)0xF8000048)

 

\#define VIDW00ADD0B0  (*(volatile unsigned long *)0xF80000A0)

\#define VIDW00ADD1B0  (*(volatile unsigned long *)0xF80000D0)

 

\#define VIDTCON0    (*(volatile unsigned long *)0xF8000010)

\#define VIDTCON1    (*(volatile unsigned long *)0xF8000014)

 

\#define HSPW      (40)        // 1~40 DCLK

\#define HBPD      (10 - 1)      // 46

\#define HFPD      (240 - 1)      // 16 210 354

\#define VSPW      (20)        // 1~20 DCLK

\#define VBPD      (10 - 1)      // 23

\#define VFPD      (30 - 1)      // 7 22 147

 

// FB地址

\#define FB_ADDR     (0x23000000)

\#define ROW       (900)

\#define COL       (1440)

\#define HOZVAL     (COL-1)

\#define LINEVAL     (ROW-1)

 

\#define XSIZE      COL

\#define YSIZE      ROW

 

// 初始化LCD

void lcd_init(void)

{

  // 配置引脚用于LCD功能

  GPF0CON = 0x22222222;

  GPF1CON = 0x22222222;

  GPF2CON = 0x22222222;

  GPF3CON = 0x22222222;

 

  // 打开背光 GPD0_0（PWMTOUT0）

  GPD0CON &= ~(0xf<<0);

  GPD0CON |= (1<<0);     // output mode

  GPD0DAT &= ~(1<<0);     // output 0 to enable backlight

 

  // 10: RGB=FIMD I80=FIMD ITU=FIMD

  DISPLAY_CONTROL = 2<<0;

 

  // bit[26~28]:使用RGB接口

  // bit[18]:RGB 并行

  // bit[2]:选择时钟源为HCLK_DSYS=166MHz

  VIDCON0 &= ~( (3<<26)|(1<<18)|(1<<2) );

 

  // bit[1]:使能lcd控制器

  // bit[0]:当前帧结束后使能lcd控制器

  VIDCON0 |= ( (1<<0)|(1<<1) );

 

  // bit[6]:选择需要分频

  // bit[6~13]:分频系数为5，即VCLK = 166M/(4+1) = 33M

  VIDCON0 |= 4<<6 | 1<<4;

 

  // H43-HSD043I9W1.pdf(p13) 时序图：VSYNC和HSYNC都是低脉冲

  // s5pv210芯片手册(p1207) 时序图：VSYNC和HSYNC都是高脉冲有效，所以需要反转

  VIDCON1 |= 1<<5 | 1<<6;

 

  // 设置时序

  VIDTCON0 = VBPD<<16 | VFPD<<8 | VSPW<<0;

  VIDTCON1 = HBPD<<16 | HFPD<<8 | HSPW<<0;

  // 设置长宽(物理屏幕)

  VIDTCON2 = (LINEVAL << 11) | (HOZVAL << 0);

 

  // 设置window0

  // bit[0]:使能

  // bit[2~5]:24bpp（RGB888）

  WINCON0 |= 1<<0;

  WINCON0 &= ~(0xf << 2);

  WINCON0 |= (0xB<<2) | (1<<15);

 

\#define LeftTopX   0

\#define LeftTopY   0

\#define RightBotX  1439

\#define RightBotY  899

 

  // 设置window0的上下左右

  // 设置的是显存空间的大小

  VIDOSD0A = (LeftTopX<<11) | (LeftTopY << 0);

  VIDOSD0B = (RightBotX<<11) | (RightBotY << 0);

  VIDOSD0C = (LINEVAL + 1) * (HOZVAL + 1);

 

  // 设置fb的地址(显存那段地址的首地址)

  VIDW00ADD0B0 = FB_ADDR;

​    //*4 是因为RGB888(24bit)，就是3Byte，但是因为3字节不对齐，所以用4字节对齐

  VIDW00ADD1B0 = (((HOZVAL + 1)*4 + 0) * (LINEVAL + 1)) & (0xffffff);//

  

  // 使能channel 0传输数据 使能window0

  SHADOWCON = 0x1;

}

 

 

### 1.14.11.LCD编程实战2-显示像素&刷背景

(1)显示像素

(2)刷背景色

static inline void lcd_draw_piexl(u32 x, u32 y, u32 color)

{  

  //base + (( 800 * y + x) * 4) ; base 内存的基地址

  *(pfb + COL * y + x) = color;    //u32指针本身可以*4 ，所以地址增加不用乘以4

 

}

 

//把整个屏幕全部填充成一个颜色color

static void lcd_draw_background(u32 color)

{

  u32 i, j;

  for(j=0; j<ROW; j++){

​    for(i=0; i<COL; i++){

​      lcd_draw_piexl(i,j,color);

​    }

  }

}

 

static void delay(void)

{

  u32 i, j;

  for(i=0; i<4000; i++)

​    for(j=0; j<1000; j++);

}

 

 void lcd_test(void)

{

  lcd_init();

  while(1){

​    lcd_draw_background(RED);

​    delay();

 

​    lcd_draw_background(GREEN);

​    delay();

 

​    lcd_draw_background(BLUE);

​    delay();

  }

}

 

 

### 1.14.12.LCD编程实战3-横线竖线斜线&画圆

(1)画横线&竖线

(2)斜线

// glib库中的画线函数，可以画斜线，线两端分别是(x1, y1)和(x2, y2)

void glib_line(unsigned int x1, unsigned int y1, unsigned int x2, unsigned int y2, unsigned int color)

{

  int dx,dy,e;

  dx=x2-x1; 

  dy=y2-y1;

  

  if(dx>=0)

  {

​    if(dy >= 0) // dy>=0

​    {

​      if(dx>=dy) // 1/8 octant

​      {

​        e=dy-dx/2; 

​        while(x1<=x2)

​        {

​          lcd_draw_pixel(x1,y1,color);

​          if(e>0){y1+=1;e-=dx;}  

​          x1+=1;

​          e+=dy;

​        }

​      }

​      else    // 2/8 octant

​      {

​        e=dx-dy/2;

​        while(y1<=y2)

​        {

​          lcd_draw_pixel(x1,y1,color);

​          if(e>0){x1+=1;e-=dy;}  

​          y1+=1;

​          e+=dx;

​        }

​      }

​    }

​    else      // dy<0

​    {

​      dy=-dy;  // dy=abs(dy)

 

​      if(dx>=dy) // 8/8 octant

​      {

​        e=dy-dx/2;

​        while(x1<=x2)

​        {

​          lcd_draw_pixel(x1,y1,color);

​          if(e>0){y1-=1;e-=dx;}  

​          x1+=1;

​          e+=dy;

​        }

​      }

​      else   // 7/8 octant

​      {

​        e=dx-dy/2;

​        while(y1>=y2)

​        {

​          lcd_draw_pixel(x1,y1,color);

​          if(e>0){x1+=1;e-=dy;}  

​          y1-=1;

​          e+=dx;

​        }

​      }

​    }  

  }

  else //dx<0

  {

​    dx=-dx;   //dx=abs(dx)

​    if(dy >= 0) // dy>=0

​    {

​      if(dx>=dy) // 4/8 octant

​      {

​        e=dy-dx/2;

​        while(x1>=x2)

​        {

​          lcd_draw_pixel(x1,y1,color);

​          if(e>0){y1+=1;e-=dx;}  

​          x1-=1;

​          e+=dy;

​        }

​      }

​      else    // 3/8 octant

​      {

​        e=dx-dy/2;

​        while(y1<=y2)

​        {

​          lcd_draw_pixel(x1,y1,color);

​          if(e>0){x1-=1;e-=dy;}  

​          y1+=1;

​          e+=dx;

​        }

​      }

​    }

​    else      // dy<0

​    {

​      dy=-dy;  // dy=abs(dy)

 

​      if(dx>=dy) // 5/8 octant

​      {

​        e=dy-dx/2;

​        while(x1>=x2)

​        {

​          lcd_draw_pixel(x1,y1,color);

​          if(e>0){y1-=1;e-=dx;}  

​          x1-=1;

​          e+=dy;

​        }

​      }

​      else    // 6/8 octant

​      {

​        e=dx-dy/2;

​        while(y1>=y2)

​        {

​          lcd_draw_pixel(x1,y1,color);

​          if(e>0){x1-=1;e-=dy;}  

​          y1-=1;

​          e+=dx;

​        }

​      }

​    }  

  }

}

 

//画圆函数，圆心坐标是(centerX, centerY)，半径是radius，圆的颜色是color

void draw_circular(unsigned int centerX, unsigned int centerY, unsigned int radius, unsigned int color)

{

  int x,y ;

  int tempX,tempY;;

  int SquareOfR = radius*radius;

 

  for(y=0; y<XSIZE; y++)

  {

​    for(x=0; x<YSIZE; x++)

​    {

​      if(y<=centerY && x<=centerX)

​      {

​        tempY=centerY-y;

​        tempX=centerX-x;            

​      }

​      else if(y<=centerY&& x>=centerX)

​      {

​        tempY=centerY-y;

​        tempX=x-centerX;            

​      }

​      else if(y>=centerY&& x<=centerX)

​      {

​        tempY=y-centerY;

​        tempX=centerX-x;            

​      }

​      else

​      {

​        tempY = y-centerY;

​        tempX = x-centerX;

​      }

​      if ((tempY*tempY+tempX*tempX)<=SquareOfR)

​        lcd_draw_pixel(x, y, color);

​    }

  }

}

 void lcd_test(void)

{

  lcd_init();

  lcd_draw_background(WHITE);

  draw_circular(511, 299 , 50, RED);

  glib_line(0, 599, 1023, 0, GREEN);

 

  

 

 

### 1.14.13.LCD编程实战4-写英文中文字符

 

//写字

//写字的左上角的坐标（x,y）,字的颜色是color， 字的字模信息储存在data中；

static void show_8_16(unsigned int x, unsigned int y, unsigned int color, unsigned char *data)

{

  int i, j, count = 0;

  for(j=y; j<(y+16); j++){

​    for(i=x; i<(x+8); i++){

​      if(i<XSIZE && j<YSIZE){

​        if(data[count/8] & (1<<(count%8)))

​          lcd_draw_pixel(i, j, color);

​      }

​      count++; 

​    }

  }

}

 

// 写字符串

// 字符串起始坐标左上角为(x, y)，字符串文字颜色是color,字符串内容为str

void draw_ascii_ok(unsigned int x, unsigned int y, unsigned int color, unsigned char *str)

{

  int i; 

  unsigned char *ch;

  for (i=0; str[i]!='\0'; i++) 

  { 

​    ch = (unsigned char *)ascii_8_16[(unsigned char)str[i]-0x20];

​    show_8_16(x, y, color, ch); 

​    

​    x += 8;

​    if (x >= XSIZE)

​    {

​      x -= XSIZE;     // 回车

​      y += 16;      // 换行

​    }

  } 

}

 

 void lcd_test(void)

{

  lcd_init();

  lcd_draw_background(WHITE);

  draw_ascii_ok(0,0,RED,"abcdABCD!@##$%^&*()_+");

 

  

}

 

 

 

## 1.14.14.LCD编程实战5-画图

### 1.14.14.1、图片显示分析

(1)图像是彩色的，而之前的文字、图形都是单色的。之前的图形文字绘制函数都有个color参数，就是传给显存告诉它这个像素的显示颜色。

(2)一副分辨率是800×480，BPP是24的图片，实际上就是800×480×3字节的数据。将来写代码将图片显示到LCD中时，图片将会以 unsigned char pic_data[800×480×3]的形式出现。

### 1.14.14.2、Image2LCD使用简介

(1)如何由一副图片得到它对应的数据的数组？要用取模工具，如Image2LCD。

### 1.14.14.3、画图函数的编写

 

 

 

1.14.15.LCD编程实战6-画图测试及调试

1.14.15.1、画图函数的显示效果测试

1.14.15.2、RGB的像素顺序调整

(1)图片中红色的变成了蓝色、蓝色的变成了红色，这就说明RGB顺序反了。

(2)解决方案一：重新使用Image2LCD来取模，取模时RGB顺序对调。

(3)解决方案二：不重新取模，改代码，在color形成的时候调换顺序。

 

1.14.15.3、小分辨率图片显示

(1)本质上大小分辨率的图像显示都是一样的，都是：都是在图像的每个像素点对应的显存中填入相应的颜色值即可。

 

 

## 1.14.16.未完成事项展望

### 1.14.16.1、RGB565和RGB888

(1)单片机等性能和资源有限的平台会用RGB565，嵌入式平台习惯用RGB888.

(2)有时候手头只有RGB888的颜色值，但是显示部分却只接受RGB565的（有时候反过来），这时候就需要在2种颜色之间做转换。

 

### 1.14.16.2、不同分辨率、不同起点坐标下的显示

(1)屏幕分辨率和图像分辨率不同时的显示。我们现在写的代码都是没有考虑的。

(2)图像起点坐标（左上角坐标）不一定在屏幕左上角，也可能在屏幕的任何其他区域，这种情况下画图的函数要做处理来支持。

(3)分辨率不同而且起始坐标不同下，这两个问题组合起来也对画图函数提出了更高要求。

 

### 1.14.16.3、bmp图片格式解析及显示

(1)我们当前的图像数据是用Image2LCD工具转过来的。实践中是不可能手工用工具来转的（你想一下Image2LCD也是一个软件，既然它能转，我们也应该可以用软件（代码）来转）。

(2)bmp格式的图片（原始图片，没有经过压缩的）本身遵照一定的格式来存储的，我们只需按照bmp的解析格式来读取文件就可得到这幅图片的图像数据的二进制，直接拿去显示。（这就是图片文件的本质）。

 

### 1.14.16.4、jgp、png、gif等压缩图片的解码和显示

(1)对于以上压缩格式的图片是不能直接解析的，必须用相应的库来解压缩图片之后才能拿来显示。

(2)不同的格式的图片其压缩算法不同，解压缩算法自然也不同。**开源社区中每种压缩格式都有个对应的库，库里提供了这种格式的压缩和解压缩函数，我们只需要移植这个库并且调用它来压缩或解压缩即可。**

### 1.14.16.5、图片缩小和放大显示

(1)图片数据源本来是400×200的，但是显示时我希望显示成100×50的，这时候就要显示函数后台对源图像进行先缩小，然后再显示。这时候就需要一个缩小算法。（譬如最简单的算法就是抽点采样）

(2)图片数据源是100×50的，但是显示时希望全屏显示（800×480），这时候就需要对源图像进行放大然后再显示（当然了显示出来图像清晰度肯定比较低），这时候就需要一种放大算法（譬如插点方式）

### 1.14.16.6、显示动画

(1)动态刷屏形成动画

(2)立体3D图像显示（伪3D）



 

# 第十五章 触摸屏TouchScreen

## 1.15.0 章节概要

**1.15.1.输入类设备简介**

​    本节简单介绍计算机的输入类设备，详细介绍了触摸屏这种输入设备的特点、分类以及相关概念，本节希望大家对触摸屏有一个全面清晰的认识先。

**1.15.2.电阻式触摸屏的原理**

​    本节讲解电阻式触摸屏的工作原理，目的是让大家明白电阻式触摸屏的工作方式，以便将来需要时更好的分析电阻式触摸屏的代码。

**1.15.3.S5PV210的电阻触摸屏控制器**

​    本节讲解S5PV210的电阻触摸屏控制器，主要讲解了控制器框图、工作方式、编程方法及主要寄存器，试图让大家进一步理解电阻式触摸屏的工作方式和编程方式。

**1.15.4.电容触摸屏的原理**

​    本节讲解电容式触摸屏的工作原理，以及电容式触摸屏和I2C总线的关系。本节的目标是使大家对电容式触摸屏的原理和编程模式有本质性的认识，以利于将来分析触摸屏的驱动代码。

**1.15.5.ft5x06电容触摸IC简介**

​    本节课简单介绍ft5x06这款常用的电容触摸IC，主要讲了它的工作模式、I2C接口、寄存器、触摸事件等，试图让大家对电容触摸屏进一步有所理解。

## 1.15.1.输入类设备简介

### 1.15.1.1、input/output

(1)IO输入输出，是计算机系统中的一个概念。计算机的主要功能就是从外部获取数据然后进行计算加工得到输出数据并输出给外部（计算机可以看成数据处理器）。计算机和外部交互就是通过IO。每一台计算机都有个标准输入和标准输出。

### 1.15.1.2、常见输入类设备

(1)键盘、鼠标、触摸屏、游戏摇杆、传感器、（摄像头并不是一个典型的输入类设备）

 

### 1.15.1.3、触摸屏的特点

(1)触摸屏和人的关系很紧密，尤其是电容式触摸屏。

(2)触摸屏和显示器关系很紧密。

(3)典型应用：手机、平板电脑、收银机、工业领域。

### 1.15.1.4、触摸屏的分类

(1)常见的触摸屏分为2种：电阻式触摸屏和电容式触摸屏。早期用电阻式触摸屏，后来发明了电容式触摸屏。

(2)这两种的特性不同、接口不同、编程方法不同、原理不同。

 

### 1.15.1.5、触摸屏和显示屏的联系与区别

(1)首先要搞清楚：触摸屏是触摸屏，用来响应人的触摸事件的；显示屏是显示屏，用来显示的。现在用的显示屏一般都是LCD。

(2)为什么很多人会搞混这两个概念，主要是因为一般产品上触摸屏和显示屏是做在一起的。一般外层是一层触摸屏，触摸屏是透明的，很薄；底下是显示屏用来显示图像，平时看到的图像是显示屏显示并且透过触摸屏让人看到的。

 

 

## 1.15.2.电阻式触摸屏的原理

###    1.15.2.1、薄膜+玻璃（需要尖锐硬物点击）

 

(1)要点是薄、透明。前面板硬度稍弱，可以被硬物按下弯曲，后面板硬度很高，不会弯曲。

(2)前面板和后面板在平时没有挨住，在外力按下之下，前面板发生（局部）形变，在这一点上前后面板会挨住。

 

### 1.15.2.2、ITO（导电+透明+均匀压降）

 

(1)ITO是一种材料，其实是一种涂料，特点就是透明、导电、均匀涂抹。

(2)本来玻璃和塑料都是不导电的，但是涂上ITO之后就变成导电了（同时还保持着原来透明的特性）。

   (3)ITO不但导电而且有电阻，所以中间均匀涂抹了ITO之后就相当于在x1和y1之间接了一个电阻，在x2和y2之间也接了一个电阻。因为ITO形成的等效电阻在整个板上是均匀分布的，所在在板子上某一点的电压值和这一点的位置值成正比。

(4)触摸屏经过操作，按下之后要的就是按下的坐标，坐标其实就是位置信息，这个位置信息和电压成正比了，而这一点的电压可以通过AD转换得到。这就是整个电阻式触摸屏的工作原理。

 

### 1.15.2.3、X/Y轴分时AD转换

 

   (1)下面要研究如何得到按下的这点的电压。

(2)在第一个面板的一对电极上加电压，然后在另一个面板的一个电极和第一个面板的地之间去测量。在没有按下时测试无结果(y1,y2不接地)，但是在有人按下时在按下的那一点2个面板接触（y1,y2接地了，），接触会导致第二个面板上整体的电压值和接触处的电压值相等，所以此时测量到的电压就是接触处在第一个面板上的电压值。

(3)以上过程在一个方向进行一次即可测得该方向的坐标值，进行完之后**撤掉电压然后**在另一个方向的电极上加电压，故伎重施，即可得到另一个方向的坐标。至此一次触摸事件结束。

 

### 1.15.2.4、电压值对应坐标值（校准）

(1)电压值和坐标值成正比的，所以需要去校准它。校准就是去计算(0, 0)坐标点的电压值是多少。

 

### 1.15.2.5、思考：为什么电阻式触摸屏不支持多点触摸

 

 

## 1.15.3.S5PV210的电阻触摸屏控制器

### 1.15.3.1、ADC与触摸屏控制器结构框图

 

(1)S5PV210一共支持10路模拟输入，分别为AIN0-AIN9.其中AIN0和AIN1是只做模拟输入的，AIN2-AIN9分别可以支持2个电阻式触摸屏。所以4个模拟输入引脚负责一个电阻式触摸屏。

(2)AD转换和触摸屏控制部分有2个附属单元。其中一个是反向控制AINn引脚的逻辑，主要作用是在触摸屏获取坐标的过程中分时给xy方向供电和测量；第二个是中断产生部件，如果AD转换完成（主要针对AIN0和AIN1这两路的）或者触摸屏被人按下/弹起时，中断产生部件会产生一个中断通知CPU来处理事件，这样就不用轮询监测触摸屏事件了。

 

### 1.15.3.2、Normal Operation Mode & Separate X/Y Position Convertion Mode

(1)**AD****转换器有2种工作模式**：正常操作模式和分时X/Y位置转换模式。

(2)正常操作模式用作普通的AD转换，分时X/Y位置转换模式用作**电阻式触摸屏**。正常AD转换下将AD转换值放在TSDATX中，在分时X/Y模式下会将X/Y坐标分别放在TSDATX和TSDATY中。

(3)对于AIN0和AIN1来说没有这么多模式，他们只能工作在**普通模式**；对于AIN2-AIN9来说，因为被复用，所以才有2种模式。如果我们将这几个引脚用作普通AD转换则配置为普通模式，如果用作电阻式触摸屏检测，则配置成**分时X/Y模式**。

 

### 1.15.3.3、中断参与

(1)其实普通AD转换和触摸屏AD转换本身都可以不在中断参与下完成。

(2)普通AD转换如果不要中断，那就去查询。开启一次转换后然后不断查询标志位，直到AD转换完硬件自动置位标志位后我们才去读取转换值就不会错。当然也可以用中断，控制器提供了一个相应的中断给普通AD转换。

(3)触摸屏也可以用或者不用中断。对于SoC来说永远不知道人会什么时候按下或者弹起触摸屏，所以触摸屏的按下/弹起对SoC来说是纯粹的异步事件。对于这种情况SOC只有2种解决方案：轮询和中断。

### 1.15.3.4、主要寄存器

## 1.15.4.电容触摸屏的原理

### 1.15.4.1、人体电流感应

   (1)利用人体电流感应现象，在手指和屏幕之间形成一个电容，手指触摸时吸走一个微小电流，这个电流会导致触摸板上4个电极上发生电流流动，控制器通过计算这4个电流的比例就能算出触摸点的坐标（这个计算过程中涉及到AD转换）。

 

### 1.14.4.2、专用电路计算坐标

(1)电阻式触摸屏本身是一个完全被动器件，里面没有任何IC和电路，它的工作逻辑完全在SoC控制器上；但是电容式触摸屏不同，电容式触摸屏需要自带一个IC进行坐标计算。因此电容式触摸屏工作时不需要主机SoC控制器参与。

(2)为什么这样设计？主要原因是因为电容式触摸屏的坐标计算太复杂，普通程序员无法写出合适的代码解决这个问题，因此在电容式触摸屏中除了触摸板之外还附加了一个IC进行专门的坐标点计算和统计。这个IC全权负责操控触摸板得到触摸操作信息，然后再通过数字接口和主机SoC进行通信。

 

### 1.14.4.3、多个区块支持多点触摸

(1)电阻触摸屏不支持多点触摸，这是它本身的原理所限制，无法改变无法提升。

(2)电容式触摸屏可以支持多点触摸（也可以单点触摸）。按照之前讲的电容式触摸屏的原理，单个电容式触摸屏面板也无法支持多点触摸，但是可以将一个大的触摸面板分成多个小的区块，每个区块相当于是一个独立的小的电容式触摸屏面板。

(3)多个区块支持多点触摸让电容触摸屏坐标计算变复杂了，但是这个复杂性被电容触摸IC吸收了，还是通过数字接口和主机SoC通信报告触摸信息（触摸点数、每个触摸点的坐标等）。

### 1.14.4.4、对外提供I2C的访问接口

(1)整个电容触摸屏包含2部分：**触摸板**和**电容触摸IC**。触摸板就是一个物理器件，电容触摸IC一般做到触摸屏的软排线（FPC）上面，电容触摸IC负责操控触摸板、通过AD转换和分析得到触摸点个数、触摸坐标等信息，然后以特定的数字接口与SoC通信。这个数字接口就是I2C。

(2)对于我们主机SoC来说，电容式触摸屏其实就是一个I2C从设备。主机只需要通过I2C总线对这个从设备进行访问即可（从设备有自己特定的从设备地址）。**从这里来讲，其实电容式触摸屏和其他的传感器（gsensor等）并没有任何区别。**

## 1.15.5.ft5x06电容触摸IC简介

### 1.15.5.1、电阻式触摸屏和电容式触摸屏的特点对比

(1)耐久性       电容式触摸屏不容易坏，电阻式触摸屏易坏

(2)抗干扰性     电容式触摸屏差一些，电阻式触摸屏要好一些

(3)精准度       电容式触摸屏差一些，电阻式触摸屏好一些  

(4)用户体验     电容式触摸屏要好一些，电阻式触摸屏要差一些

(5)价格         电容式触摸屏贵一些，电阻式触摸屏便宜很多

### 1.15.5.2、思考：为什么工业应用中要用电阻式触摸屏？

(1)消费电子产品（手机、平板电脑）用电容式触摸屏。但是在工业领域都是用电阻式触摸屏，就是因为工业领域环境比较恶劣，电容式触摸屏容易受干扰，所以不合适。

### 1.15.5.3、触摸屏的发展方向

(1)更薄、更透明、更精准、支持点数更多。

(2)把电容触摸屏和LCD做在一起。可以做到更薄、更透明、价格更低。但是面临的困难是抗干扰性要求更高。

### 1.15.5.4、ft5x06的数据手册浏览

(1)软件工程师并不关心触摸屏的工艺问题，只关心软件编程接口（物理层是I2C）。



 

# 第十六章 shell原理和问答机制引入

## 1.16.1.shell是什么鬼

### 1.16.1.1、壳与封装

(1)shell就是壳的意思，在计算机中经常提到shell是用户操作接口的意思。

(2)因为计算机程序本身很复杂，里面的实现和外面的调用必须分开。接口本身就是对内部复杂的实现的一种封装，外部只需要通过接口就可以很容易的实现效果，但是却不用理会内部实现的复杂性和原理。

 

### 1.16.1.2、程序或操作系统的用户接口

(1)操作系统运行起来后都会给用户提供一个操作界面，这个操作界面就叫shell。用户可以通过shell来调用操作系统内部的复杂实现。

(2)shell编程就是在shell层次上进行编程。譬如linux中的脚本编程、windows中的批处理。

 

### 1.16.1.3、两种shell：GUI和cmdline

(1)GUI（图形用户界面），特点是操作简单、易学易用，适合使用电脑来工作的人。

(2)cmdline(命令行界面)，譬如linux的终端和windows的cmd，特点是不易用易学，优点是可以进行方便的shell编程，适合做开发的人。

(3)展望：将来的shell应该是声音图像等接口的。

 

### 1.16.1.4、shell的运行原理：由消息接收、解析、执行构成的死循环

(1)我们主要分析命令行shell的运行原理。

(2)**命令行shell其实就是一个死循环**：这个死循环包含3个模块，这3个模块是串联的，分别是命令接收、命令解析、命令执行。

(3)**命令行有一个标准命令集**：用户在操作的时候必须知道自己想要的操作用通过哪个命令来实现，不能随便输入命令。如果用户输入了一个不是标准命令的命令（不能识别的命令），提示用户这不是一个合法命令，然后重新回到命令行让用户输入下一个命令。

(4)**用户输入命令的界面是一个命令行**：命令行的意思就是用户输入的命令是以行为单位的，更好理解的说用户输入的命令在用户按下回车键之后就算是结束了，shell可以开始接收了。

\#include<stdio.h>

\#include<stdlib.h>

\#include<string.h>

 

\#define MAX_LINE_LENGTH 256   //命令行的长度

 

int main(void)

{  

  char ustr[MAX_LINE_LENGTH];   //用来存放用户输入的内容

 

  while(1){

​    //打印命令行提示符,注意不能加换行

​    printf("Sheridan#");

​    //清除数组

​    memset(ustr, 0, sizeof(ustr));

 

​    //获取用户输入的命令

​    scanf("%s",ustr);

​    

​    //shell 第二步：解析用户输入命令

 

​    //shell 第三步：处理用户输入的命令

​    printf("%s\n",ustr);

  }

  return 0;

}

 

### 1.16.1.5、shell举例：uboot、linux终端、Windows图形界面等

(1)常见的shell，uboot就是一个裸机程序构成的shell（本课程要完成的shell也是裸机的），Linux的终端和windows的cmd是操作系统下的命令行shell。windows图形界面、ubuntu图形界面、android的图形界面这些都是图形界面的shell。突然想到另一个类型的shell，网页类型的shell，典型代表就是路由器。

 

 

## 1.16.2.shell实战1-从零写最简单shell

### 1.16.2.1、使用printf和scanf做输入回显、定义简单命令集

\#include<stdio.h>

\#include<stdlib.h>

\#include<string.h>

 

\#define MAX_LINE_LENGTH   256   //命令行的长度

 

//宏定义一些标准命令

\#define led    "led"

\#define lcd    "lcd"

\#define pwm    "pwm"

\#define CMD_NUM    3   //当前系统定义的命令数

 

char g_cmdset[CMD_NUM ][MAX_LINE_LENGTH];

 

//初始化命令列表

static void init_cmd_set(void)

{

  memset(g_cmdset, 0, sizeof(g_cmdset) );

  strcpy(g_cmdset[0],led);

  strcpy(g_cmdset[1],lcd);

  strcpy(g_cmdset[2],pwm);

}

 

int main(void)

{  

  int i;

  char ustr[MAX_LINE_LENGTH];   //用来存放用户输入的内容

 

  init_cmd_set();

 

  while(1){

​    //打印命令行提示符,注意不能加换行

​    printf("Sheridan#");

​    //清除数组

​    memset(ustr, 0, sizeof(ustr));

 

​    //获取用户输入的命令

​    scanf("%s",ustr);

​    printf("ustr:%s\n",ustr);

​    printf("g_cmdset:%s\n",g_cmdset[0]);

​    printf("g_cmdset:%s\n",g_cmdset[1]);

​    printf("g_cmdset:%s\n",g_cmdset[2]);

​    //shell 第二步：解析用户输入命令

​    for(i=0; i<CMD_NUM; i++){

​      if( !strcmp(g_cmdset[i],ustr)){

​        //相等，找到了这个命令，就去执行这个命令所对应的的动作

​        printf("%s合法\n",ustr);

​        break;

​      }

​      

​    }

​    if(i>=CMD_NUM){

​      //找遍了命令集都没找到这个命令

​      printf("%s不是内部合法命令，请重新输入\n",ustr);

​    }

 

​    

  }

  return 0;

}

 

 

## 1.16.3.shell实战2-将简易shell移植到开发板中

### 1.16.3.1、工程选定、文件复制、Makefile书写

 

### 1.16.3.2、printf和scanf函数（本质是putc和getc函数）的移植

(1)puts和putchar函数比较简单，注意的地方就是windows和linux中的回车键定义的不同。

所以在putchar函数中如果用户要输出'\n'时，实际输出"\r\n"

(2)gets和getchar是从Windows中的SecureCRT终端输入字符串到裸机程序中。这里面至少有3个问题：用户输入回显问题、用户按回车键问题、用户按BackSpace退格键问题

(3)自己实现回显

(4)用户按回车键问题，在getchar中解决。方法是碰到'\r'时直接返回'\n'

 

### 1.16.3.3、编译下载和调试验证

Main.c

void puts(const char *p);

char *gets(char *p);

void uart_init(void);

 

// C标准库中也有个memset函数，但是我们这里用的是自己写的，没用标准库

void memset(char *p, int val, int length)

{

  int i;

  

  for (i=0; i<length; i++)

  {

​    p[i] = val;

  }

}




int main(void)

{

  char buf[100] = {0};    // 用来暂存用户输入的命令

  

  uart_init();

  

  puts("x210 simple shell:\n");

  while(1)

  {

​    

​    puts("aston#");

​    memset(buf, 0, sizeof(buf));    // buf弄干净好存储这次用户输入

​    gets(buf);             // 读取用户输入放入buf中

​    puts("您输入的是：");

​    puts(buf);

​    puts("\n");

  }

  

  return 0;

}

 

 

## 1.16.4.shell实战3-定义标准命令集及解析

### 1.16.4.1、添加cmd_parser和cmd_exec

**Main.c**

\#include "shell.h"

 

static void shell_init(void)

{

  // shell init

  init_cmd_set();

  uart_init();

  puts("x210 simple shell:\n");    // shell logo

}

 

int main(void)

{

  char buf[MAX_LINE_LENGTH] = {0};    // 用来暂存用户输入的命令

  

  shell_init();

 

  while(1)

  {

​    // 第1步：命令获取

​    puts("Shridan#");

​    memset(buf, 0, sizeof(buf));    // buf弄干净好存储这次用户输入

​    gets(buf);             // 读取用户输入放入buf中

​    // 第2步：命令解析

​    cmd_parser(buf);

​    // 第3步：命令执行

​    cmd_exec();

  }

  

  return 0;

}

 

 

### 1.16.4.2、实现简单的cmd_parser

// 解析命令

void cmd_parser(char *str)

{

  int i;

 

​    //第一步，现将用户的次命令（字符串）分割放入cmd中

​    cmdsplit(cmd, str);

​    //第二步，将cmd中的次命令的第一个字符串和g_cmdset对比

 

  for(i=0; i<CMD_NUM; i++)    {

​    if (!strcmp(cmd[0], g_cmdset[i]))

​    {

​      // 相等，找到了这个命令，就去执行这个命令所对应的动作。

​      cmd_index = i;

​      cmd_exec();

​      break;

​      }  

​    }

}

 

### 1.16.4.3、实现对应的cmd_exec

// 执行命令

void cmd_exec(void)

{

  switch (cmd_index){

​    case  0:

​    case  1:

​    case  2:

​    default :   do_cmd_notfound(); break;

​          

  }

}

 

 

 

## 1.16.5.shell实战4-添加第一个命令

### 1.16.5.1、命令任务分析

(1)第一个命令：led，实现的功能是控制板载LED的亮和灭

(2)命令定义：led on 表示点亮led，led off 熄灭led

(3)扩展：led 1 on 表示点亮第一个led。（课堂不实现，留给大家做作业）

 

###    1.16.5.2、命令解析

(1)命令解析其实就是把一个类似 led on这种命令解析成led和on两个字符串，放在一个字符串数组中。

char g_cmdset[CMD_NUM][MAX_LINE_LENGTH];    // 命令集，存主命令

char cmd[MAX_CMD_PART][MAX_LEN_PART];      // 当前解析出来的命令

int cmd_index = -1;               // 存储解析到的命令是第几个主命令

 

// 初始化命令列表

void init_cmd_set(void)

{

  memset((char *)g_cmdset, 0, sizeof(g_cmdset));   // 先全部清零

  strcpy(g_cmdset[0], led);

  strcpy(g_cmdset[1], lcd);

  strcpy(g_cmdset[2], pwm);

  

  memset((char *)cmd, 0, sizeof(cmd));  

}

 

 

 

void cmdsplit(char cmd[][MAX_LEN_PART], const char *str)

{

  int m = 0, n = 0;  // m表示二位数组第一维，n表示第二维

  while (*str != '\0')

  {

​    if (*str != ' ')

​    {

​      cmd[m][n] = *str;

​      n++;

​    }

​    else

​    {

​      cmd[m][n] = '\0';

​      n = 0;

​      m++;

​    }

​    str++;

  }

  cmd[m][n] = '\0';

}

 

 

// 解析命令

void cmd_parser(char *str)

{

  int i;

  

  // 第一步，先将用户输入的次命令字符串分割放入cmd中

  cmdsplit(cmd, str);

  

  // 第二步，将cmd中的次命令第一个字符串和cmdset对比

  cmd_index = -1;

  for (i=0; i<CMD_NUM; i++)

  {

​    // cmd[0]就是次命令中的第一个字符串，也就是主命令

​    if (!strcmp(cmd[0], g_cmdset[i]))

​    {

​      // 相等，找到了这个命令，就去执行这个命令所对应的动作。

​      //puts("您输入的命令是：");

​      //puts(str);

​      //puts("\n");

​      cmd_index = i;

​      

​      break;

​    }

  }  

 

// 执行命令

void cmd_exec(void)

{

  switch (cmd_index)

  {

​    case 0:

​      do_cmd_led();      break;

​    case 1:

​    case 2:

​    default:

​      do_cmd_notfound();   break;

  }

}

 

## 1.16.6.shell实战5-添加其他命令1

### 1.16.6.1、第一个硬件LED的控制

Led.c

\#define GPJ0CON   0xE0200240

\#define GPJ0DAT   0xE0200244

 

\#define rGPJ0CON  *((volatile unsigned int *)GPJ0CON)

\#define rGPJ0DAT  *((volatile unsigned int *)GPJ0DAT)

 

void delay(void);

 

void delay(void)

{

  volatile unsigned int i = 900000;    // volatile 让编译器不要优化，这样才能真正的减

  while (i--);              // 才能消耗时间，实现delay

}

 

//led 初始化

void led_init() 

{

  // led初始化，也就是把GPJ0CON中设置为输出模式

  //volatile unsigned int *p = (unsigned int *)GPJ0CON;

  //volatile unsigned int *p1 = (unsigned int *)GPJ0DAT;

  rGPJ0CON = 0x11111111;

  rGPJ0DAT = ((1<<3) | (1<<4) | (1<<5));

}

 

void led_on()

{

  // led亮

  rGPJ0DAT = ((0<<3) | (0<<4) | (0<<5));

}

 

void led_off()

{

  //led 灭

  rGPJ0DAT = ((1<<3) | (1<<4) | (1<<5));

}

 

 void led1_on()

{

  //led 灭

  rGPJ0DAT = ((0<<3) | (1<<4) | (1<<5));

}

void led2_on()

{

  //led 灭

  rGPJ0DAT = ((1<<3) | (0<<4) | (1<<5));

}

void led3_on()

{

  //led 灭

  rGPJ0DAT = ((1<<3) | (1<<4) | (0<<5));

}

 

 

 

Cmd.c

// led命名的处理方法

void do_cmd_led(void)

{

  int flag = -1;

  char *error_cmd_str = "led";

 

  //点亮全部led灯

​    // cmd[0]里面是led,cmd[1]里面是on|off

  if(!strcmp(cmd[1], "on")){

​    //led on

​    led_on();

​    flag = 1;

  }if(!strcmp(cmd[1], "off")){

​    //led off;

​    led_off();

​    flag = 1;

  }else{

​    flag = -2;

​    //点亮或者关闭单个led灯 

​    if(!strcmp(cmd[1], "1")){

​      if(!strcmp(cmd[2], "on")){

​        led1_on();

​        flag = 1;

​      }  

​    }if(!strcmp(cmd[1], "2")){

​      if(!strcmp(cmd[2], "on")){

​        led2_on();

​        flag = 1;

​      }

​    }if(!strcmp(cmd[1], "3")){

​      if(!strcmp(cmd[2], "on")){

​        led3_on();

​        flag = 1;

​      }    

​    }

  }

 

  error_print(flag, error_cmd_str);    

}

其他命令的添加如法炮制

 

## 1.16.7.shell实战6-添加其他命令2

这个的注意lcd移植的时候的重定位

## 1.16.8.shell实战7-实现开机倒计时自动执行命令1

(1)计时功能。要用计时的部件（定时器）来完成。

(2)主程序

注意：C语言中声明全局变量时不能加初始化，如果加了编译器就会把这个声明当作定义

 

## 1.16.9.shell实战7-实现开机倒计时自动执行命令2

Wdt.c

//wdt作为定时用来所有初始化

 

void wdt_timer_init(void)

{

  wdt_init_interrupt();

 

  system_init_exception();

 

 // 绑定isr到中断控制器硬件

  intc_setvectaddr(NUM_WDT,isr_wdt);

}

 

unsigned long getvicirqstatus[4] = {VIC0IRQSTATUS,VIC1IRQSTATUS,VIC2IRQSTATUS,VIC3IRQSTATUS};

if(getvicirqstatus[i] != 0){

 

if语句调用 getvicirqstatus[4] 里面的地址的值得时候会导致 程序在串口输出乱码，暂时找不到解决办法 

找到原因了，是因为.bin 文件超过了16k，现在只要将程序分为BL1和BL2两部分就可以解决。     

## 1.16.10.shell实战8-初步实现环境变量1

### 1.16.10.1环境变量就好象程序的全局变量一样，整个程序中唯一

环境变量就好象程序的全局变量一样，整个程序中唯一。可以影响程序的执行，环境变量可以支持一些命令来查询环境变量、设置环境变量、保存环境变量（必须借助flash才能完成。本节只在内存中实现环境变量所以无法保存）。

环境变量的几个函数 env_init(); env_get(); env_set();

 void env_init(void)

 {

   memset((char *)envset, 0 ,sizeof(envset));

   strcpy(envset[0].env_name,"bootdelay");

   strcpy(envset[0].env_val,"5");

   envset[0].is_used = 1;

  //第二个环境变量

  strcpy(envset[1].env_name,"bootcmd");

   strcpy(envset[1].env_val,"/user/bin");

   envset[1].is_used = 1;

 

 }

// 成功找到env则返回0，失败则返回1.

int env_get(const char *pEnv, char *val)

 {

   int i;

   for(i = 0; i < sizeof(envset)/sizeof(envset[0]); i++){

​     if(!envset[i].is_used){

​       continue;

​     }

​     if(!strcmp(envset[i].env_name,pEnv)){

​       //找到环境变量

​       strcpy(val, envset[i].env_val);

​       return 0;

​     }

   }

   return 1;

 }

 

 void env_set(const char *pEnv, const char *val)

 {

   int i;

   // 先找目前有没有这个环境变量，如果有就直接改值

   for(i = 0; i < sizeof(envset)/sizeof(envset[0]); i++){

​     if(!envset[i].is_used){

​       continue;

​     }

​     if(!strcmp(envset[i].env_name,pEnv)){

​       //找到环境变量

​       strcpy( envset[i].env_val, val);

​       return;

​     }

   }

   

   //没找着就新建一个环境变量

  for(i = 0; i < sizeof(envset)/sizeof(envset[0]); i++){

​     if(envset[i].is_used){

​       continue;      

​     }

​    strcpy(envset[i].env_name, pEnv);

​    strcpy(envset[i].env_val, val);

​    envset[i].is_used = 1;

​    return;

   }

   

​     //找遍了环境变量的数组，还是没有空位，说明已经存满了

​     printf("环境变量已经存满！\n\r");

   

 }

 

 

void global_init(void)

{

  char val[20] = {0};

  if(env_get("bootdelay", val)){

​    printf("env bootdelay not found.\n\r");

​    return; 

  }

  //字符串转数字，字符串格式的"5"转成数字格式的5赋值给g_bootdelay

  g_bootdelay = my_strtoul(val, (char *)0,10);

}

将环境变量bootdelay的字符转换成值赋值给g_bootdelay;

 